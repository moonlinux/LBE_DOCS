******Sistema mínimo como root********************************************************************************************

Fuentes:
-Preguntar a clever en el canal #raspberrypi
https://www.linux.it/~rubini/docs/init/init.html

***************
*NOTAS PREVIAS*
***************

--Lo más importante que debes saber es que lo importante de un nodo en /dev no es un nombre, sino sus MAJOR y MINOR numbers.
Los puedes ver en un sistema "normal" con ls -l /dev/loquesea. Por ejemplo, con "ls -l /dev/tty" vemos:
crw-rw-rw- 1 root tty 5, 0 nov 16 03:54 /dev/tty
De donde deducimos que tenemos que creat /dev/tty con major 5 y minor 0. ESE ES EL MODO EN QUE EL KERNEL SABER CÓMO USARLO,
SU NOMBRE ES LO DE MENOS.
Entonces, ese nodo se crearía a mano con:
mknod -m 666 /dev/tty c 5 0
Y si miramos tty1 con "ls -l /dev/tty1", vemos:
crw--w---- 1 root tty 4, 1 nov 15 16:23 /dev/tty1
Así que ese nodo se crearía a mano con:
mknod -m 660 /dev/tty c 4 1
LA COSA es que, si necesitamos crear nodos a mano, los miramos con ls -l en un sistema funcional, y deducimos cómo crearlos
a mano nosotros con mknod.

--UDEV se encarga de cargar los módulos para el hardware que tengamos conectado, PERO no crea nodos en /dev a no ser que
tenga las rules necesarias, que creo que se las pasa systemd. Vamos, que no crea nodos para el hardware cuyos módulos carga,
por eso los creamos nosotros a mano en el script de inicio, como vas a ver.
Los nodos del hardware que está built-in en el kernel sí que los crea el kernel, pero para ello tiene que tener la funcionalidad
CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y.

--Como montamos tmpfs en /dev, los módulos que se crean en cada sesión son creados en RAM, así que se pierden en cada reinicio.
Supongo que es posible tener nodos estáticos, pero ni idea de momento.

--Partimos de la premisa de que al kernel le pasamos console=tty1, claro. Si usamos otra tty, pues habrá que crear esa otra TTY
y mandar el sh a correr en esa otra tty.

*******************
*FIN NOTAS PREVIAS*
*******************

El siguiente script es el que puedes poner como script mínimo de arranque para levantar un sistema usable sin systemd
ni ningún otro proceso init.
Yo lo he puesto como /root/minimal, con permisos de ejecución, y luego en cmdline.txt he puesto
init=/root/minimal rw
Lo de rw es directamente para montar el root como read-write.

********************************************************
*EMPIEZA EL SCRIPT BÁSICO (LO IMPORTANTE DE TODO ESTO) *
********************************************************

#!/bin/sh
# Para que vayan gráficos y audio, es necesario tener sysfs y proc.
# Y para que arranque el servicio udev, y para poder configurar el governor a mano, etc
mount -t sysfs sysfs /sys
mount -t proc proc /proc
mount -n -t tmpfs none /dev

# Ponemos a punto el governor
echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor

# Creamos los nodos de tty (que pasará a ser la tty en uso cuando tengamos
# algo funcionando en alguna tty) y de tty1.
# Los dos ultimos numeros son el MAJOR y el MINOR, y hay que conocerlos
# porque son especificos de cada tipo de nodo que creemos.
mknod -m 666 /dev/tty c 5 0
mknod -m 660 /dev/tty1 c 4 1

# En caso de que te den en faltar estos nodos basicos, asi se crean.
#mknod -m 622 /dev/console c 5 1
#mknod -m 666 /dev/null c 1 3
#mknod -m 666 /dev/zero c 1 5
#mknod -m 666 /dev/ptmx c 5 2
#mknod -m 444 /dev/random c 1 8
#mknod -m 444 /dev/urandom c 1 9

# Creamos los nodos del chip grafico. La pi4 tiene dos salidas,
# así que creamos dos tarjetas. El renderD128 también es necesario.
mkdir -p /dev/dri
mknod -m 660 /dev/dri/card0 c 226 0
mknod -m 660 /dev/dri/card1 c 226 1
mknod -m 660 /dev/dri/renderD128 c 226 128

# Creamos los nodos de audio
mkdir -p /dev/snd
mknod -m 660 /dev/snd/controlC0 c 116 0
mknod -m 660 /dev/snd/controlC1 c 116 32
mknod -m 660 /dev/snd/pcmC0D0p c 116 16
mknod -m 660 /dev/snd/pcmC1D0p c 116 48
mknod -m 660 /dev/snd/timer c 116 33

# Creamos los nodos de input
mkdir -p /dev/input
mknod -m 660 /dev/input/mouse0 c 13 32
mknod -m 660 /dev/input/mice c 13 63
mknod -m 660 /dev/input/event0 c 13 64
mknod -m 660 /dev/input/event1 c 13 65
mknod -m 660 /dev/input/event4 c 13 68
mknod -m 660 /dev/input/js0 c 13 68

# devpst es para poder conectar por ssh.
#mkdir /dev/pts
#mount -t devpts none /dev/pts -o gid=4,mode=620 

# Lanzamos udev para que nos detecte lo que conectemos dinámicament
# y carge los modulos. NO crea los nodos a no ser que tenga unas rules
# que creo que le pasa systemd, así que por eso tenemos que crearlos
# nosotros a mano como acabas de ver.
/etc/init.d/udev start >> /dev/null

# Si queremos levantar la red, descomentar esto.
#ifconfig eth0 up
#ip addr add 192.168.1.8/24 dev eth0
#ip route add default via 192.168.1.7
#/etc/init.d/dropbear start

# Esto configura la fuente y el teclado de la consola.
# Lee la configuración de /etc/default/console-setup y /etc/default/keyboard.
setupcon

# En caso de querer consola, descomentar esto.
# Se puede usar bash pero depende de más basura de systemd.
#/bin/sh
exec setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'

# Este es el programa único que va a correr el sistema, en lugar de la consola.
#/usr/local/bin/retroarch

# Una vez que se sale del programa único, paramos udev y desmontamos todo.
# El desmontaje conlleva la sincronización de los discos.
/etc/init.d/udev stop
umount -a

# Dependiendo de si quieres reiniciar o apagar al salir, usa una o la otra.
# Poweroff va con dos -f, sí, no es un error, es para que no contacte con el gestor de procesos, que no existe.
reboot -f
#poweroff -f -f

************************
*ACABA EL SCRIPT BÁSICO*
************************

**************************************
* OTRAS NOTAS PARA AFINAR EL SISTEMA *
**************************************

TAMBIÉN puedes poner en cmdline.txt para que no salga el cursor parpadeante:
vt.global_cursor_default=0

******************
*COSAS PENDIENTES*
******************
TODO: 
-Tunear lo de la escritura en disco para que sea inmediata. Mira los parámetros: vm.dirty_background_ratio y
vm.dirty_ratio.

-En lugar de usar esa línea tan larga de setsid para lanzar sh en la tty1, usar cttyhack, que es parte de busybox.
Pero para eso habría que pasarse a busybox. Puede convenir porque además trae mdev en vez de udev, que creo que
crea los nodos sin depender de rules externas, así que nos ahorramos lo de hacerlo a mano. Investigarlo.

-Pasar de udev a mdev, que es lo que se usa en busybox. Para poner en marcha mdev una vez instalado, lee:
https://git.busybox.net/busybox/plain/docs/mdev.txt
La alternativa se supone que es tener un kernel con devtmpfs activado (opciones CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y
de la configuración del kernel), ya que un kernel con devtmpfs crea los nodos necesarios, pero lo malo es que eso no
carga los módulos necesarios.
Tampoco sé si mdev carga los módulos automáticamente, se supone que sí. Pero vamos, que con devtmpfs no es suficiente para
la carga de módulos.


******************
* NOTAS DE AYUDA *
******************
NOTA ADICIONAL POR SI TE HACE FALTA: Para ver la configuración del kernel en ejecución, tienes que insertar un módulo y luego
sacarla de un fichero, tal que así:
sudo modprobe configs
zcat /proc/config.gz > kernel_config

NOTA ADICIONAL POR SI TE HACE FALTA. Tira de google a partir de esto si quieres reiniciar con el saludo de los tres dedos.
You can change the behaviour of CTRL-ALT-DEL from rebooting: To disable CTRL-ALT-DEL from rebooting your computer (or to have it do something different), you can edit the /etc/inittab file

NOTA ADICIONAL POR SI TE HACE FALTA.
Para loguearte como usuario, se podría tirar de agetty:
getty -n -l /bin/sh 9600 tty1
