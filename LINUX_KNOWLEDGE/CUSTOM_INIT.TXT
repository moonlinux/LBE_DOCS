******Sistema mínimo como root********************************************************************************************

Fuentes:
-Preguntar a clever en el canal #raspberrypi
https://www.linux.it/~rubini/docs/init/init.html

***************
*NOTAS PREVIAS*
***************

--Lo más importante que debes saber es que lo importante de un nodo en /dev no es un nombre, sino sus MAJOR y MINOR numbers.
Los puedes ver en un sistema "normal" con ls -l /dev/loquesea. Por ejemplo, con "ls -l /dev/tty" vemos:
crw-rw-rw- 1 root tty 5, 0 nov 16 03:54 /dev/tty
De donde deducimos que tenemos que creat /dev/tty con major 5 y minor 0. ESE ES EL MODO EN QUE EL KERNEL SABER CÓMO USARLO,
SU NOMBRE ES LO DE MENOS.
Entonces, ese nodo se crearía a mano con:
mknod -m 666 /dev/tty c 5 0
Y si miramos tty1 con "ls -l /dev/tty1", vemos:
crw--w---- 1 root tty 4, 1 nov 15 16:23 /dev/tty1
Así que ese nodo se crearía a mano con:
mknod -m 660 /dev/tty c 4 1
LA COSA es que, si necesitamos crear nodos a mano, los miramos con ls -l en un sistema funcional, y deducimos cómo crearlos
a mano nosotros con mknod.

--UDEV se encarga de cargar los módulos para el hardware que tengamos conectado, PERO no crea nodos en /dev a no ser que
tenga las rules necesarias, que creo que se las pasa systemd. Vamos, que no crea nodos para el hardware cuyos módulos carga,
por eso los creamos nosotros a mano en el script de inicio, como vas a ver.
Los nodos del hardware que está built-in en el kernel sí que los crea el kernel, pero para ello tiene que tener la funcionalidad
CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y.

--Como montamos tmpfs en /dev, los módulos que se crean en cada sesión son creados en RAM, así que se pierden en cada reinicio.
Supongo que es posible tener nodos estáticos, pero ni idea de momento.

--Cuando en un programa encontremos que hacer un open() a /dev/tty devuelve -1 (es decir, al abrir el FD de la tty en uso)
y al mirar el ERRNO nos diga "can't open /dev/tty, no such device or address",
o lo que es lo mismo, cuando nos diga lo de "no such device or address" al hacer un echo hola > /dev/tty,
significa que SÍ TENEMOS el nodo /dev/tty, pero que no hay una TTY activaa (tty1, tty2, etc)
por lo que /dev/tty digamos que no apunta a ninguna parte (si la TTY activa es tty1, /dev/tty apunta a /dev/tty1, etc).
Cuando digo que una TTY es la TTY activa, es que se está viendo en pantalla (se cambiaría con CRTL+ALT+Fn, como sabes).
POR ESO tenemos que lanzar sh de manera que vaya a parar a una TTY (idealmente la tty1, que es la que está usando el kernel
para sacar sus mensajes, porque le hemos pasado console=tty1 en la línea de comandos del kernel, recuerda).
Puedes saber sobre qué TTY está corriendo sh o lo que sea simplemente con el comando "tty".
Y puedes saber sobre qué TTY corre cada programa en ejecución con ps -a.

--ES POSILBE hacer un open() pasándole 0 en vez de /dev/tty a open(), si no has puesto en ningún TTY el SH
o el programa único que hayas lanzado en modo singleuser, y/o ni siquiera tienes un nodo /dev/tty que apunte
a una tty de verdad (/dev/tty1, etc..) creado. Y funciona.
E incluso se puede hacer el típico de KDSKBMODE a K_OFF para que no haya leak de teclas a la consola, o K_XLATE
para que vuelva a producir pulsaciones de teclas a la consola, etc.. con el fd que nos ha devuelto open() pasándole 0
en vez de una TTY.
Lo que pasa es que con SDL2 no hay forma de restaurar el teclado ("ioctl(0, KDSKBMODE, K_XLATE") al salir, porque el ioctl falla con
"bad file descriptor". (O sea, el ioctl devuelve -1, pero luego miramos errno con: 
printf("ERRORNO after ioctl was: %s\n", strerror(errno));
Y ahí vemos lo del "bad file descriptor".
(Sí funciona si lo restauramos nada más hacer el K_OFF para silenciarlo, pero si lo hacemos a la salida ya no funciona).
Esto pasa porque SDL2 hace en alguna parte un close() a un fd que vale 0, o vamos, que le llega 0 a un close.
Pero eso escapa completamente a nuestro control.

--Partimos de la premisa de que al kernel le pasamos console=tty1, claro. Si usamos otra tty, pues habrá que crear esa otra TTY
y mandar el sh a correr en esa otra tty.

*******************
*FIN NOTAS PREVIAS*
*******************

El siguiente script es el que puedes poner como script mínimo de arranque para levantar un sistema usable sin systemd
ni ningún otro proceso init.
Yo lo he puesto como /root/minimal, con permisos de ejecución, y luego en cmdline.txt he puesto
init=/root/minimal rw
Lo de rw es directamente para montar el root como read-write.

********************************************************
*EMPIEZA EL SCRIPT BÁSICO (LO IMPORTANTE DE TODO ESTO) *
********************************************************

#!/bin/sh
# Para que vayan gráficos y audio, es necesario tener sysfs y proc.
# Y para que arranque el servicio udev, y para poder configurar el governor a mano.
mount -t sysfs sysfs /sys
mount -t proc proc /proc
mount -n -t tmpfs none /dev

# Ponemos a punto el governor
echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor

# OPCIONAL: Lanzamos udev para que nos detecte lo que conectemos dinámicamene
# y carge los modulos. NO crea los nodos a no ser que tenga unas rules
# que creo que le pasa systemd, así que por eso tenemos que crearlos
# nosotros a mano como acabas de ver.
# /etc/init.d/udev start >> /dev/null

# LO QUE SOLEMOS HACER PARA NO USAR UDEV: Si no usamos udev, cargamos a mano los modulos.
# Esta es la lista minima para tener video, sonido, teclado y raton, joystick y red en la Pi4.
modprobe hid_logitech_hidpp
modprobe hid_logitech_dj
modprobe vc4 
modprobe v3d
modprobe drm
modprobe joydev
modprobe i2c_brcmstb
modprobe snd_pcm

# Creamos los nodos de tty (que pasará a ser la tty en uso cuando tengamos
# algo funcionando en alguna tty) y de tty1.
# Los dos ultimos numeros son el MAJOR y el MINOR, y hay que conocerlos
# porque son especificos de cada tipo de nodo que creemos.
mknod -m 666 /dev/tty c 5 0
mknod -m 660 /dev/tty1 c 4 1

# En caso de que te den en faltar estos nodos basicos, asi se crean.
#mknod -m 622 /dev/console c 5 1
#mknod -m 666 /dev/null c 1 3
#mknod -m 666 /dev/zero c 1 5
#mknod -m 666 /dev/ptmx c 5 2
#mknod -m 444 /dev/random c 1 8
#mknod -m 444 /dev/urandom c 1 9

# Creamos los nodos del chip grafico. La pi4 tiene dos salidas,
# así que creamos dos tarjetas. El renderD128 también es necesario.
mkdir -p /dev/dri
mknod -m 660 /dev/dri/card0 c 226 0
mknod -m 660 /dev/dri/card1 c 226 1
mknod -m 660 /dev/dri/renderD128 c 226 128

# Creamos los nodos de audio
mkdir -p /dev/snd
mknod -m 660 /dev/snd/controlC0 c 116 0
mknod -m 660 /dev/snd/controlC1 c 116 32
mknod -m 660 /dev/snd/pcmC0D0p c 116 16
mknod -m 660 /dev/snd/pcmC1D0p c 116 48
mknod -m 660 /dev/snd/timer c 116 33

# Creamos los nodos de input
mkdir -p /dev/input
mknod -m 660 /dev/input/mouse0 c 13 32
mknod -m 660 /dev/input/mice c 13 63
mknod -m 660 /dev/input/event0 c 13 64
mknod -m 660 /dev/input/event1 c 13 65
mknod -m 660 /dev/input/event4 c 13 68
mknod -m 660 /dev/input/js0 c 13 68

# devpst es para poder conectar por ssh.
#mkdir /dev/pts
#mount -t devpts none /dev/pts -o gid=4,mode=620 

# Si queremos levantar la red, descomentar esto. Ojo que será necesario tener
# cargados los módulos para el hardware de red de nuestra máquina.
# En la Pi4, con la lista mínima de módulos que cargamos manualmente
# no hace falta nada más.
#ifconfig eth0 up
#ip addr add 192.168.1.8/24 dev eth0
#ip route add default via 192.168.1.7
#/etc/init.d/dropbear start

# Esto configura la fuente y el teclado de la consola.
# Lee la configuración de /etc/default/console-setup y /etc/default/keyboard.
setupcon

# En caso de querer consola, descomentar esto.
# Se puede usar bash pero depende de más basura de systemd.
#/bin/sh
exec setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'

# Este es el programa único que va a correr el sistema, en lugar de la consola.
#/usr/local/bin/retroarch

# Una vez que se sale del programa único, paramos udev (si es que lo hemos lanzado)
# y desmontamos todo.
# El desmontaje conlleva la sincronización de los discos.
# /etc/init.d/udev stop
umount -a

# Dependiendo de si quieres reiniciar o apagar al salir, usa una o la otra.
# Poweroff va con dos -f, sí, no es un error, es para que no contacte con el gestor de procesos, que no existe.
reboot -f
#poweroff -f -f

************************
*ACABA EL SCRIPT BÁSICO*
************************

**************************************
* OTRAS NOTAS PARA AFINAR EL SISTEMA *
**************************************

TAMBIÉN puedes poner en cmdline.txt para que no salga el cursor parpadeante:
vt.global_cursor_default=0

******************
*COSAS PENDIENTES*
******************
TODO: 
-Tunear lo de la escritura en disco para que sea inmediata. Mira los parámetros: vm.dirty_background_ratio y
vm.dirty_ratio.

-En lugar de usar esa línea tan larga de setsid para lanzar sh en la tty1, usar cttyhack, que es parte de busybox.
Pero para eso habría que pasarse a busybox. Puede convenir porque además trae mdev en vez de udev, que creo que
crea los nodos sin depender de rules externas, así que nos ahorramos lo de hacerlo a mano. Investigarlo.

-Pasar de udev a mdev, que es lo que se usa en busybox. Para poner en marcha mdev una vez instalado, lee:
https://git.busybox.net/busybox/plain/docs/mdev.txt
La alternativa se supone que es tener un kernel con devtmpfs activado (opciones CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y
de la configuración del kernel), ya que un kernel con devtmpfs crea los nodos necesarios, pero lo malo es que eso no
carga los módulos necesarios.
Tampoco sé si mdev carga los módulos automáticamente, se supone que sí. Pero vamos, que con devtmpfs no es suficiente para
la carga de módulos.


******************
* NOTAS DE AYUDA *
******************
NOTA ADICIONAL POR SI TE HACE FALTA: Para ver la configuración del kernel en ejecución, tienes que insertar un módulo y luego
sacarla de un fichero, tal que así:
sudo modprobe configs
zcat /proc/config.gz > kernel_config

NOTA ADICIONAL POR SI TE HACE FALTA. Tira de google a partir de esto si quieres reiniciar con el saludo de los tres dedos.
You can change the behaviour of CTRL-ALT-DEL from rebooting: To disable CTRL-ALT-DEL from rebooting your computer (or to have it do something different), you can edit the /etc/inittab file

NOTA ADICIONAL POR SI TE HACE FALTA.
Para loguearte como usuario, se podría tirar de agetty:
getty -n -l /bin/sh 9600 tty1
