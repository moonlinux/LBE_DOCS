FINETUNING THE SYSTEM
=====================

Una vez que hemos arrancado nativamente, tenemos mucho que hacer.

-RECUERDA que para poder logearte por SSH como ROOT tienes que editar /etc/ssh/sshd_config y: 
	-Poner "PermitRootLogin" a "yes"
	-Ya que estás, deja comentada la línea:
		#AcceptEnv LANG LC_*
	...lo que nos ahorra errores de LOCALES cuando usamos APT-GET por SSH.
	
-Crear el usuario pi:
sudo adduser pi
sudo adduser pi sudo
sudo adduser pi audio
sudo adduser pi video
(Esto último es importante, porque has estado dando vueltas y el kernel sí reconocía el audio interno y la hifiberry (cat /proc/asound/cards)
pero aplay -L no listaba los dispositivos...¡porque no estabas en el grupo audio!)

-DESINSTALAMOS loggers y cosas raras, que se llevan por delante servicios que no usamos:
apt-get clean triggerhappy rsyslog cron dphys-swapfile bluetooth avahi-* fake-hwclock
(NOTA: fake-hwclock no se usa porque en su lugar uso systemd-timesyncd que sincroniza la hora al conectarase a la red
 y guarda la hora en disco al reiniciar, con lo que fake-hwclock es redundante.)

-Deshabilitamos estos servicios:
systemctl mask e2scrub_all.timer
systemctl mask e2scrub_reap.service
systemctl mask man-db.service
systemctl mask man-db.timer
systemctl mask raspi-config.service
systemctl mask rc-local.service
systemctl mask rpcbind.service
systemctl mask rpcbind.socket
systemctl mask rpi-eeprom-update.service
systemctl mask run-rpc_pipefs.mount
systemctl mask sys-fs-fuse-connections.mount
systemctl mask sys-kernel-debug.mount
systemctl mask sys-kernel-tracing.mount
systemctl mask systemd-rfkill.service
systemctl mask systemd-rfkill.socket
(OJO: Servicios que NO DEBES DESHABILITAR:
	-NetworkManager, que se usa para conectarse a la Wifi usando raspi-config y que deja las redes conocidas en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf
	-systemd-journald, que lo usaremos para ver los mensajes de inicio del kernel y los servicios con el comando "journalctl"
	-systemd-logind, que lo usaremos para que libseat sepa que estamos logueados sin tener que usar el servicio seatd
	 (seatd lo usaremos en sistemas embedidos sin systemd). Esto sirve para poder levantar Wayland compositors.
	-Los servicios que preparan o limpian las tmpfiles, aunque mandes todo eso a RAM
	-El servicio system-getty.slice, que sirve para gestionar los recursos de GETTY en las TTYs,
	aunque nos spawnee una getty por cada TTY del 1 al 6.
	Si lo deshabilitas, el autologin en la TTY funciona, pero el servicio no respawnea al hacer un logout escribiendo "exit".
	El truco es dejar system-getty.slice vivo, editar /etc/systemd/logind.conf y poner NAutoVTs a 1 o 2,
	dependiendo si quieres autologin en una TTY o en dos, o vamos, en las que vayas a usar concretamente.
	De ese modo nos funciona el autologin en las TTYs que queramos, y ademas funciona el respawn al escribir "exit".
)

-Deshabilita los timers de actualización diaria de APT:
sudo systemctl disable apt-daily-upgrade.timer
sudo systemctl disable apt-daily.timer
y crea el fichero:
/etc/apt/apt.conf.d/99periodic-disable
con el contenido:
APT::Periodic::Enable "0";

-Deshabilita el target de swap:
sudo systemctl mask swap.target

-Deshabilita el timer de rotación diaria de logs:
sudo systemctl disable logrotate.timer
Otros timers activos los puedes buscar con:
sudo systemclt | grep timer
Y miras a ver cuáles están active loaded. Unos se quitan con mask, otros con disable.

-Para eliminar el error de "automount point not supported", simplemente haz:
sudo depmod -a
Y reinicia. Ya no debería salir más.

-Ponemos autologin en tty1 y tty2:
	-Creamos los ficheros: 
	/etc/systemd/system/getty@tty1.service.d/autologin.conf
	/etc/systemd/system/getty@tty2.service.d/autologin.conf
	-Metemos ambos ficheros esto:
		[Service]
		ExecStart=
		ExecStart=-/sbin/agetty --autologin root --noclear --skip-login --nonewline %I $TERM
	-Activamos los servicios:
		systemctl enable getty@tty1.service
		systemctl enable getty@tty2.service	
	-Si queremos que la consola no se limpie al acabar el inicio del sistema o al hacer logout, creamos
	/etc/systemd/system/getty@tty1.service.d/noclean.conf
	con el contenido:
		[Service]
		TTYVTDisallocate=no

-Si después de hacer lo del autologin no puedes cambiar a TTY2 (ctrl+alt+f2), es porque no has activado el servicio. Haz:
sudo systemctl enable getty@tty2.service
Y ya podrás cambiar de TTY1 a TTY2!!!

***BLOQUE ALSA****
-PARA INSTALAR ALSA:
Instalamos alsa-utils, pero NO desde el entorno chrooted sino nativamente.
Si no tienes red en la Pi, puedes descargar los paquetes en el entorno chrooted, y luego instalarlos en nativo, o sea, en dos pasos, mira:
1) En el entorno chrooted:
sudo apt-get clean (para que no haya lios con otros paquetes en /var/cache/apt/archives)
sudo apt-get install --download-only alsa-utils
2) En el entorno nativo, es decir, en la Pi sin red:
cd /var/cache/apt/archives
sudo dpkg -i *
AHORA PASA A CREAR /etc/asound.conf, cuyo contenido varía si usas la HIFIBERRY o si no la usas:

-Si usas la hifiberry, acuérdate que en config.txt tienes que tener para que funcione:
dtoverlay=hifiberry-dacplus
Y la línea del audio interno comentada, para que el kernel sólo cargue la hifiberry:
#dtparam=audio=on

ESTO ES IMPORTANTE: Para que siempre se elija la hifiberry como tarjeta por defecto, crea este /etc/asound.conf:
pcm.!default {
    type hw
    card sndrpihifiberry
}

ctl.!default {
    type hw    
    card sndrpihifiberry
}

-Ahora ajusta los niveles en ALSAMIXER, que se van a quedar como los dejes porque vamos a quitar los servicios que los guardan y los restauran

-Y ahora quita los servicios que guardan y restauran los niveles de ALSA:
sudo systemctl mask alsa-state.service 
sudo systemctl mask alsa-restore.service

Y ya van a quedar así para siempre los niveles. Si los quieres cambiar, pues unmaskeas los servicios state y restore, los cambias, reinicias y los vuelves a maskear.

****FIN BLOQUE ALSA****

-Crear el /usr/bin/netup con:
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo systemctl start dropbear
(OJO: dropbear ya no arranca a mano con '/etc/init.d/dropbear start')

-Instalar dropbear, generar sus claves y quitarlo del arranque sin maskearlo, porque si no luego no arranca desde mi script netup.
(Esto además instala fuentes, setup de la consola y todo eso, que nos va a hacer falta)
apt-get install dropbear
dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
sudo systemctl disable dropbear
(CUIDADO QUE SIN LAS CLAVES NO FUNCIONA!!!)

-Configuramos la consola, el teclado y los locales (NO LO HAGAS POR SSH, o fallará por culpa de los LOCALE de la máquina
desde la que te conectas y perderás un buen rato):
sudo apt-get install locales console-setup console-data keyboard-configuration
sudo dpkg-reconfigure console-setup
sudo dpkg-reconfigure locales
(Elegimos que se generen en_US.UTF8 y es_ES.UTF, y dejamos puesto en_US.UTF8. ESTO nos quita errores de teclado a través de SSH,
ya que necesitamos los LOCALES de la máquina cliente también).
sudo dpkg-reconfigure keyboard-configuration
Tras reiniciar (sí, hay que reiniciar), ya tendría que ir la Ñ, los acentos y todo eso.

Otra manera más sencilla de evitar esos errores por SSH es editar /etc/ssh/sshd_config y comentar:
	# Allow client to pass locale environment variables
	# AcceptEnv LANG LC_*
Si lo haces así no necesitas regenerar es_ES.utf8, con en_US.utf8 vale.	

Si queremos cambiar la distribución del teclado de nuevo (porque cambiamos de sistema y/o teclado) basta con volver a hacer:
sudo dpkg-reconfigure keyboard-configuration
Eso sí, asegúrate antes de que el comando "locale" nos dice que está todo a en_US.UTF-8.

-Vamos quitando los servicios con:
sudo systemctl mask <sevcio>

-Para que funcione el teclado, ratón y joystick con las SDL2, creamos /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Y reiniciamos.

-SI QUITAS systemd-journald (NO RECOMENDADO)
---Para quitar el error de DMESG: "Failed to connect stdout to the journal socket"
Edita /etc/systemd/system.conf y pon LogTarget=null.
---Para quitar el error: "Failed to listen on journal socket"
Mira a ver qué sockets están activos con:
systemctl | grep socket
...Y le haces un "systemctl mask" a los que queden.
También hazle "systemctl mask" a sockets.target.
Algunos ejemplos:
systemctl mask systemd-journald.socket
systemctl mask systemd-journald-dev-log.socket
systemctl mask systemd-rfkill.socket

-Para quitar el error: "brcmfmac: brcmf_sdio_htclk: HT Avail timeout (1000000): clkctl 0x50"
Puedes instalar el firmware de la wifi, o simplemente deshabilitarla poniendo en config.txt:
dtoverlay=pi3-disable-wifi

-Para ocultar los mensajes de systemd en el inicio, pon en cmdline.txt:
systemd.show_status=false

-Para evitar errores en el inicio relacionados con systemd-journald-audit.socket (que nosotros NO tenemos), pon en cmdline.txt:
audit=0

-Para evitar parones (stalls) en el vídeo de los juegos debido al i/o scheduler, pon en cmdline.txt:
elevator=noop

-En .bashrc, descomenta para tener el prompt en color:
force_color_prompt=yes

-El mensaje que quieras que se vea en el inicio, ponlo en /etc/issue

-PARA USUARIOS NORMALES SOLAMENTE:
TENEMOS QUE QUITAR LOS RLIMITS, o los emuladores se empezarán a quejar al llegar al 80% de uso de la CPU!
Para ello, editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:

@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

De este modo, no hay límites para el usuario Pi ni para nadie del grupo audio, como jackd.
Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

-Para configurar el audio con el driver de audio HDMI del lado de ARM (que es como lo venimos haciendo ahora):
	PREVIO: En el momento en que usamos el sistema KMS (dtoverlay=vc4-kms-v3d) obtenemos el dispositivo ALSA de audio llamado vc4hdmi,
	que mete los frames de audio en los periodos de blanking del vídeo.
	Al usar KMS, el kernel se encarga del vídeo y de meter esos frames de audio en el blanking de vídeo, así que el audio del lado del
	firmware (es decir, el audio bcm2835) NO PUEDE FUNCIONAR CON KMS.

	-Para usar el vídeo KMS, tenemos que tener en config.txt:
		dtoverlay=vc4-kms-v3d
		#dtparam=audio=on <---SE DEBE deshabilitar la carga de bcm2835.
		(Si quisiéramos desactivar el dispositivo de audio vc4hdmi a la vez que usamos KMS, usaríamos esto: dtoverlay=vc4-kms-v3d,noaudio
		 PERO OLVÍDATE de tener KMS y a la vez audio del lado del firmware (bmc2835) cargando manualmente el módulo snd_bcm2835
		 o si usamos el init por defecto descomentando la línea "dtparam=audio=on", PORQUE combinar KMS con el audio bcm2835
		 es imposible como ya se ha dicho: SI USAMOS KMS, NO PODEMOS USAR EL AUDIO BMC2835, SÓLO EL AUDIO VC4HDMI.)
	 RECUERDA que ninguno de los parámetros hdmi_* de config.txt funciona en modo KMS! El modo de vídeo, por ejemplo,
	 se establecería añadiendo a cmdline.txt algo como:
	 video="HDMI-A-1:1280x720@60"
	-Si falla speakertest, mira que tengas en /usr/share/alsa/cards/vc4-hdmi.conf la última versión que siempre está disponible
	 en: https://github.com/alsa-project/alsa-lib/blob/master/src/conf/cards/vc4-hdmi.conf
	-Si falla algo, pregunta a dom en el foro de Raspberry Pi.
     Y YA. CON ESTO TIENE QUE FUNCIONAR SÍ O SÍ. 

-Si el guardado y restauración de los valores de alsamixer falla a veces, tienes DOS opciones:

	1) LA MÁS RECOMENDABLE AHORA MISMO, Y LA QUE MÁS CONTROL TE DA: Modificar el servicio alsa-restore.service.
	   No está roto el servicio en sí, sino que cuando es lanzado, el mezclador aún no está accesible porque el driver está mal y hasta que un 
	   programa no reproduce audio, no aparece disponible el mezclador (lo puedes comprobar porque alsamixer no muestra controles hasta que
	   un programa ha reproducido algo).
	   Para "parchear" el problema, edita así el servicio de manera que no se sobreescriban los cambios en las acltualizaciones:
	
	   sudo systemctl edit --full alsa-restore.service

	   Y lo dejas con este contenido (o sea, pasas de usar "alsactc restore" y lo que haces es reproducir un sonido y a continuación
	   restauras el volúmen que te de la gana):
	   
[Unit]
Description=Restore volume

[Service]
Type=oneshot
RemainAfterExit=false
ExecStartPre=-/usr/bin/aplay /dev/zero -s 1 -q
ExecStart=-/usr/bin/amixer set PCM 230 -q
       
       El valor 230 NO se corresponde linealmente con un volúmen de 0 a 100, es 80%. Ya sabes, las cosas del audio.

       CADA VEZ que quieras ajustar el volúmen guardado, te toca hacer: sudo systemctl edit --full alsa-restore.service
       Pero vamos, que lo controlas tú todo a tu gusto.
       Puedes crearte un script en /usr/local/bin/volume con el contenido:
       sudo systemctl edit --full alsa-restore.service

	2) (Actualmente no válido porque falla "alsactl restore"). Deshabilitar el servicio alsa-restore.service (sudo systemctl mask alsa-restore.service), pon los controles a tu gusto en alsamixer, y guarda la configuración con:
		alsactl store -f /etc/asound.state
		Prueba a cargar la configuración con:
		sudo alsactl restore -f /etc/asound.state
		Si todo va bien, ALSA va a restaurar esos valores en cada arranque, leyéndolos de /etc/asound.state, sin que hagas nada y sin ningún servicio.
		Si quieres, puedes aniadir lo de alsactl restore al .profile		

	-CÓMO USAR LA HIFIBERRY: Se supone que funciona siempre porque aunque el ordering de las tarjetas puede cambiar entre arranques, estamos espeficicando la tarjeta por
	    defecto en /etc/asound.conf con el contenido:
	    	pcm.!default {
    			type hw
    			card sndrpihifiberry
			}
			
			ctl.!default {
    			type hw    
    			card sndrpihifiberry
			}					
		Deshabilita el servicio alsa-restore.service, y pon en .profile:
		amixer set Digital 85% -q
		Esto lo que hace es que te pone el control llamado Digital a 55 (no a 85 como podría parecer).
		Puedes ver los controles con "amixer scontrols".
		Vamos, que esto lo que hace es que pongas a mano el valor que quieras para cada control de la tarjeta por defecto
		(también se puede elegir tarjeta y tal, mira "man amixer" si ves que te hace falta).

	-EXPERIMENTAL, NO FUNCIONA: Sería la más recomemdada: soluciona los problemas de ordering, porque tienes dos tarjetas. Para ello, crea /etc/modprobe.d/alsa-base.conf con:
		options snd_soc_hifiberry_dacplus index=0
		options vc4 index=1
	 De esta manera, el servicio de restauración de ALSA (alsa-restore.service) no debería fallar nunca, porque la primera tarjeta es siempre la hifiberry y aplicaría los
	 valores guardados correctos para cada tarjeta en el arranque, ya que el ordering de las tarjetas no cambiaría nunca.
            
Recuerda mirar las mierdas que lanza systemd en el arranque antes de ocultarlo, y mira los targets con
sudo systemctl | grep <loquesea>
Luego los vas quitando, al igual que los services, con systemctl mask <monbre service o target>
Si metes la pata y el sistema no arranca más, elimina cosas de /etc/systemd/system, que es donde pone los links a /dev/null correspondientes a los services o targets que hayas eliminado
sin deber hacerlo...

-Para conectarte automaticamente a una WIFI, lo mejor es tener activado el servicio NetworkManager y meter la red/contraseña en raspi-config,
en la seccion system->wireless lan.
Las redes conocidas quedan guardadas en /etc/NetworkManager/system-connections, en lugar de en /etc/wpa_supplicant/wpa_supplicant.conf

-Si PING te da el error "ping: socket: Address family not supported by protocol", simplemente haz:
sudo chmod 4755 /bin/ping
Y ya te irá perfectamente.

KERNEL REALTIME PRECOMPILADO
============================

Instala la última versión LOW_LATENCY de aquí:
https://github.com/kdoren/linux/releases/

Siguiendo estas instrucciones de aquí:
https://github.com/kdoren/linux/wiki/Installation-of-kernel-from-deb-package-%28Raspberry-Pi-OS%29

ACTUALIZAR RASPBERRY PI OS SIN ACTUALIZAR EL KERNEL
===================================================

Útil para cuando tenemos un kernel especial instalado, como por ejemplo el kernel realtime de: https://github.com/kdoren/linux/releases/

Se hace poniendo el paquete raspberrypi-kernel en "hold", tal que así:

-Actualizamos el índice de paquetes como siempre:
sudo apt-get update

-Ponemos el paquete del kernel en hold:
sudo apt-mark hold raspberrypi-kernel

-Actualizamos los paquetes normalmente. Como el paquete del kernel está en holdo, no se actualizará:
sudo apt-get upgrade

Opcionalmente, si quieres, puedes quitar el hold del paquete del kernel al acabar, haciendo:
sudo apt-mark unhold raspberrypi-kernel

GUARDAR TODOS LOS LOGS EN RAM
=============================

Lo primero es desisntalar rsyslog
apt-get purge rsyslog
(RECUERDA: con systemd-journald nos vale para que nos guarde los logs de sistema,
puedes usar el comando "journalctl" sin mas para ver los mensajes de inicio/parada del kernely los servicios).

Ahora borra los logs de disco:

rm -R /tmp/* 
rm -R /var/tmp/*
rm -R /var/log/*
rm -R /var/spool/* 

Ahora, añade estas lineas a /etc/fstab:

# Added 4 lines to use RAM instead of SSD for temp and log files
tmpfs /tmp tmpfs defaults,noatime,mode=1777 0 0
tmpfs /var/tmp tmpfs defaults,noatime,mode=1777 0 0
tmpfs /var/log tmpfs defaults,noatime,mode=0755 0 0
tmpfs /var/spool tmpfs defaults,noatime,mode=1777 0 0

¡¡¡CUIDADO!!! NUNCA mandes /var a RAM, porque ahi guardan apt-get y otros programas importantes sus datos.
SOLO puedes mandar a RAM esos subdirectorios de /var que te he dicho.
Y NUNCA borres el contenido de /var, solo el contenido de esos subdirectorios que te he dicho.

INSTALAR MESA
==============

NOCIONES PREVIAS DE APIS, DEPENDENCIAS, Y SOPORTE DE OPENGL COMPLETO (NO GLES)

Para tener OpenGL "completo" (no GLES), Mesa se puede compilar con GLX (lo que conlleva un cojón de dependencias de X11 y es un asco), o con GLVND (libglvnd, una librería muy ligera de NVIDIA que es libre).
Compilar MESA con OpenGL completo para GLX nos produce libGL.so, y compilar MESA con OpenGL completo para GLVND nos produce libOpenGL.so  

Si compilas con OpenGL completo mediante GLVND, las SDL2 deberían ya detectar y usar libOpenGL.so en vez de libGL.so, y los programas de SDL2
que usen OpenGL completo funcionarán.
Aún así, si algún programa intenta linkar con -lGL, no lo va a encontrar, así que cambia -lGL por -lOpenGL y ya linkará sin problemas.
Si algún programa linka contra -lGLU, elimínalo y ya. No se necesita nada de ahí.

Si MESA te da un error de que no encuentra GL/glxproto.h, reinstala el paquete x11proto-dev

FIN NOCIONES PREVIAS

¡¡¡OJO!!! LO PRIMERO EN LA PI4, AÑADE AL USUARIO "pi" AL GRUPO RENDER, O TE VOLVERÁS LOCO PORQUE GLES NO IRÁ PERO DRM SÍ (o sea, modetest funciona pero MESA no puede cargar GLES). PARA ELLO, HAZ:
sudo usermod -a -G render pi

Empezamos con libDRM:

Lo primero es instalar la última versión de MESON, porque la que trae DEBIAN siempre son viejos y las versiones
actuales de WLROOTS necesitan versiones actuales de MESON para compilar (DEBIAN nunca coge a WLROOTS con la versión
de MESON necesaria). Así que ahorra tiempo ahora si vas a usar WAYLAND, y deja ya instalado el último MESON:

sudo apt-get purge meson
sudo apt install python3-pip --no-install-recommends
sudo python3 -m pip install ninja
sudo python3 -m pip install meson
PATH="/usr/local/bin:$PATH"

...Ahora ya vamos con libDRM en sí...
Elimimanos el libDRM del sistema, que es viejo siempre:
apt-get purge libdrm*
Instalamos estas dependencias previas: 
sudo apt-get install xsltproc libpciaccess-dev xutils-dev libtool make cmake automake pkg-config gcc g++ python3-setuptools --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente)
Bajamos la última versión estable de:
https://dri.freedesktop.org/libdrm/
mkdir b4
cd b4

Configuramos libdrm con esto:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dudev=true -Dvc4=enabled -Dintel=disabled -Dvmwgfx=disabled -Dradeon=disabled -Damdgpu=disabled -Dnouveau=disabled \
-Dfreedreno=disabled -Detnaviv=disabled \
-Dinstall-test-programs=true ..

Compilamos e instalamos:
ninja -j4
sudo ninja install

En este punto, puedes probar si libdrm te funciona bien haciendo:
modetest -s 32:1280x720
(donde 32 es un ID de conector válido: puedes ver los conectores con modetest|grep connected).

DEPENDENCIAS PREVIAS DE MESA:

SI QUIERES GLES Y GLES2 NECESITAS ESTAS DEPENDENCIAS:
sudo apt-get install --no-install-recommends \
    flex bison python3-mako python3-setuptools \
    libexpat1-dev libudev-dev gettext \
    ca-certificates xz-utils \
    zlib1g-dev pkg-config

SI ADEMÁS QUIERES VULKAN NECESITAS ESTAS DEPENDENCIAS:
sudo apt-get install libvulkan-dev libvulkan1 vulkan-tools --no-install-recommends

SI ADEMÁS QUIERES OPENGL COMPLETO SOBRE LIBGLVND, TIENES QUE INSTALAR LIBGLVND:
Bajamos la última estable de aquí:
https://gitlab.freedesktop.org/glvnd/libglvnd/-/tags
Y configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dx11=disabled ..

NO TE OLVIDES DE AÑADIR AL USUARIO AL GRUPO RENDER:
sudo adduser pi render
(Si ves un error como "MESA-LOADER: failed to open kms_swrast", es porque no lo has hecho).

SATISFECHAS SUS DEPENDENCIAS, PASAMOS A LA COMPILACIÓN DE MESA COMO TAL:

Bajamos los últimos estables de:
https://mesa.freedesktop.org/archive/

Editamos src/broadcom/vulkan/v3dv_device.c y buscamos "destroy dumb object" y comentamos el fprintf() que lo contiene.

Las instrucciones para compilar con MESON se pueden ver en: https://www.mesa3d.org/meson.html
Pero yo ya lo tengo resuelto a continuación...

CONFIGURAMOS COMO LO VENIMOS HACIENDO AHORA, CON GLES, GLES2, OPENGL COMPLETO MEDIANTE GLVND Y VULKAN:

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers=broadcom -Ddri-drivers='' -Dgallium-drivers=v3d,vc4,kmsro \
-Dglvnd=true -Dbuildtype=release ..

(Si no quieres soporte para Wayland, usa -Dplatforms='')

SI QUISIERAS GLES, GLES2 Y OPENGL COMPLETO MEDIANTE GLVND:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dglvnd=true -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

SI QUISIERAS SÓLO GLES Y GLES2, SIN OPENGL COMPLETO:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
meson -Dglx=disabled -Dplatforms=wayland -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

PARA COMPILAR:
ninja -j4
PARA INSTALAR:
sudo ninja install
Y NO TE OLVIDES DE HACER:
sudo rm /etc/ld.so.cache
sudo ldconfig
Y SI HAS COMPILADO CON VULKAN pruebla que todo va bien ejecutando vulkaninfo.

Y PARA DESINSTALAR:
sudo ninja uninstall
O ALTERNATIVAMENTE:
meson introspect ./ --installed | python3 -c 'import sys; a = eval(sys.stdin.read()); print(" ".join(a.keys()))' | xargs rm

COPIAR ARCHIVOS DESDE UN SISTEMA ANTIGUO
=========================================

Lo puedes hacer con rsync -av <origen> <destino>
Ambos sistemos deben tener instalado rsync, y se puede usar por red como scp.

INSTALAR SDL2
=============

Lo primero borra esto:
sudo rm -R /opt/vc

Instalamos dependencias previas:
sudo apt-get install libudev-dev libasound2-dev libvorbis-dev libflac-dev libmpg123-dev libmodplug-dev libpng-dev libjpeg-dev libfreetype6-dev --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente)

Bajamos la última versión estable de:
https://www.libsdl.org/download-2.0.php

Ahora, para configurar:

CON GLES, GLES2, OPENGL COMPLETO y VULKAN, COMO LO HACEMOS AHORA:

CFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
CXXFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-video-rpi --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl --enable-video-vulkan --enable-libudev --disable-esd --disable-ime --disable-fcitx --disable-libsamplerate

CON GLES, GLES2, OPENGL COMPLETO y VULKAN, COMO LO HACEMOS AHORA, PERO EN MODO DEBUG:

CFLAGS="-O0 -ggdb -DEGL_NO_X11" \
CXXFLAGS=" -O0 -ggdb -DEGL_NO_X11" \
./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-video-rpi --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl --enable-video-vulkan --enable-libudev --disable-esd --disable-ime --disable-fcitx --disable-libsamplerate

(LO DE -DMESA_EGL_NO_X11_HEADERS LO HEMOS SACADO DE /usr/lib/pkgconfig/egl.pc. Como el viejo buildsystem de las SDL2 basado en configure y make no usa pkgconfig para saber qué flags tiene que pasar cuando
se compile eglplatform.h, parte de EGL de MESA, que es donde  MESA_EGL_NO_X11_HEADERS evita intentar incluir las headers de X11, pues se lo tenemos que pasar nosotros a mano. El buildsystem de las SDL2 basado en CMAKE sí
pasa correctamente el  -DMESA_EGL_NO_X11_HEADERS de /usr/lib/pkgconfig/egl.pc, porque usa pkconfig para saber qué flags tiene que pasar cuando compila los headers de EGL).

TEMPORAL (SIN PROBAR DEL TODO) CON CMAKE POR SI UN DÍA HAY QUE CAMBIAR AL CMAKE (ESPEREMOS QUE NO!):
cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DASSERTIONS=disabled -DVIDEO_DUMMY=OFF -DVIDEO_VULKAN=OFF -DDISKAUDIO=OFF -DDUMMYAUDIO=OFF -DOSS=OFF ..

Compilar e instalar.

No te olvides de añadir en /etc/profile:
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

Si te da un error "No available video device", y cumplas estos requisitos:
tienes libdrm instalada en /usr/local/lib/<nombre_arquitectura>/,
tienes libgbm que es instalada por MESA también en /usr/local/lib/<nombre_arquitectura>/,
tienes al usuario pi añadido al grupo "render",
...pues regenera la caché de LDD, como siempre que una librería está en un sitio, la estás viendo, pero LD no la ve:
sudo rm /etc/ld.so.cache
sudo ldconfig

Y si tienes un mando que no es detectado por las SDL2 como gamecontroller (lo sabrás porque no funciona con el Prince...), saca su cadena de mapping de la SDL2 Gamepad Tool (http://www.generalarcade.com/gamepadtool),
 y la aniades en /etc/profile usando la variable de entorno SDL_GAMECONTROLLERCONFIG, tal que así:
SDL_GAMECONTROLLERCONFIG="030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,"

Para SDL2_Mixer:
-Instalar antes estas dependencias: apt-get install libmpg123-dev libogg-dev libflac-dev libmodplug-dev
-Instalar antes fluidsynth (tienes instrucciones en LINUX_KNOWLEDGE para instalarlas manualmente sin depender de X11)
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_mixer/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-music-midi-timidity

Para SDL2_Image:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_image/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure

Para SDL2_ttf:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_ttf/releases
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --without-x --disable-freetype-builtin --disable-harfbuzz

Para SDL2_net:
-Nos bajamos la última versión estable de: https://github.com/libsdl-org/SDL_net/releases 
-Configuramos con:
CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure

INSTALAR RETROARCH
===================

Instalamos dependencias previas:
apt-get install libasound-dev

Si vas a compilarlo con soporte para Vulkan, lo primero es instalar el compilador de shaders:
sudo apt-get install glslang-dev glslang-tools spirv-tools

LO PRIMERO, HAZ ESTO O EL CONFIGURE FALLARÁ:
apt-get purge libraspberrypi*

-Para que no se nos cree una ventana fantasma con el logo de RetroArch al ejecutar RetroArch, editamos gfx/common/wayland_common.c
 y comentamos la llamada a draw_splash_screen() y el "if (wl->libdecor)" junto con lo que hay dentro de él y su "else".
 Si tienes varias pantallas conectadas y eso provoca errores, comenta la llamada a shm_buffer_paint_checkerboard() dentro de draw_splash_screen().

Ahora, para configurar RetroArch con soporte de GLES y VULKAN, como lo venimos haciendo:

CFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
CXXFLAGS="-march=native -mtune=native -O2 -DEGL_NO_X11" \
./configure --disable-ibxm --disable-vg --disable-x11 --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg \
--disable-networking --disable-netplaydiscovery --disable-libretrodb --enable-udev --disable-sdl --disable-pulse --disable-oss \
--disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac \
--disable-qt --disable-materialui --disable-xmb --enable-rgui --disable-ozone --disable-gfx_widgets --disable-langextra \
--disable-cdrom --disable-accessibility --disable-tinyalsa --disable-rpiled --disable-v4l2 \
--enable-egl --enable-opengles --enable-opengles3 --enable-vulkan --disable-builtinglslang

(NO le pases --enable-neon ni --enable-floathard, o fallará el configure porque dlopen() no va bien)
(SI TE DA ERROR AL LINKAR por funciones de slang, no le pases --disable-builtinglslang)

PARA COMPILAR CUALQUIER CORE:

CFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" \
CXXFLAGS="-march=native -mtune=native -fomit-frame-pointer -DALIGN_LONG" make -j4

		Configuración óptima de RetroArch (En Wayland)

VIDEO: driver VULKAN, VSYNC ON, MAX_SWAPCHAIN 2
AUDIO: driver ALSATHREAD, 48000 Hz, 32ms, resampler quality normal
(Si usas otra frecuencia de audio, modifícalo también en las opciones del core FBNeo)

SHADER: usamos FAKELOTTES, que tiene una mask increíble.

Si no quieres shimmering en las letras del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE
y activar LINEAR FILTERING.

Si quieres que aparezcan las opciones de SAVE/LOAD STATE, tienes dos opciones:
-Activar la opción settings->core->"bypass core info save states"
-O bien instalar los core info files, que se hace así:
	--Clonamos el repo: git clone --depth 1 https://github.com/libretro/libretro-core-info.git
	--Copiamos los .info a ~/.config/retroarch/cores, junto con los cores (suponiendo que tengamos ese directorio puesto
	  como path para los core info, es la ruta por defecto).

Si quieres que RetroArch te ofrezca con qué emulador quieres correr una ROM, tienes que clonar este repo:
git clone --depth 1 https://github.com/libretro/libretro-super.git
Y mandar el contenido del directorio libretro-super/dist/info a ~/.config/retroarch/cores. Sí, junto con los cores. Así:
cp -R libretro-super/dist/info/* ~/.config/retroarch/cores/
Ahora en RetroArch, en Settings->File Browser, desactiva todo y activa "Filter Unknows Extensions" 

Si quieres configurar un tema del XMB o del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE.
En RGUI, para que se ponga el tema que elijas con CUSTOM THEME PRESET, tienes que poner MENU COLOR THEME en CUSTOM.
En XMB, puedes desactivas el lazo de fondo en SETTINGS->USER INTERFACE->APPEARANCE si quieres.
Para XMB, un buen tema es el Systematic ("SETTINGS->USER INTERFACE->APPEARANCE->MENU ICON THEME")

Si quieres que te salgan iconos en el menú XMB en lugar de cuadrados negros, necesitas los assets de aquí: https://github.com/libretro/retroarch-assets
De ese repo, necesitas solamente el directorio ozone en el directorio de assets. El directorio de assets se cambia en el menú o en el cfg. Yo los tengo en ~/retro/assets,
de tal manera que ahí quedaría el directorio xmb del repo, tal que ~/retro/assets/xmb
Con assets/xmb y assets/rgui te vale, borra los demás.
Con el RGUI es igual.

PARA CUALQUIER PROBLEMA de librerías no encontradas pero que sí están instaladas, RECUERDA REGENERAR LA CACHE DE LDD:
sudo rm /etc/ld.so.cache
sudo ldconfig

Si quieres filtros por software, entra en gfx/video_filters y haz make, y copias los .so y los .filt a ~/.config/retroarch/filters/video/
y luego los seleccionas en retroarch.
