NOTAS PREVIAS
==============

En GNU/LInux en general, la arquitectura ARM de 64 bits se llama aarch64, con doble a. Sin embargo, en Debian se suele llamar arm64: así se refleja en el parámetro de
arquitectura objetivo que se le pasa a debootstrap, por ejemplo. Sin embargo, el ejecutable de qemu-static lleva el subfijo aarch64, porque no es algo propio de Debian.

PARTE 1: EL KERNEL AARCH64
=========================

Seguimos estos dos tutoriales:
http://www.tal.org/tutorials/raspberry-pi3-build-64-bit-kernel
http://www.tal.org/tutorials/booting-64-bit-kernel-raspberry-pi-3
Al final el kernel, los módulos, los dtb y demás quedan en kernel-out, como en el tutorial.

Si da error al compilar las binutils, mira que tengas instalado el paquete texinfo.
Si te da error al compilar el gcc, modifica gcc/graphite.h y ponle includes para isl/id.h y isl/space.h

Antes de empezar, siempre ponemos el crosscompilador de 64bits en el path:
export PATH=$PATH:/opt/aarch64/bin/

Cosas que hacemos distintas para instalar el kernel, módulos y dtbs:
-Para empezar clonamos el kernel con:
	git clone --depth 1 https://github.com/raspberrypi/linux.git -b rpi-4.19.y
	git pull
       (Puede que la versión sea más actual, pero NUNCA CLONES SIN PASARLE EL BRANCH, aunque parezca redundante, que si no luego git pull no funciona bien).

-RECOMENDADO: SI QUEREMOS parchear el kernel para MUQSS scheduler, bajamos el parche correspondiente de:
http://ck.kolivas.org/patches/
(Aplica el parche completo, no sólo el del MUQSS scheduler sino el patch-set CK completo)
(Nótese que con el MUQSS el kermel puede funcionar a 100Hz, no a 1000, y así podemos tener más thoughput a la vez que excelente latencia! El conjunto de parches de CK
deberían poner el kernel a 100Hz por defecto si se usa MUQSS).
Y parcheamos copiando el parche (.patch) al directorio raiz de los sources y haciendo:
patch -p1 < parche
Y luego elegimos el MUQSS como scheduler (GENERAL SETUP, primerísima opción) y ponemos los HZ a 100.
SI VAS A APLICAR ESTE PARCHE, PRIMERO PON EL DEFCONFIG QUE VAYAS A USAR Y LUEGO PARCHEAS, Y LUEGO ENTRAS EN MENUCONFIG. En ese órden va bien.

-OPCIONAL: SI QUEREMOS parchear el kernel para REALTIME, bajamos el parche correspondiente de:
https://mirrors.edge.kernel.org/pub/linux/kernel/projects/rt
Y parcheamos copiando el parche (.patch) al directorio raiz de los sources y haciendo:
patch -p1 < parche.diff
Y luego ajustamos GENERAL SETUP->PREEMPTION MODEL a FULLY PREEMPTIBLE KERNEL(RT).

-Ponemos la configuración por defecto con:
make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-  bcmrpi3_defconfig
-Configuramos el kernel con:
make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig

Ajustes al kernel:
-Asegúrate de que el scheduler está en LOW LATENCY DESKTOP (GENERAL SETUP) y que el scheduler está a 100Hz si usas MUQSS y a 1000Hz si no lo usas (KERNEL FEATURES). 
-En GENERAL SETUP, deshabilita EMBEDDED SYSTEM, lo que te perminirá desactivar CONFIGURE STANDARD KERNEL FEATURES, que es el symbol EXPERT=y (NO lo tienes que dejar a =y, sino desactivado, no lo dudes)
-En GENERAL SETUP, deshabilita abajo del todo SLUB PER CPU PARTIAL CACHE y PROFILING SUPPORT
Con esto desactivado, ya puedes ir a KERNEL HACKING y quitar KERNEL DEBUGGING.
-Quita todo en KERNEL HACKING (debugeo.. todo!). Quita dentro del KERNEL HACKING, en Compile-time checks and compiler options, "Compile the kernel with debug info"
-En KERNEL FEATURES, deshabilita "Speculative Store Bypass Disable" y el resto de mitigations
-Si quieres WIFI:
	En NETWORKING SUPPORT, activa WIRELESS, activa "CFG80211 wireless configuration api"
	En DEVICE DRIVERS->Network Device Support->WIRELESS LAN->Broadcom Devices->Broadcom FULLMAC WLAN Driver
	A parte, necesitas los ficheros brcmfmac43430-sdio.bin y brcmfmac43430-sdio.txt en /lib/firmware/brcm/ que se descargan de https://github.com/RPi-Distro/firmware-nonfree/blob/master/brcm
	Sólo si tienes esos ficheros puedes hacer: sudo ifconfig wlan0 up 
	Y deberías ver wlan0 levantado.

-En I/O SCHEDULER, quita TODOS los i/o scheduler, lo que hará que por defecto se use el no-op. Eso es lo correcto para unidades de disco solido.
-En CPU POWER MANAGEMENT, deja el governor performance solamente y ponlo por defecto.
-ASEGÚRATE DE TENER ACTIVADO COMO MÓDULO EL DRIVER DE LA TARJETA ETHERNET: ES EL CONFIG_USB_LAN78XX en el .config, y está en:
Device Drivers > Network device support > USB Network Adapters -> Microchip LAN78XX Based USB Ethernet Adapters
Si no funciona ni así, haz un sudo ifconfig -a, porque igual sí que funciona solo que no está puesto como eth0 (mira más abajo para ver cómo arreglarlo en tal caso).
-OJO, NO desactives el SYNOPSIS DWC en DEVICE DRIVERS->USB SUPPORT, porque es el USB host usado por la Raspberry Pi
-OJO, NO desactives el WATCHDOG de BCM2835 (En DEVICE DRIVERS->WATCHDOG TIER SUPPORT->BROADCOM BCM2835), o si no, no se reiniciará ni se apagará la Pi.
-OJO, NO desactives el FILE LOCKING API, en FILESYSTEMS. Es necesario para que funcione flock(), y flock() lo usan dpkg y apt-get.
-OJO, NO desaactives-> Device Drivers -> Graphics support -> Direct Rendering Manager -> Enable legacy fbdev support for your modesetting driver,
porque en el viejo FBDev es donde se pinta la consola TTY de texto!!
-OJO, ACTIVA como módulo Device Drivers->Input device support->Mouse interface (es para que funcione el servicio GPM, que nos da ratón en gestores de ventanas en modo texto como
TWIN, SCREEN, etc). Ya que estás aquí, DESACTIVA "Support for memoryless force-feedback devices"
-El único RTC que necesitas en DEVICE DRIVERS->REAL TIME CLOCK es el DALLAS/MAXIM DS1307

-Compilamos el kernel y los módulos así:
make -j6 O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-

-Instalamos los módulos del kernel así: (OJO!!!!!!!!!!!! MUCHO CUIDADO QUE UNAS VECES LA PARTICIÓN APARECE COMO CUSTOM_ROOT Y OTRAS COMO CUSTOM_ROOT1!!!!
SI LE PASAS LA RUTA EQUIVOCADA, TE FALTARÁN LOS MÓDULOS Y EL KERNEL ARRANCA PERO SIN MÓDULOS, POR LO QUE TENDRÁS UN BONITO PANTALLAZO NEGRO CON KMS, CUELGUES AL REINICIO, ETC)
sudo make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/media/manuel/CUSTOM_ROOT modules_install
(kernel_out es nuestro directorio de salida del kernel, los módulos, los dtbs y tal. Así va en esos tutoriales que usamos: mandando los resultados a un directorio a parte).

-Instalamos el kernel con:
cp ../kernel-out/arch/arm64/boot/Image /media/manuel/CUSTOM_BOOT/kernel8.img

-Nosotros no instalamos los módulos del kernel hasta el final, después de instalar el rootfs (que es la segunda parte de este documento
que estás leyendo). De momento instala el kernel (kernel8.img) y los dtb, y los overlays.
Los overlays están en arch/arm64/boot/dts/overlays/*.dtb* y los tienes que pasar a overlays, un directorio que cuelga directamente del raiz de la partición de boot (FAT32) de la SD.
(Vamos, como en Raspbian más o menos).
cp ../kernel-out/arch/arm64/boot/dts/broadcom/*.dtb /media/manuel/CUSTOM_BOOT/
cp ../kernel-out/arch/arm64/boot/dts/overlays/*.dtbo /media/manuel/CUSTOM_BOOT/overlays/

-En config.txt nosotros ponemos (a consecuencia de cómo tenemos las cosas instaladas):
device_tree=bcm2710-rpi-3-b-plus.dtb
overlay_prefix=overlays/
kernel=kernel8.img
arm_control=0x200

Puedes actualizar el firmware con el contenido de boot de este repo:
https://github.com/raspberrypi/firmware.git

PARTE 2: EL ROOTFS
==================

Seguimos el tutorial de:
https://www.debian.org/releases/stable/arm64/apds03.en.html

Lo primero formateamos la partición EXT4:
sudo mkfs.ext4 /dev/sdb2
Lo montamos como /mnt/LINUX
sudo mount /dev/sdb2 /mnt/LINUX

Instalamos el debootstrap:
sudo apt-get install debootstrap

La línea para hacer el debootstrap a un filesystem EXT4 vacío y montado en /mnt/LINUX es:
sudo debootstrap --foreign --arch arm64 buster /mnt/LINUX http://ftp.es.debian.org/debian

Ahora copiamos el quemu-static al nuevo sistema:
sudo cp /usr/bin/qemu-aarch64-static /mnt/LINUX/usr/bin/

Ahora chrooteamos al nuevo sistema (aún no hace falta que hagas el mount bind de dev, sys y proc, sólo con un chroot básico vale):
LANG=C.UTF-8 sudo chroot /mnt/LINUX qemu-aarch64-static /bin/bash

Exportamos el modelo de terminal del host:
export TERM=xterm-color

Y ahora empezamos con el 2nd stage del nuevo sistema! (Recuerda que para tener debootstrap/debootstrap has tenido que pasar la opción "--foreign" ahí arriba,
cuando ejecutaste debootstrap en el host al principio para empezar):
/debootstrap/debootstrap --second-stage

Aprovecha para:

-Crear el /etc/fstab con el contenido:
proc    /proc                   proc    defaults                                0       0
#PARTUUID=db375d88-08  /boot           vfat    defaults,noatime,nodiratime      0       2
PARTUUID=db375d88-09  /               ext4    defaults,noatime,nodiratime       0       1
(el PARTUUID lo puedes obtener con sudo blkid /dev/...)
-Ajustar el PARTUUID en cmdline.txt de la partición de boot.
-Instalar el VIM, sudo, net-tools, sshd... (sí, ¡funciona con la red del host!):
apt install vim sudo net-tools 
OJO!!!! NO INSTALES alsa-utils desde un entorno chrooted!!!! LO DEL AUDIO CON ALSA VA LUEGO!!!! TIENE SU PROPIA SECCIÓN!!!! NO LO HAGAS AQUÍ!!!!
-Para que sudo no de el error (unable to resolve host), en /etc/hosts, añade la línea:
127.0.1.1    raspi
(suponiendo que hayas llamado al sistema raspi en /etc/hostname, claro. Si lo has llamado de otra manera, pon el nombre correspondiente).
-Cambiar el password de root  mientras estás chrooteado
-Ajustar el hostname, en /etc/hostname.
-Arreglar el nombre del interface de red, que aparece como enx..., para que aparezca como eth0:
Editar /lib/udev/rules.d/73-usb-net-by-mac.rules y dejar así la línea de IMPORT, para que el interface ethernet se llame eth0 y no un churro basado en la MAC address:
IMPORT{builtin}="net_id", NAME="eth0"
Y para que futuras actualizaciones no nos jodan el arreglo, haz:
cp /lib/udev/rules.d/73-usb-net-by-mac.rules /etc/udev/rules.d/

-Instala bash-completion si quieres que funcione autocompletar cuando usas sudo:
apt-get install bash-completion
-Instala psmisc para tener killall:
apt-get install psmisc

¡¡¡Sólo si hemos hecho el rootfs en un disco y lo transferimos a otro!!!
Transferimos el rootfs desde el disco duro del host a la partición EXT4 de la tarjeta con:
cd debian_arm64
sudo rsync -avP --numeric-ids ./ /mnt/LINUX/

-QUE NO SE TE OLVIDE: Ahora instalamos los módulos del kernel en nuestro nuevo rootfs, QUE NO SE TE OLVIDE JAMÁS!!!!:
sudo make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/mnt/LINUX/ modules_install

-Y ahora ya, arranca el sistema en nativo. Adelante!!

OJO!!!!!!!!!! SI NO VES NADA EN LA PANTALLA (PANTALLA NEGRA!!!), LO MÁS PROBABLE ES QUE NO HAYAS INSTALADO LOS MÓDULOS DEL KERNEL!!!!!
ACABAS DE CONFIGURAR UN ROOTFS NUEVO, Y PRETENDES USAR UN KERNEL ANTERIOR O ALGO ASÍ, Y NO HAS INSTALADOS LOS MÓDULOS!!!!! INSTÁLALOS!!!!!

OJO!!!!!!!!!! SI AL EJECUTAR apt-get o dpkg TE DA ERRORES DE LOCKS, Y NO TE LOS DA ACCEDIENDO AL MISMO SISTEMA OBJETIVO POR CHROOT, ES QUE TIENES DESACTIVADO
EL FILE LOCKING API EN EL KERNEL, EN FILESYSTEMS->FILE LOCKING API. El file locking API es usado por flock(), que a su vez es usado por DPKG y APT. ACTÍVALO Y LISTO!!!!

!!!!!!!!!!!!!!!!!!!!!
SI TE DEJAS ALGO que no se pueda hacer en la máquina objetivo, puedes volver a chrootearte en la partición EXT4 de la SD después de haber transferido el rootfs,
y lo puedes hacer tantas veces como sea necesario, pero pasándole a chroot la ruta del raiz del EXT4 de la SD:

LANG=C.UTF-8 sudo chroot /media/manuel/CUSTOM_ROOT qemu-aarch64-static /bin/bash

Puede ser necesario hacer:
mount --rbind /dev dev/
Pero hazlo sólo si tienes problemas al instalar cosas en el entorno chrooted (como que apt-get se quede en "0% WAITING FOR HEADERS" clavado)!
Lo normal es que no te haga falta si no has borrado el contenido estático de /dev
(El contenido estático de /dev NO es necesario para un funcionamiento normal del sistema, pero sí para estas cosas. Si no lo borraste, no hace falta que hagas el mount binding de dev este).

***
Si te chrooteas y al ejecutar un simple "ls" te da un error "bash: /bin/ls: cannot execute binary file: Exec format error", debes reinstalar el qemu en el host, y luego copiarlo de nuevo
al sistema debian que estás instalando. O sea, si el rootfs del sistema está ya en /media/manuel/CUSTOM_ROOT:
sudo apt-get install qemu-user-static
sudo cp /usr/bin/qemu-aarch64-static /media/manuel/CUSTOM_ROOT/usr/bin/
LANG=C.UTF-8 sudo chroot /media/manuel/CUSTOM_ROOT qemu-aarch64-static /bin/bash
***
!!!!!!!!!!!!!!!!!!!!!!!!

OJO A ESTO QUE SIGUE: SI NO VES NADA EN LA PANTALLA HASTA EL LOGIN, NO ES QUE TE FALTE NADA EN /dev. SI TIENES console=tty1 EN CMDLINE.TXT SE TIENE QUE
VER. EL PROBLEMA ES QUE SYSTEMD LIMPIA LA CONSOLA TAN RÁPIDO ANTES DEL LOGIN, QUE PARECE QUE NO SALE NADA EN PANTALLA PERO ES MENTIRA.
¡¡NO NECESITAS FICHEROS PERMANENTES EN /dev PARA VER LOS MENSAJES DEL KERNEL Y DE SYSTEMD EN EL INICIO!!! NO TE RAYES. ¡¡¡NO NECESITAS NINGÚN FICHERO
PERMANENTE EN /dev, CON LOS QUE CREA UDEV EN EL ARRANQUE ES SUFICIENTE!!! (QUE SON INVISIBLES SI HACES UN CHROOT AL ROOTFS EN VEZ DE ARRANCAR 
EN ÉL DE VERDAD) 
Ahora hacemos que systemd deje de borrarnos la consola en el incio, o no veremos nada del arranque (ni del kernel ni de los procesos que va levantando systemd):
Para ello creamos el fichero:
/etc/systemd/system/getty@.service.d/noclear.conf
Con el contenido:
[Service]
TTYVTDisallocate=no

PARTE 3: FINETUNING THE SYSTEM
=============================

Una vez que hemos arrancado nativamente, tenemos mucho que hacer.

-RECUERDA que para poder logearte por SSH como ROOT tienes que editar /etc/ssh/sshd_config
y aniadir
PermitRootLogin yes

-Crear el usuario pi:
sudo adduser pi
sudo adduser pi sudo
sudo adduser pi audio
sudo adduser pi video
(Esto último es importante, porque has estado dando vueltas y el kernel sí reconocía el audio interno y la hifiberry (cat /proc/asound/cards)
pero aplay -L no listaba los dispositivos...¡porque no estabas en el grupo audio!)

-Deshabilita los timers de actualización diaria de APT:
sudo systemctl disable apt-daily-upgrade.timer
sudo systemctl disable apt-daily.timer
y crea el fichero:
/etc/apt/apt.conf.d/99periodic-disable
con el contenido:
APT::Periodic::Enable "0";

-Deshabilita el target de swap:
sudo systemctl mask swap.target

-Deshabilita los timers de cleaning de tmp y el timer de rotación diaria de logs:
sudo systectl mask systemd-tmpfiles-clean.timer
sudo systectl disable logrotate.timer
Otros timers activos los puedes buscar con:
sudo systemclt | grep timer
Y miras a ver cuáles están active loaded. Unos se quitan con mask, otros con disable.

-Para eliminar el error de "automount point not supported", simplemente haz:
sudo depmod -a
Y reinicia. Ya no debería salir más.

-Si después de hacer lo del autologin no puedes cambiar a TTY2 (ctrl+alt+f2), es porque no has activado el servicio. Haz:
sudo systemctl enable getty@tty2.service
Y ya podrás cambiar de TTY1 a TTY2!!!

-Fusiona el directorio /usr/lib y /usr/lib64, por si alguna librería se instala en la ruta no estándar /usr/lib64 y luego no se puede encontrar desde los programas que la usan:
sudo ln -s /usr/lib /usr/lib64
(Si /usr/lib64 no existe, bien, esto lo crea, y es como debería ser).

***BLOQUE ALSA****
-PARA INSTALAR ALSA:
Instalamos alsa-utils, pero NO desde el entorno chrooted sino nativamente.
Si no tienes red en la Pi, puedes descargar los paquetes en el entorno chrooted, y luego instalarlos en nativo, o sea, en dos pasos, mira:
1) En el entorno chrooted:
sudo apt-get clean (para que no haya lios con otros paquetes en /var/cache/apt/archives)
sudo apt-get install --download-only alsa-utils
2) En el entorno nativo, es decir, en la Pi sin red:
cd /var/cache/apt/archives
sudo dpkg -i *
AHORA PASA A CREAR /etc/asound.conf, cuyo contenido varía si usas la HIFIBERRY o si no la usas:


Si NO usas la hifiberry y quieres que el audio salga por HDMI, en config.txt tienes que tener:
dtparam=audio=on
hdmi_drive=2
force_hdmi_open=1
config_hdmi_boost=4

Y en /etc/asound.conf:
pcm.!default {
    type hw
    card ALSA
}

ctl.!default {
    type hw    
    card ALSA
}

-Si usas la hifiberry, acuérdate que en config.txt tienes que tener para que funcione:
dtoverlay=hifiberry-dacplus
Y la línea del audio interno comentada, para que el kernel sólo cargue la hifiberry:
#dtparam=audio=on

ESTO ES IMPORTANTE: Para que siempre se elija la hifiberry como tarjeta por defecto, crea este /etc/asound.conf:
pcm.!default {
    type hw
    card sndrpihifiberry
}

ctl.!default {
    type hw    
    card sndrpihifiberry
}

-Ahora ajusta los niveles en ALSAMIXER, que se van a quedar como los dejes porque vamos a quitar los servicios que los guardan y los restauran

-Y ahora quita los servicios que guardan y restauran los niveles de ALSA:
sudo systemctl mask alsa-state.service 
sudo systemctl mask alsa-restore.service

Y ya van a quedar así para siempre los niveles. Si los quieres cambiar, pues unmaskeas los servicios state y restore, los cambias, reinicias y los vuelves a maskear.
****FIN BLOQUE ALSA****

-Crear el /usr/bin/netup con:
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo systemctl start dropbear
(OJO: dropbear ya no arranca a mano con '/etc/init.d/dropbear start')

-Instalar dropbear, generar sus claves y quitarlo del arranque sin maskearlo, porque si no luego no arranca desde mi script netup.
(Esto además instala fuentes, setup de la consola y todo eso, que nos va a hacer falta)
apt-get install dropbear
dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
sudo systemctl disable dropbear
(CUIDADO QUE SIN LAS CLAVES NO FUNCIONA!!!)

-Configuramos la consola, el teclado y los locales (NO LO HAGAS POR SSH, o fallará por culpa de los LOCALE de la máquina desde la que te conectas
y perderás un buen rato):
sudo apt-get install locales console-setup console-data keyboard-configuration
sudo dpkg-reconfigure console-setup
sudo dpkg-reconfigure locales
(generamos sólo en_US.UTF-8, y dejamos puesto por defecto ese antes de salir. Tenemos que comprobar con el comando locale que todo sale puesto a en_US.UTF-8 y NO a POSIX)
sudo dpkg-reconfigure keyboard-configuration
Tras reiniciar (sí, hay que reiniciar), ya tendría que ir la Ñ, los acentos y todo eso.
Si queremos cambiar la distribución del teclado de nuevo (porque cambiamos de sistema y/o teclado) basta con volver a hacer:
sudo dpkg-reconfigure keyboard-configuration
Eso sí, asegúrate antes de que el comando "locale" nos dice que está todo a en_US.UTF-8.

-Vamos quitando los servicios con:
sudo systemctl mask <sevcio> 
-Al final, de acuerdo con systemd-analyze blame, sólo quedan iniciados estos:

-Para que funcione el teclado, ratón y joystick con las SDL2, creamos /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Y reiniciamos.

-Para quitar el error: "brcmfmac: brcmf_sdio_htclk: HT Avail timeout (1000000): clkctl 0x50"
Puedes instalar el firmware de la wifi, o simplemente deshabilitarla poniendo en config.txt:
dtoverlay=pi3-disable-wifi

-Para ocultar los mensajes de systemd en el inicio, pon en cmdline.txt:
systemd.show_status=false

-Para evitar errores en el inicio relacionados con systemd-journald-audit.socket (que nosotros NO tenemos), pon en cmdline.txt:
audit=0

-Para evitar parones (stalls) en el vídeo de los juegos debido al i/o scheduler, pon en cmdline.txt:
elevator=noop

-En .bashrc, descomenta para tener el prompt en color:
force_color_prompt=yes

-El mensaje que quieras que se vea en el inicio, ponlo en /etc/issue

-TENEMOS QUE QUITAR LOS RLIMITS, o los emuladores se empezarán a quejar al llegar al 80% de uso de la CPU!
Para ello, editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:

@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

De este modo, no hay límites para el usuario Pi ni para nadie del grupo audio, como jackd.
Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

-Para configurar el audio con el driver de audio HDMI del lado de ARM (que es como lo venimos haciendo en 2020):
	-En config.txt
		dtoverlay=vc4-kms-v3d-pi4
		(o bien dtoverlay=vc4-kms-v3d para pi3 y anteriores)
		#dtparam=audio=on <---SE DEBE deshabilitar la carga de bcm2835.
	-Si falla speakertest, mira que tengas en /usr/share/alsa/cards/vc4-hdmi.conf lo que pone en el post de DOM en
	 https://www.raspberrypi.org/forums/viewtopic.php?f=29&t=269769&p=1636828#p1636828
	 OJO! PARECE QUE SEGÚN SE ACTUALIZA EL KERNEL, LOS CONTENIDOS DE /usr/share/alsa/cards/vc4-hdmi.conf hay que irlos cambiando
	 a veces. Así que si no te va, mira o pregunta en ese hilo.	
	-Si falla algo, pregunta en este hilo a dom:https://www.raspberrypi.org/forums/viewtopic.php?f=29&t=269769
     Y YA. CON ESTO TIENE QUE FUNCIONAR SÍ O SÍ. 

-Si el guardado y restauración de los valores de alsamixer falla a veces, tienes DOS opciones:

	-La que uso SIN LA HIFIBERRY (podría fallar a veces ya que el ordering de las tarjetas puede cambiar entre arranques, no está claro. Lo ideal sería tener sólo la tarjeta vc4-hdmi, pero en 64bit no suena):
		En vim drivers/gpu/drm/vc4/vc4_hdmi.c, haz que la función vc4_hdmi_audio_init retorne cero y no haga nada más. Adiós a la tarjeta vc4-hdmi!!

		En /etc/asound.conf tenemos esto, aunque no hace falta si te has cargado la tarjeta vc4-hdmi:
 
			pcm.!default {
    				type hw
    				card ALSA
			}
			
			ctl.!default {
    				type hw    
    				card ALSA
			}

		Deshabilita el servicio alsa-restore.service (sudo systemctl mask alsa-restore.service), pon los controles a tu gusto en alsamixer, y guarda la configuración con:
		alsactl store -f /etc/asound.state
		Prueba a cargar la configuración con:
		sudo alsactl restore -f /etc/asound.state
		Si todo va bien, ALSA va a restaurar esos valores en cada arranque, leyéndolos de /etc/asound.state, sin que hagas nada y sin ningún servicio.
		Si quieres, puedes aniadir lo de alsactl restore al .profile		

	-LA QUE USO CON LA HIFIBERRY: Se supone que funciona siempre porque aunque el ordering de las tarjetas puede cambiar entre arranques, estamos espeficicando la tarjeta por
	    defecto en /etc/asound.conf con el contenido:
	    	pcm.!default {
    			type hw
    			card sndrpihifiberry
			}
			
			ctl.!default {
    			type hw    
    			card sndrpihifiberry
			}					
		Deshabilita el servicio alsa-restore.service, y pon en .profile:
		amixer set Digital 85% -q
		Esto lo que hace es que te pone el control llamado Digital a 55 (no a 85 como podría parecer). Puedes ver los controles con "amixer scontrols".
		Vamos, que esto lo que hace es que pongas a mano el valor que quieras para cada control de la tarjeta por defecto (también se puede elegir tarjeta y tal, mira "man amixer"
		si ves que te hace falta).

	-EXPERIMENTAL, NO FUNCIONA: Sería la más recomemdada: soluciona los problemas de ordering, porque tienes dos tarjetas. Para ello, crea /etc/modprobe.d/alsa-base.conf con:
		options snd_soc_hifiberry_dacplus index=0
		options vc4 index=1
	 De esta manera, el servicio de restauración de ALSA (alsa-restore.service) no debería fallar nunca, porque la primera tarjeta es siempre la hifiberry y aplicaría los
	 valores guardados correctos para cada tarjeta en el arranque, ya que el ordering de las tarjetas no cambiaría nunca.


-Al final, sólo necesitas estos servicios de los que salen con systemd-analyze blame:
pi@raspberrypi:~$ sudo systemd-analyze blame
           542ms dev-mmcblk0p2.device
          1.011s alsa-restore.service
           382ms keyboard-setup.service
           266ms systemd-udevd.service
           238ms systemd-remount-fs.service
           128ms fake-hwclock.service
           124ms systemd-udev-trigger.service
            54ms console-setup.service
            28ms systemd-modules-load.service
            24ms systemd-user-sessions.service
            15ms boot.mount
            10ms kmod-static-nodes.service
Recuerda mirar las mierdas que lanza systemd en el arranque antes de ocultarlo, y mira los targets con
sudo systemctl | grep <loquesea>
Luego los vas quitando, al igual que los services, con systemctl mask <monbre service o target>
Si metes la pata y el sistema no arranca más, elimina cosas de /etc/systemd/system, que es donde pone los links a /dev/null correspondientes a los services o targets que hayas eliminado
sin deber hacerlo...

-Si PING te da el error "ping: socket: Address family not supported by protocol", simplemente haz:
sudo chmod 4755 /bin/ping
Y ya te irá perfectamente.

INSTALAR MESA
==============

NOCIONES PREVIAS DE APIS, DEPENDENCIAS, Y SOPORTE DE OPENGL COMPLETO (NO GLES)

Mesa se puede compilar con GLX o con glvnd o con ninguno de los dos.
Compilar MESA para GLX nos produce libGL.so, que es lo que hace falta para OPENGL COMPLETO (NO GLES). Pero eso depende de muchas librerías de las X11.
Una alternativa es compilar MESA para LIBGLVND, que es un GLES multifabricante de NVIDIA, opensource. En ese caso, MESA produce libEGL_mesa.so pero NO produce libEGL.so. Tampoco produce
libGL.so, sino libglapi.so. PERO que tengamos libGL.so o libglapi.so NOS DEBERÍA DAR IGUAL porque los programas se deberían basar en usar libEGL.so y NO buscar libGL.so o libglapi.so directamente, sólo
deberían entender de libEGL.so!!! Y las SDL2 igual, sólo deberían entender de libEGL.so.

Si queremos que MESA nos aporte un libEGL.so, tenemos que compilarla, o bien con glx, o bien SIN GLX NI TAMPOCO LIBGLVND. Entonces sí crea un libEGL.so en vez de un libEGL_mesa.so.
Pero en ese caso, al no haber GLX (libGL.so), loas SDL2 interpretan que no tenemos OpenGL COMPLETO (NO GLES) porque lo que hacen es buscar de algún modo libGL.so en vez de simplemente
buscar libEGL.so y abstraerse de si tenemos libGL.so o libglapi.so

DICHO de otro modo: SDL2 para tener OPENGL COMPLETO, necesita GLX. SDL2 NO encuentra OPENGL completo si no es con GLX: si compilas MESA con OPENGL COMPLETO mediante libglvnd, SDL2 no lo detecta, sólo detecta GLES. Y MESA, si se compila con GLX, se tiene que compilar con las plataformas drm y x11. Y al compilarse para X11, tiene un montón de dependencias de X11 aunque no necesite el servidor funcionando.
Lo ideal es que SDL2, para tener soporte para OPENGL COMPLETO, sólo necesitase libEGL.so y le diese igual tener libglapi.so o libGL.so. De ese modo, podríamos compilar MESA con platform=drm solamente, y sin necesidad de GLX ni de LIBGLVND.
Si compilamos MESA sin GLX ni LIBGLVND, en SDL2 actualmente sólo tenemos GLES1 y GLES2, no OPENGL COMPLETO.

Si MESA te da un error de que no encuentra GL/glxproto.h, reinstala el paquete x11proto-dev

FIN NOCIONES PREVIAS

¡¡¡OJO!!! LO PRIMERO EN LA PI4, AÑADE AL USUARIO "pi" AL GRUPO RENDER, O TE VOLVERÁS LOCO PORQUE GLES NO IRÁ PERO DRM SÍ (o sea, modetest funciona pero MESA no puede cargar GLES). PARA ELLO, HAZ:
sudo usermod -a -G render pi

TAMBIÉN, ACTUALIZA AL ÚLTIMO KERNEL DEL BRANCH NEXT:
sudo BRANCH=next rpi-update

Empezamos con libDRM:
Instalamos estas dependencias previas: 
sudo apt-get install xsltproc libpciaccess-dev xutils-dev libtool make automake pkg-config gcc g++ meson --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente)
Bajamos la última versión estable de:
https://dri.freedesktop.org/libdrm/
mkdir b3
cd b3

Configuramos libdrm con esto:
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" meson -Dudev=true -Dvc4=true -Dintel=false -Dvmwgfx=false -Dradeon=false -Damdgpu=false -Dnouveau=false -Dfreedreno=false -Dinstall-test-programs=true ..

Compilamos e instalamos:
ninja -j4
sudo ninja install

En este punto, puedes probar si libdrm te funciona bien haciendo:
modetest -s 32:1360x768
(donde 32 es un ID de conector válido: puedes ver los conectores con modetest|more).

Ahora vamos a por MESA. Instalamos estos paquetes previos:

(SI NO QUIERES GLX, SINO LIBGLVND O NI GLX NI LIBGLVND, SÓLO NECESITAS ESTAS. PERO EN TAL CASO, SDL2 NO FUNCIONARÁ CON OPENGL COMPLETO, SÓLO GLES1 Y GLES2:)
sudo apt-get install --no-install-recommends \
    flex bison python3-mako python3-setuptools \
    libexpat1-dev libudev-dev gettext \
    ca-certificates xz-utils \
    zlib1g-dev pkg-config meson

SÓLO SI DECIDES COMPILAR MESA CONTRA LIBGLVND, PUES TIENES QUE INSTALAR LIBGLVND. OJO, SI SÓLO QUIERES GLES, NO NECESITAS LIBGLVND:
sudo apt-get install libtool
sudo apt-get install  libx11-dev libxext-dev --no-install-recommends
git clone --depth 1 https://github.com/NVIDIA/libglvnd.git
./autogen.sh
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" ./configure --prefix=/usr --disable-glx
etc... (no recomendado porque SDL2 no funciona con libglapi.so, ver más arriba).

(SI QUIERES GLX, PARA QUE SDL2 FUNCIONE CON OPENGL COMPLETO, GLES1 Y GLES2, NECESITAS TODO ESTO:).
sudo apt-get install --no-install-recommends --reinstall \
    flex bison python3-mako libexpat1-dev \
    libxcb-dri3-dev libxcb-dri2-0-dev \
    libxcb-glx0-dev libx11-xcb-dev \
    libxcb-present-dev libxcb-sync-dev \
    libxshmfence-dev libxxf86vm-dev libxrandr-dev \
    libxdamage-dev libxext-dev libxfixes-dev \
    x11proto-dri2-dev x11proto-dri3-dev \
    x11proto-present-dev x11proto-gl-dev \
    libudev-dev gettext \
    ca-certificates xz-utils \
    zlib1g-dev pkg-config meson

Bajamos los últimos estables de:
https://mesa.freedesktop.org/archive/
Las instrucciones para compilar con MESON se pueden ver en: https://www.mesa3d.org/meson.html
Pero yo ya lo tengo resumido a continuación...mira:
configuramos con:
mkdir b3
cd b3
AHORA PARA CONFIGURAR:
ASI LO VENIMOS HACIENDO:  CON GLES Y GLES2, SIN OPENGL COMPLETO:
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" meson -Dglx=disabled -Dplatforms= -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

SI QUISIERAS GLES, GLES2 Y OPENGL COMPLETO MEDIANTE GLX:
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" meson -Dglx=dri -Dplatforms=drm,x11 -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

SI QUISIERAS GLES, GLES2 Y OPENGL COMPLETO MEDIANTE GLVND:
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" meson -Dglx=disabled -Dglvnd=true -Dplatforms= -Dllvm=disabled -Dvulkan-drivers='' -Ddri-drivers='' -Dgallium-drivers=vc4,v3d,kmsro -Dbuildtype=release ..

PARA COMPILAR:
ninja -j3 (NO USES -j4 si has quitado los rlimits, o petarás la máquina por agotamiento de CPU!)
PARA INSTALAR:
sudo ninja install
Y NO TE OLVIDES DE HACER:
sudo rm /etc/ld.so.cache
sudo ldconfig

Y PARA DESINSTALAR:
sudo ninja uninstall
O ALTERNATIVAMENTE:
meson introspect ./ --installed | python3 -c 'import sys; a = eval(sys.stdin.read()); print(" ".join(a.keys()))' | xargs rm

(si quieres ver las lineas de compilación, pásale -v).
La cosa es que al usar glvnd ahora, ya no dependemos de librerías relacionadas con las X. No tenemos GLX, pero tenemos FULL OPENGL sobre contexto EGL! GLX depende de las X sí o sí, aunque sea sólo en build time
y no en runtime, y EGL no. Por eso usamos glvnd y así tenemos full opengl sin X11 ni sus librerías: mira:
<imirkin> SDL2 has no knowledge of glapi
<imirkin> SDL2 knows about EGL, which in turn has cleverness.
<imirkin> glapi is an internal mesa detail

!!!!NOTA QUE TE PUEDE INTERESAR EN EL FUTURO: En X86_64, donde se usa el driver i965 que NO es gallium sino dri, se haría:
CFLAGS="-O2 -march=native -mtune=native" CXXFLAGS="-O2  -march=native -mtune=native" meson --buildtype=plain -Db_ndebug=true -Dglvnd=true -Dplatforms=drm -Dglx=disabled -Dllvm=false -Ddri-drivers=i915 -Dgallium-drivers='' -Dvulkan-drivers='' ..

Si al compilar te da un error de que NULL no está definido, añade en src/egl/main/egldevice.h:
#include <stddef.h>

COPIAR ARCHIVOS DESDE UN SISTEMA ANTIGUO
=========================================

Lo puedes hacer con rsync -av <origen> <destino>
Ambos sistemos deben tener instalado rsync, y se puede usar por red como scp.

INSTALAR SDL2
=============

Lo primero es instalar estos:
sudo apt-get install libudev-dev libasound2-dev libvorbis-dev libflac-dev libmodplug-dev libpng-dev libjpeg-dev libfreetype6-dev --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente)

Por ahora, hasta que salga SDL 2.0.11, tenemos que cambiar código para que funcione bien el resampler de audio acelerado para instrucciones NEON. 
Para ello, actualizamos src/audio/SDL_audiotypecvt.c desde la versión actual, que podemos sacar de https://hg.libsdl.org/SDL
(En la parte de arriba tienes la última versión en ZIP, TAR, etc... Sobreescribe el  src/audio/SDL_audiotypecvt.c con la versión actualizada de aquí).

SÓLO CON GLES1 y GLES2, COMO LO HACEMOS AHORA:
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" ./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --disable-video-opengl --enable-libudev --disable-ime --disable-libsamplerate --disable-video-vulkan

SÓLO CON GLES1 y GLES2, COMO LO HACEMOS AHORA, PERO EN MODO DEBUG:
CFLAGS="-O0 -ggdb -DEGL_NO_X11" CXXFLAGS="-O0 -ggdb -DEGL_NO_X11" ./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --disable-video-opengl --enable-libudev --disable-ime --disable-libsamplerate --disable-video-vulkan

CON OPENGL COMPLETO, GLES1 y GLES2
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" ./configure --enable-video-kmsdrm --disable-video-x11 --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl --enable-libudev --disable-ime --disable-libsamplerate --disable-video-vulkan 

(LO DE -DMESA_EGL_NO_X11_HEADERS LO HEMOS SACADO DE /usr/lib/pkgconfig/egl.pc. Como el viejo buildsystem de las SDL2 basado en configure y make no usa pkgconfig para saber qué flags tiene que pasar cuando
se compile eglplatform.h, parte de EGL de MESA, que es donde  MESA_EGL_NO_X11_HEADERS evita intentar incluir las headers de X11, pues se lo tenemos que pasar nosotros a mano. El buildsystem de las SDL2 basado en CMAKE sí
pasa correctamente el  -DMESA_EGL_NO_X11_HEADERS de /usr/lib/pkgconfig/egl.pc, porque usa pkconfig para saber qué flags tiene que pasar cuando compila los headers de EGL).

TEMPORAL (SIN PROBAR DEL TODO) CON CMAKE POR SI UN DÍA HAY QUE CAMBIAR AL CMAKE (ESPEREMOS QUE NO!):
cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DASSERTIONS=disabled -DVIDEO_DUMMY=OFF -DVIDEO_VULKAN=OFF -DDISKAUDIO=OFF -DDUMMYAUDIO=OFF -DOSS=OFF ..

Compilar e instalar.

No te olvides de aniadir en /etc/profile:
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

Y si tienes un mando que no es detectado por las SDL2 como gamecontroller (lo sabrás porque no funciona con el Prince...), saca su cadena de mapping de la SDL2 Gamepad Tool (http://www.generalarcade.com/gamepadtool),
 y la aniades en /etc/profile usando la variable de entorno SDL_GAMECONTROLLERCONFIG, tal que así:
SDL_GAMECONTROLLERCONFIG="030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,"

Para SDL2_Mixer (instalar antes libogg-dev y libflac-dev):
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" ./configure --disable-music-midi-timidity --disable-music-midi-fluidsynth

Para SDL2_Image o SDL2_ttf:
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" ./configure --without-x

INSTALAR RETROARCH
===================

Se configura con:

CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" ./configure --disable-videocore --disable-vulkan --disable-ibxm --disable-vg --disable-x11 --disable-wayland --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg --disable-networking --disable-netplaydiscovery --disable-libretrodb --enable-udev --disable-sdl --disable-pulse --disable-oss --disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac --disable-qt --disable-materialui --enable-xmb --enable-rgui --disable-ozone --disable-gfx_widgets --disable-langextra --disable-cdrom --disable-accessibility --disable-tinyalsa --disable-glslang --disable-builtinglslang --disable-rpiled --enable-egl --enable-opengles --enable-opengles3 --enable-opengles3_1

(NO le pases --enable-neon ni --enable-floathard, o fallará el configure porque dlopen() no va bien)

Compilar y listo.

Si quieres que te salgan iconos en el menú XMB en lugar de cuadrados negros, necesitas los assets de aquí: https://github.com/libretro/retroarch-assets
De ese repo, necesitas solamente el directorio ozone en el directorio de assets. El directorio de assets se cambia en el menú o en el cfg. Yo los tengo en ~/retro/assets,
de tal manera que ahí quedaría el directorio xmb del repo, tal que ~/retro/assets/xmb
Con assets/xmb y assets/rgui te vale, borra los demás.
Con el RGUI es igual.

Si quieres configurar un tema del XMB o del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE.
En RGUI, para que se ponga el tema que elijas con CUSTOM THEME PRESET, tienes que poner MENU COLOR THEME en CUSTOM.
En XMB, puedes desactivas el lazo de fondo en SETTINGS->USER INTERFACE->APPEARANCE si quieres.
Para XMB, un buen tema es el Systematic ("SETTINGS->USER INTERFACE->APPEARANCE->MENU ICON THEME")


SECCIÓN VULKAN
==============

¡¡¡OJO!!! LO PRIMERO EN LA PI4, AÑADE AL USUARIO "pi" AL GRUPO RENDER, O TE VOLVERÁS LOCO PORQUE GLES NO IRÁ PERO DRM SÍ (o sea, modetest funciona pero MESA no puede cargar GLES). PARA ELLO, HAZ:
sudo usermod -a -G render pi

---BLOQUE MESA CON VULKAN---

Clonamos el repo de MESA en gitlab (por ahora no hay versión estable que tenga VULKAN para la Pi...):
git clone --depth 1 https://gitlab.freedesktop.org/mesa/mesa.git

Instalamos unas dependencias previas:
sudo apt-get install libvulkan-dev libvulkan1 vulkan-tools --no-install-recommends

Configuramos así (NO hace falta especificar platforms=drm, porque drm se selecciona solo):
CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72" meson -Dglx=disabled -Dplatforms= -Dllvm=disabled -Dvulkan-drivers=broadcom -Ddri-drivers='' -Dgallium-drivers=v3d,vc4,kmsro -Dbuildtype=release ..

Y YA DEBERÍA ESTAR. Ejecuta vulkaninfo para ver que todo va bien.

---FIN BLOQUE MESA VULKAN---

---RETROARCH CON VULKAN---

Instalamos el compilador de shaders:
sudo apt-get install glslang-dev glslang-tools spirv-tools

Configuramos para Pi4 con VULKAN solamente:

CFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" CXXFLAGS="-O2 -march=armv8-a+crc+simd -mtune=cortex-a72 -DEGL_NO_X11" ./configure --disable-ibxm --disable-vg --disable-x11 --disable-wayland --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg --disable-networking --disable-netplaydiscovery --disable-libretrodb --enable-udev --disable-sdl --disable-pulse --disable-oss --disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac --disable-qt --disable-materialui --enable-xmb --enable-rgui --disable-ozone --disable-gfx_widgets --disable-langextra --disable-cdrom --disable-accessibility --disable-tinyalsa --disable-builtinglslang --disable-rpiled --disable-egl --disable-opengles --enable-vulkan

SI DUCKSTATION DA SEGFAULT AL SELECCIONAR VULKAN, VE A SETTINGS->VIDEO->OUTPUT Y EN "OUTPUT" SELECCIONA "VULKAN"

PARA CUALQUIER PROBLEMA de librerías no encontradas pero que sí están instaladas, RECUERDA REGENERAR LA CACHE DE LDD:
sudo rm /etc/ld.so.cache
sudo ldconfig
