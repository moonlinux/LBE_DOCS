ALGORITMO DE SWAPBUFFERS EN ATOMIC
===================================

Unas palabras de robclark describiendo el algoritmo SwapWindow() para doble buffer, para ver cómo interactuamos con el kernel mediante los fences:
20:59 <robclark> it would be something like:   void MySwapBuffers() { in_fence_fd =  create_gpu_fence_and_export_to_fd();  
                 eglSwapBuffers(); atomic_commit(); /* <== returns out_fd */ display_fence = import_fd_to_egl_fence(out_fd);  
                 eglWaitSyncKHR(display_fence); }
                 
**Notas de lo anterior: 
    --atomic_commit() devuelve out_fd, o sea, kms_out_fence_fd dejándolo en dispdata->kms_out_fence_fd
    --atomic_commit() coge in_fd, o sea, kms_in_fence_fd dejándolo en dispdata->kms_in_fende_fd
                 
LOS FENCES según los creamos (eglCreateSync..() son fence ptrs. El juego es pasárselos al kernel, luego recogerlos
y esperar en ellos.
Hay que:
-exportarlos a FD para pasárselos al kernel
-cuando el kernel los devuelve, importarlos de nuevo a fence prt
-esperar en ellos (con eglWait..() o eglClienWait..())

*****COSAS PREVIAS PARA ENTERDER SwapWindow() con ATOMIC PAGEFLIP*************

-Lo primero, recuerda que durante el loop de juego la GPU construye, mediante las lamadas GL, el cmdstream. LO CONSTRUYE, y luelo LO EJECUTA, y sólo al renderizar es cuando renderiza en un buffer. Esta separación entre construir el cmdstring y renderizar el cmdstring es fundamental, ya que si bien dejamos que la GPU construya otro cmdstring completo correspondiente a un frame al volver al loop de juego, NO permitimos que lo renderice hasta completarse el último pageflip solicitado (ya que lo renderizaría en un buffer que aún es el front buffer...causando tearing).
 
-Hay dos niveles: el nivel EGL y el nivel KMS. Que algo se haya hecho a nivel EGL no quiere decir que esté hecho a nivel KMS.
Por eso tenemos que sincronizarlos.
-eglWaitSync() NO bloquea el programa llamante, sino que le dice a la GPU que se bloquee hasta que se señalice una fence, pero eso se hace fuera de nuestro control. Se usa para que la GPU no ejecute el cmdstream hasta que se haya completado el pageflip, porque si empezase a ejecutar el cmdstream antes de completarse el pageflip, se vería cómo dibuja ya que la GPU dibujaría en el que aún es el front buffer (y que no deja de serlo hasta completarse el pageflip).
-eglClientWaitSync() SÍ bloquea al programa llamante hasta que se señalice una fence. Se usa para que no entremos otra vez en el loop del juego otra vez sin antes completarse los cambios solicitados en el atomic ioctl (o sea, sin completarse el pageflip en este caso).

TODA atomic ioctl admite que metas un FD a la entrada, y que saques un FD a la salida. Qué haya en esos FDs depende de nosotros, pero en general, EL FD QUE METAS A LA ENTRADA DEL ATOMIC IOCTL LE DA INSTRUCCIONES AL KERNEL PARA QUE LAS TENGA EN CUENTA AL HACER LOS CAMBIOS KMS SOLICITADOS EN EL IOCTL, Y EL FD QUE SACAMOS A LA SALIDA SIRVE PARA AVISARNOS DE QUE LSO CAMBIOS SOLICITADOS EN EL IOCTL SE HAN COMPLETADO EFECTIVAMENTE.
Concretamente, en este caso nuestro:

-kms_in_fence_fd es el FD que METEMOS en el kernel. Es un FD DE ENTRADA, POR LO QUE NO SE SEÑALIZA EXTERNAMENTE, NO PODEMOS RECOGERLO A LA SALIDA: SIMPLEMENTE LE PASA AL KERNEL LA ÓRDEN DE BLOQUEAR LA REZALIZACIÖN LOS CAMBIOS SOLICITADOS EN EL IOCTL HASTA QUE LA GPU COMPLETE EL RENDERIZADO DE UN FRAME. O SEA, ES PARA DAR UNA INSTRUCCIÓN AL KERNEL ("eh, kernel! no hagas los cambios KMS solicitados hasta que la GPU acabe el frame! Cuando los vayas a aplicar, mira si la GPU ha acabado, y si no ha acabado, TE ESPERAS A QUE ACABE.") DE CARA A UNA ESPERA FUTURA CUANDO SOLICITEMOS LOS CAMBIOS, COSA QUE SE HARÁ EN EL ATOMIC IOCTL, Y YA. Entra para dar esa instrucción de que KMS espere a la GPU cuando vaya a aplicar los cambios solicitados, y ya.
NO ES USADO ni directa ni indirectamente por ninguna función eglWaitSync...() ni eglClientWaitSync...(), ya que no tendría sentido, sólo es para darle una instrucción al kernel a futuro y ya. 

-kms_out_fence_fd es el FD que SACAMOS del kernel. Es un FD DE SALIDA, POR LO QUE VALE PARA QUE EL KERNEL NOS SEÑALICE QUE HA COMPLETADO LOS CAMBIOS SOLICITADOS EN EL ATOMIC IOCTL. Lo usamos en eglWaitSync(), tras importarlo a kms_fence, para que la GPU no renderice (=no ejecute el cmdstring construido de un frame completo) hasta que se hayan completado los cambios solicitados en el atomic ioctl (=hasta que se haya completado el pageflip solicitado).   
kms_fence también se usa para bloquear el programa en eglClientWaitSync() hasta que se haya completado el pageflip solicitado en el atomic ioctl.


TIENES QUE VERLO, RESUMIDAMENTE, COMO QUE LE DECIMOS A KMS QUE ESPERE A LA GPU, Y LE DECIMOS A LA GPU QUE ESPERE A KMS, a grandes rasgos así:
1) Se le dice a KMS que antes de realizar los cambios que le vamos a solicitar más adelante en el atomic ioctl (=el pageflip en este caso) tiene que esperar a que la GPU acabe de renderizar.
Esto se le dice al kernel (KMS) en tanto que exportamos gpu_fence a kms_in_fence_fd, dejándolo allí preparado, y luego haciendo el atomic ioctl con este FD de entrada preparado. Así se lo transmitimos al kernel: debes esperar a que la GPU acabe de renderizar y luego ya haces los cambios KMS.
Una vez hemos paso esta info al kernel al principio de la función de SapWindow(), ya nos olvidamos de gpu_fence, ya lo hemos usado para dar esa instrucción al kernel de cómo va a tener que actuar en el futuro cuando le solicitemos los cambios KMS en el atomic ioctl, y no lo vamos a usar más.
No esperes una llamada eglSync..() o eglClientSync...() con la gpu_fence, obviamente.

2) Se le dice a la GPU que antes de renderizar el siguiente frame tiene que esperar a que se complete el último pageflip solicitado.
Para esto se usa kms_out_fence_fd, importado a kms_fence para poderlo usar nosotros, mediante eglWaitSyncKHR()
Recuerda que eglWaitSyncKHR() no es bloqueante, sólo le da una instrucción a la GPU ("eh! GPU! Antes de renderizar otro frame, espérate a que se haga el pageflip solicitado en el atomic ioctl!") y el programa sigue corriendo.

O SEA: SE DAN UNAS INSTRUCCIONES ("KMS, TÚ ESPERA A LA GPU! Y TÜ, GPU, ESPERA A KMS!") Y SE PONE A RODAR LA BOLA: Y LA SINCRONIZACIÓN KMS->GPU Y GPU->KMS SE PRODUCE SOLA SIN NUESTRA INTERVENCIÓN. ESTO TIENES QUE VERLO ASÏ DE CLARO.
También podríamos decir que en realidad sólo existe un fence, ya que sólo hay un atomic ioctl, y que este fence funciona para que KMS espere a la GPU, y para que la GPÛ espere a KMS, usando la mecánica que acabo de describir.


*****MÁS COSAS PREVIAS PARA ENTENDER SwapWindow() con ATOMIC PAGEFLIP*********
-Lo tienes que ver así: nosotros no controlamos directamente la sincronización entre KMS y GPU, sino que DAMOS INSTRUCCIONES POR ADELANTADO PARA QUE SE SINCONICEN, Y DEJAMOS QUE CADA PARTE (KMS Y GPU) HAGA SU TRABAJO DE FORMA PARALELA, ESPERÁNDOSE UNA A LA OTRA CUANDO HAGA FALTA EN BASE A LAS INSTRUCCIONES QUE HEMOS DADO.
Vamos:
Colocando gpu_fence en km_in_fence_fd, que es el FD que METEMOS en el kernel 

Sólo hay un punto en que nosotros SÍ controlamos desde el programa que el programa se bloquee, que es en eglClientWaitSync(), que se hace para que no se haga otro atomic ioctl hasta completarse el anterior (hasta completarse el pageflip, que es lo que solicitamos en esto satomic ioctls), porque daría errores si "se amontonan".



*****AHORA SÍ: GUÍA PARA ENTENDER SwapWindow() CON ATOMIC PAGEFLIP******

-Nada más entrar, creamos la gpu_fence, porque venimos de construir el cmdstream correspondiente a un frame completo, y queremos
que la gpu_fence se inserte en el cmdstream en ese punto, de manera que cuando se señalice sepamos que la GPU ha terminado de renderizar
un frame completo. POR ESO creamos la gpu_fence en este punto exacto.
Por cierto: este fence se usa para luego bloquear la realización de los cambios solicitados en el atomio ioctl hasta que la GPU termine de renderizar un frame completo.

-Llamamos a eglSwapBuffers() para marcar, a nivel de EGL, qué buffer queremos poner como siguiente front buffer. El pageflip (cambio de front buffer) no se hace aún, porque eso ocurre a nivel de KMS y ahí no lo hemos solicitado a KMS siquiera. Sólo marcamos a nivel de EGL.

-Como eglSwapBuffers() es lo que realmente "echa" el gpu_fence en el cmdstream ("flushes the gpu_fence down the cmdstream"),
ya podemos coger el FD de entrada al kernel de gpu_fence. Es decir: exportamos la gpu_fence al FD de entrada al kernel,
de manera que se le pasará al kernel ese FD de entrada cuando se haga la atomic ioctl más abajo.
(Por si te pierdes, la exportación de gpu_fence al FD de entrada al kernel lo hacemos con eglDupNativeFenceFDANDROID)
ESTE ES EL PUNTO DONDE ESTABLECEMOS A FUTURO LA SINCRONIZACIÓN DE KMS RESPECTO A LA GPU, O SEA, DONDE DEJAMOS ESTABLECIDO QUE KMS VA A TTENER QUE ESPERAR A QUE LA GPU ACABE DE RENDERIZAR UN FUTOGRAMA ANTES DE HACER LOS CAMBIOS QUE LE PEDIREMOS EN EL ATOMIC IOCTL: DEJAR COLOCADITA LA GPU_FENDE EN KMS_IN_FENDE_FD LO QUE HACE ES QUE, CUANDO HAGAMOS LA ATOMIC IOCTL, LE VAMOS A DECIR AL KERNEL QUE KMS TIENE QUE ESPERAR A QUE LA GPU ACABE EL FRAME QUE ESTÁ PINTANDO PARA PODER HACER LOS CAMBIOS SOLICITADOS EN EL ATOMIC IOCTL. 

-"Candamos" el buffer que hemos marcado a nivel EGL como siguiente front buffer, para que EGL no lo pueda pillar del buffer pool y elegirlo como back buffer para dibujar en él. A la vez, pillamos un hadle a ese buffer para poder solicitar el pageflip a él.

-(!!!)LO QUE VIENE AHORA LO VEO COMO ALGO OPCIONAL PERO PARECE NECESARIO: tenemos que bloquear el programa para no lanzar otro atomic ioctl sin que se complete el anterior. Para ello usamos eglClientWaitSync() bloqueando en kms_fence, que recuerda que es el fence que se importa desde kms_out_fence_fd, es decir, se importa desde el FD que es señalizado cuando se completan los cambios del atomic ioctl, es decir, en este caso cuando se completa el pageflip.
ES NECESARIO hacer esto porque si cometemos un atomic ioctl antes de haberse completado el anterior, obtenemos un error. Así que nos tenemos que asegurar de que no pasa, ya que la idea de esta implementación de SwapWindow() es permitir que se entre en el siguiente loop de juego tras solicitar ls cambios en atomic ioctl y sin esto no se bloquea el programa en ninguna parte, por lo que podríamos volver a SwapWindow() y a hacer otro atomic ioctl sin completarse el anterior.
NOTA: EN CASO DE QUERER un sistema de doble buffer, moveríamos esta espera al final de la función de WindowSwap(), y listo.

-Hacemos el atomic ioctl (atomic_commit()), que solicita al kernel en una sola llamada todos los camnbios que queramos. En este caso, el pageflip.
atomic commit() retorna inmediatamente: no se espera a que el kernel complete los cambios solicitados. PERO internamnente y fuera de nuestro control, los cambios pueden quedar bloqueados, y en este caso RECUERDA QUE AHÍ ARRIBA HEMOS DEJADO PUESTA LA GPU_FENCE EN "KMS_IN_FENCE_FD" DE MANERA QUE LOS CAMBIOS SOLICITADOS A KMS QUEDARÁN BLOQUEADOS HASTA QUE GPU_FENCE SE SEÑALICE, ES DECIR, HASTA QUE LA GPU ACABE DE RENDERIZAR EL FRAME.

-Liberamos el antiguo front buffer (NO el buffer que hemos solicitado que se convierta en nuevo front buffer, ojo!) para que vuelva al buffer pool y EGL lo pueda seleccionar de nuevo como backbuffer para dibujar en él. No hay fallo.
Así mismo, tomamos nota del buffer que hemos solicitado que sea el siguiente front buffer, porque la próxima vez que vengamos aquí, ese buffer será "el anterior front buffer" y tendremos que liberarlo como hemos hecho ahora con este.

-PARA LO QUE VIENE AHORA, TIENES QUE RECORDAR QUE CUANDO SE COMPLETEN LOS CAMBIOS SOLICITADOS EN EL ATOMIC IOCTL (en este caso, cuando el pageflip solicitado en el atomic ioctl se completa) EL KERNEL SEÑALIZARÁ EL FD DE SALIDA (KMS_OUT_FENCE_FD). Así que nosotros importamos kms_out_fence_fd a kms_fence. Y usamos kms_fence para decirle a la GPU mediante eglWaitSync(): vale, COMO EL JUEGO VA A ENTRAR EN OTRO LOOP, puedes CONSTRUIR el cmdstream del siguiente fotograma, PERO NO PUEDES EJECUTARLO HASTA QUE SE SEÑALICE EL KMS_FENCE, COSA QUE OCURRE CUANDO SE COMPLETEN LOS CAMBIOS SOLICITADOS EN EL ATOMIC IOCTL, es decir, el pageflip.


...Y VOLVEMOS AL LOOP DEL JUEGO. Sólo hemos bloqueado el programa en eglClientSyncWait() en caso de ser necesario, para no solicitar un atomit ioctl sin haber completado el anterior. Eso sí, hemos dado órdenes para que KMS y la GPU se esperen mutuamente!!!
