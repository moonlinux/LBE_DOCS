NOTAS PREVIAS
==============

En GNU/LInux en general, la arquitectura ARM de 64 bits se llama aarch64, con doble a. Sin embargo, en Debian se suele llamar arm64: así se refleja en el parámetro de
arquitectura objetivo que se le pasa a debootstrap, por ejemplo. Sin embargo, el ejecutable de qemu-static lleva el subfijo aarch64, porque no es algo propio de Debian.

PARTE 1: EL KERNEL AARCH64
=========================

Seguimos estos dos tutoriales:
http://www.tal.org/tutorials/raspberry-pi3-build-64-bit-kernel
http://www.tal.org/tutorials/booting-64-bit-kernel-raspberry-pi-3
Al final el kernel, los módulos, los dtb y demás quedan en kernel-out, como en el tutorial.

Si te da error al compilar el gcc, modifica gcc/graphite.h y ponle includes para isl/id.h y isl/space.h

Antes de empezar, siempre ponemos el crosscompilador de 64bits en el path:
export PATH=$PATH:/opt/aarch64/bin/

Cosas que hacemos distintas para instalar el kernel, módulos y dtbs:
-Para empezar, nosotros usamos el branch realtime del kernel, que clonamos con:
	git clone --depth 1 https://github.com/raspberrypi/linux.git -b rpi-4.14.y-rt
	(Puede que la versión sea más actual, busca el branch que lleve lo de -rt en el repo del kernel para la Raspberry, y ahí ves qué versión es ahora).
-Configuramos el kernel con:
make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig
Ajustes al kernel:
-Asegúrate de que el scheduler está a 1000HZ y que estás en FULL PREEMPTIBLE KERNEL, si estás en RT. Si no, a 300Hz y la máxima preemtion que puedas.
-Quita todo en kernel hacking (debugeo.. todo!). Quita dentro del KERNEL HACKING, en Compile-time checks and compiler options, "Compile the kernel with debug info"
Además deshabilita a mano en .config: CONFIG_FRAME_POINTER (ya que es activado por la opción ARM64, que es inevitable)
-En KERNEL FEATURES, deshabilita "Speculative Store Bypass Disable"
-En ENABLE THE BLOCK LAYER, pon el I/O Scheduler a BFQ por defecto y quita los demás
-En CPU POWER MANAGEMENT, deja el governor performance solamente y ponlo por defecto.

-Instalamos los módulos del kernel así:
sudo make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/media/manuel/CUSTOM_ROOT1 modules_install
(kernel_out es nuestro directorio de salida del kernel, los módulos, los dtbs y tal. Así va en esos tutoriales que usamos: mandando los resultados a un directorio a parte).

-Instalamos el kernel con:
sudo cp ../kernel-out/arch/arm64/boot/Image /media/manuel/CUSTOM_BOOT/kernel8.img

-Nosotros no instalamos los módulos del kernel hasta el final, después de instalar el rootfs (que es la segunda parte de este documento
que estás leyendo). De momento instala el kernel (kernel8.img) y los dtb, y los overlays.
Los DTBs están en arch/arm64/boot/dts/broadcom/*.dtb y los tienes que pasar al directorio raiz de la partición de boot (FAT32) de la SD.
Los overlays están en arch/arm64/boot/dts/overlays/*.dtb* y los tienes que pasar a overlays, un directorio que cuelga directamente del raiz de la partición de boot (FAT32) de la SD.
(Vamos, como en Raspbian más o menos).
cp ../kernel-out/arch/arm64/boot/dts/broadcom/*.dtb /media/manuel/CUSTOM_BOOT/
cp ../kernel-out/arch/arm64/boot/dts/overlays/* /media/manuel/CUSTOM_BOOT/overlays/

-En config.txt nosotros ponemos (a consecuencia de cómo tenemos las cosas instaladas):
device_tree=bcm2710-rpi-3-b-plus.dtb
overlay_prefix=overlays/
kernel=kernel8.img
arm_control=0x200

PARTE 2: EL ROOTFS
==================

Seguimos el tutorial de:
https://www.debian.org/releases/stable/arm64/apds03.html.en#idm3828

Lo primero formateamos la partición EXT4:
sudo mkfs.ext4 /dev/sdb2
Lo montamos como /mnt/LINUX
sudo mount /dev/sdb2 /mnt/LINUX

La línea para hacer el debootstrap a un directorio llamado arm64 es:
sudo debootstrap --foreign --arch arm64 stretch  /mnt/LINUX http://ftp.es.debian.org/debian

Ahora copiamos el quemu-static al nuevo sistema:
sudo cp /usr/bin/qemu-aarch64-static /mnt/LINUX/usr/bin/

Ahora chrooteamos al nuevo sistema:
LANG=C.UTF-8 sudo chroot /mnt/LINUX qemu-aarch64-static /bin/bash

Exportamos el modelo de terminal del host:
export TERM=xterm-color

Y ahora empezamos con el 2nd stage del nuevo sistema! (Recuerda que para tener debootstrap/debootstrap has tenido que pasar la opción "--foreing" ahí arriba,
cuando ejecutaste debootstrap en el host al principio para empezar):
/debootstrap/debootstrap --second-stage

Aprovecha para:
-Instalar el VIM, sudo, net-tools, sshd... (sí, ¡funciona con la red del host!):
apt install vim sudo net-tools alsa-utils 
-Para que sudo no de el error (unable to resolve hos), en /etc/hosts, añade la línea:
127.0.1.1    raspberrypi
-Cambiar el password de root  mientras estás chrooteado
-Ajustar el hostname, en /etc/hostname.
-Arreglar el nombre del interface de red, que aparece como enx..., para que aparezca como eth0:
Editar /lib/udev/rules.d/73-usb-net-by-mac.rules y dejar así la línea de IMPORT, para que el interface ethernet se llame eth0 y no un churro basado en la MAC address:
IMPORT{builtin}="net_id", NAME="eth0"
Y para que futuras actualizaciones no nos jodan el arreglo, haz:
cp /lib/udev/rules.d/73-usb-net-by-mac.rules /etc/udev/rules.d/

-Instala bash-completion si quieres que funcione autocompletar cuando usas sudo:
sudo apt-get install bash-completion
-Instala psmisc para tener killall:
sudo apt-get install psmisc

Si te dejas algo que no se pueda hacer en la máquina objetivo, puedes volver a chrootearte en la partición EXT4 de la SD después de haber transferido el rootfs,
y lo puedes hacer tantas veces como sea necesario, pero pasándole a chroot la ruta del raiz del EXT4 de la SD:
LANG=C.UTF-8 sudo chroot /mnt/LINUX qemu-aarch64-static /bin/bash

¡¡¡Sólo si hemos hecho el rootfs en un disco y lo transferimos a otro!!!
Transferimos el rootfs desde el disco duro del host a la partición EXT4 de la tarjeta con:
sudo rsync -avP --numeric-ids debian_arm64/ /mnt/LINUX/

Ahora instalamos los módulos del kernel:
sudo make O=../kernel-out/ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/mnt/LINUX/ modules_install

OJO A ESTO QUE SIGUE: SI NO VES NADA EN LA PANTALLA HASTA EL LOGIN, NO ES QUE TE FALTE NADA EN /dev. SI TIENES console=tty1 EN CMDLINE.TXT SE TIENE QUE
VER. EL PROBLEMA ES QUE SYSTEMD LIMPIA LA CONSOLA TAN RÁPIDO ANTES DEL LOGIN, QUE PARECE QUE NO SALE NADA EN PANTALLA PERO ES MENTIRA.
¡¡NO NECESITAS FICHEROS PERMANENTES EN /dev PARA VER LOS MENSAJES DEL KERNEL Y DE SYSTEMD EN EL INICIO!!! NO TE RAYES. ¡¡¡NO NECESITAS NINGÚN FICHERO
PERMANENTE EN /dev, CON LOS QUE CREA UDEV EN EL ARRANQUE ES SUFICIENTE!!! (QUE SON INVISIBLES SI HACES UN CHROOT AL ROOTFS EN VEZ DE ARRANCAR 
EN ÉL DE VERDAD) 
Ahora hacemos que systemd deje de borrarnos la consola en el incio, o no veremos nada del arranque (ni del kernel ni de los procesos que va levantando systemd):
mkdir /etc/systemd/system/getty@.service.d
cat >/etc/systemd/system/getty@.service.d/noclear.conf <<EOF
[Service]
TTYVTDisallocate=no
EOF

PARTE 3: FINETUNING THE SYSTEM
=============================

Una vez que hemos arrancado nativamente, tenemos mucho que hacer.

-Crear el usuario pi:
sudo adduser pi
sudo adduser pi sudo
sudo adduser pi audio
sudo adduser pi video
(Esto último es importante, porque has estado dando vueltas y el kernel sí reconocía el audio interno y la hifiberry (cat /proc/asound/cards)
pero aplay -L no listaba los dispositivos...¡porque no estabas en el grupo audio!)
-Si usas la hifiberry, acuérdate que en config.txt tienes que tener para que funcione:
dtoverlay=hifiberry-dacplus
Y la línea del audio interno comentada, para que el kernel sólo cargue la hifiberry:
#dtparam=audio=on
Y además, para evital problemas de ordering (o sea, que a veces la hifiberry es la 0 y por tanto es usada por defecto, pero otras veces la vc4hdmi es la 0 y es usada por defecto) necesitas unas cosas en /etc/asound.conf, que vamos a ver ahora mismo.
Para empezar, entra en alsamixer y no te sale el mezclador de la hifiberry, dale a F6 para ver si ALSA la ve al menos. (Este paso es opcional).
Ahora, averiguamos el NOMBRE de la tarjeta con aplay -l. Nos interesa lo que pone justo después de CARD=, NO lo que pone debajo ni nada de eso, sino lo que pone
justo a continuación del =. ESE es el nombre de las tarjetas. Nos interesa la que se llama "sndrpihifiberry", así que creamos /etc/asound.conf y lo dejamos así:

pcm.!default {
    type hw
    card sndrpihifiberry
}

ctl.!default {
    type hw           
    card sndrpihifiberry
}

Pues con esto, ya da igual qué tarjeta sea la 0, porque seleccionamos la tarjeta ALSA por defecto a través de su nombre, no por su número.
La mejor información sobre esto está en la wiki de arch: https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture#Select_the_default_PCM_via_environment_variable

-Crear el /usr/bin/netup con:
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo systemctl start dropbear
(OJO: dropbear ya no arranca a mano con '/etc/init.d/dropbear start')

-Instalar SSH y luego quitarlo, en dos pasos, uno en chroot y otro en nativo: Esto además instala fuentes, setup de la consola y todo eso, que nos va a hacer falta:
apt install sshd (en entorno chroot. No podrá configurar, lo hacemos en nativo con dpkg --configure -a)
apt-get purge ssh-server (en nativo)

-Instalar dropbear, generar sus claves y quitarlo del arranque sin maskearlo, porque si no luego no arranca desde mi script netup:
apt-get install dropbear
dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
sudo systemctl disable dropbear
(CUIDADO QUE SIN LAS CLAVES NO FUNCIONA!!!)

-Reconfiguramos la consola, el teclado y los locales:
sudo apt-get install locales console-setup keyboard-configuration
sudo dpkg-reconfigure console-setup
sudo dpkg-reconfigure keyboard-configuration
sudo dpkg-reconfigure locales
(generamos sólo en_US.UTF-8)
Trase reiniciar, ya tendría que ir la Ñ, los acentos y todo eso.

-Vamos quitando los servicios con:
sudo systemctl mask <sevcio> 
-Al final, de acuerdo con systemd-analyze blame, sólo quedan iniciados estos:

-Para que funcione el teclado, ratón y joystick con las SDL2, creamos /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Y reiniciamos.

-Para quitar el error: "brcmfmac: brcmf_sdio_htclk: HT Avail timeout (1000000): clkctl 0x50"
Puedes instalar el firmware de la wifi, o simplemente deshabilitarla poniendo en config.txt:
dtoverlay=pi3-disable-wifi

-Para ocultar los mensajes de systemd en el inicio, pon en cmdline.txt:
systemd.show_status=false

-TENEMOS QUE QUITAR LOS RLIMITS, o los emuladores se empezarán a quejar al llegar al 80% de uso de la CPU!
Para ello, editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:

@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20

De este modo, no hay límites para el usuario Pi ni para nadie del grupo audio, como jackd.
Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

-El guardado y restauración de los valores de alsamixer falla a veces. Tienes dos opciones:
	-La más sencilla:
		El problema es que no se cumple la condición de que exista "/dev/snd/control*" cuando se intenta cargar alsa-restore.service
		Si editamos completamente el unit del servicio alsa-restore.service ("sudo systemctl edit --full alsa-restore.service"), vemos que tiene la condición:
		ConditionPathExistsGlob=/dev/snd/control*
		...que es la que está fallando.
		Pues bien: vamos a quitar esa condición. Para ello, editamos un "override" del unit, no el unit en sí (ya que esto se perdería al actualizar el sistema...).
		Lo editamos con:
		sudo systemctl edit alsa-restore.service
		Y simplemente añadimos esa condition pero "en blanco":
		
		[Unit]
		ConditionPathExistsGlob=
		
		Salvamos, reiniciamos, y alsamixer debería restaurar los niveles sin problemas. Comprueba que "systemctl status alsa-restore.service" se ha iniciado correctamente ahora.
	-La más complicada y poco recomendada: 
		Deshabilita el servicio que lo lleva, y pon en .profile:
		sudo alsactl restore 0 --file /etc/asound.state
		Esto restaura los valores de alsamixer para la primera tarjeta. Podemos generar estos valores una vez tengamos nuestra configuración idonea guardándola con:
		alsactl store --file /etc/asound.state
		
-Al final, sólo necesitas estos servicios de los que salen con systemd-analyze blame:
pi@raspberrypi:~$ sudo systemd-analyze blame
           542ms dev-mmcblk0p2.device
          1.011s alsa-restore.service
           382ms keyboard-setup.service
           266ms systemd-udevd.service
           238ms systemd-remount-fs.service
           128ms fake-hwclock.service
           124ms systemd-udev-trigger.service
            54ms console-setup.service
            28ms systemd-modules-load.service
            24ms systemd-user-sessions.service
            15ms boot.mount
            10ms kmod-static-nodes.service
Recuerda mirar las mierdas que lanza systemd en el arranque antes de ocultarlo, y mira los targets con
sudo systemctl | grep <loquesea>
Luego los vas quitando, al igual que los services, con systemctl mask <monbre service o target>
Si metes la pata y el sistema no arranca más, elimina cosas de /etc/systemd/system, que es donde pone los links a /dev/null correspondientes a los services o targets que hayas eliminado
sin deber hacerlo...

INSTALAR MESA
==============

Los CFLAGS van a ser: 
-march=armv8-a+crc -mtune=cortex-a53

Empezamos con DRM:
git clone --depth 1 git://anongit.freedesktop.org/mesa/dr
sudo apt-get install xutils-dev libtool make automake pkg-config gcc g++ --no-install-recommends
./autogen.sh
Editamos configure y donde pone O2 ponemos:
-O3 -march=armv8-a+crc -mtune=cortex-a53
Configuramos y compilamos:
./configure --prefix=/usr --disable-vmwgfx --disable-radeon --disable-nouveau --disable-freedreno --disable-amdgpu

Ahora vamos a por MESA. Instalamos estos paquetes previos:
sudo apt-get install --no-install-recommends \
    flex bison python-mako \
    libxcb-dri3-dev libxcb-dri2-0-dev \
    libxcb-glx0-dev libx11-xcb-dev \
    libxcb-present-dev libxcb-sync-dev \
    libxshmfence-dev \
    libxdamage-dev libxext-dev libxfixes-dev \
    x11proto-dri2-dev x11proto-dri3-dev \
    x11proto-present-dev x11proto-gl-dev \
    libexpat1-dev libudev-dev gettext \
    ca-certificates \
    zlib1g-dev

Bajamos los últimos estables de:
https://mesa.freedesktop.org/archive/
configuramos con:
./autogen.sh
CFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53 -flto" CXXFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53 -flto" LDFLAGS="-flto" AR="gcc-ar" NM="gcc-nm" RANLIB="gcc-ranlib"  ./configure --prefix=/usr --libdir=/usr/lib --with-gallium-drivers=vc4 --with-dri-drivers= --with-egl-platforms=drm --disable-glx

(lo de AR, NM y RANLIB es para que funcione el LTO, que falla si no se lo pasas, como al compilar el SCUMMVM.

COPIAR ARCHIVOS DESDE UN SISTEMA ANTIGUO
=========================================

Lo puedes hacer con rsync -av <origen> <destino>
Ambos sistemos deben tener instalado rsync, y se puede usar por red como scp.

INSTALAR SDL2
=============

Lo primero es instalar estos:
sudo apt-get install libudev-dev libasound2-dev libvorbis-dev libpng-dev libjpeg-dev libfreetype6-dev --no-install-recommends

Si queremos que el SN30 de 8Bitdo se detecte como un gamepad (importante en SDLPop!), tenemos que añadir en src/joystick/SDL_gamecontrollerdb.h, en la parte de #if defined(__LINUX__):
"03000000c82d00000031000011010000,8Bitdo Receiver,a:b1,b:b0,back:b10,leftshoulder:b6,leftx:a0,lefty:a1,rightshoulder:b7,start:b11,x:b4,y:b3,",

O bien:
"03000000c82d00000031000011010000,8Bitdo Receiver,a:b1,b:b0,x:b4,y:b3,back:b10,start:b11,leftshoulder:b6,rightshoulder:b7,dpup:-a1,dpdown:+a1,dpleft:-a0,dpright:+a0"

Se configura con:
CFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53" CXXFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53" ./configure --prefix=/usr --enable-video-kmsdrm --disable-video-x11 --disable-video-mir --disable-dbus --disable-diskaudio --disable-oss --disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --disable-video-opengl --enable-libudev --disable-dbus --disable-ime --disable-video-vulkan

Compilar e instalar.

Para SDL2_Mixer:
CFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53" CXXFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53" ./configure --prefix=/usr --disable-music-midi-timidity --disable-music-midi-fluidsynth

Para SDL2_Image o SDL2_ttf:
CFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53" CXXFLAGS="-O3 -march=armv8-a+crc -mtune=cortex-a53" ./configure --prefix=/usr --without-x

INSTALAR RETROARCH
===================

Se configura con:
./configure --disable-ibxm --disable-vg --disable-x11  --disable-wayland --disable-sdl2 --disable-al --enable-neon --enable-floathard --disable-cheevos --disable-ffmpeg --disable-networking --disable-libretrodb --disable-materialui --disable-xmb --enable-udev --disable-sdl --disable-pulse --disable-oss --disable-freetype --disable-7zip --disable-libxml2 --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga  --enable-opengl --enable-opengles --disable-flac
(No le pases --enable-neon ni --enable-floathard, o fallará el configure porque dlopen() no va bien)

Ponemos en config.mk, en CFLAGS y CXXFLAGS:
 -march=armv8-a+crc -mtune=cortex-a53

Compilar y listo.
