******Sistema mínimo como root********************************************************************************************

Fuentes:
-Preguntar a clever en el canal #raspberrypi
-Tienes el script mínimo de arranque, que puedes pasarle al kernel como init, en el mismo directorio que este documento, con
el nombre "minimal".

***************
*NOTAS PREVIAS*
***************

--Lo más importante que debes saber es que: lo importante de un nodo en /dev no es un nombre, sino su TIPO y sus MAJOR y MINOR numbers.
Los puedes ver en un sistema "normal" con ls -l /dev/loquesea. Por ejemplo, con "ls -l /dev/tty" vemos:
crw-rw-rw- 1 root tty 5, 0 nov 16 03:54 /dev/tty
De donde deducimos que tenemos que creat /dev/tty como un nodo de tipo CARACTER (de ahí la "c") con major 5 y minor 0.
ESE ES EL MODO EN QUE EL KERNEL SABER CÓMO USARLO, SU NOMBRE ES LO DE MENOS.
Entonces, ese nodo se crearía a mano con:
mknod -m 666 /dev/tty c 5 0
Y si miramos tty1 con "ls -l /dev/tty1", vemos:
crw--w---- 1 root tty 4, 1 nov 15 16:23 /dev/tty1
Así que ese nodo se crearía a mano con:
mknod -m 660 /dev/tty c 4 1
LA COSA es que, si necesitamos crear nodos a mano, los miramos con ls -l en un sistema funcional, y deducimos cómo crearlos
a mano nosotros con mknod.
Los nodos tipo bloque, como los discos, se hacen pasándole a mknod una "b" en vez de una "c".

--UDEV se encarga de cargar los módulos para el hardware que tengamos conectado, PERO no crea nodos en /dev a no ser que
tenga las rules necesarias, que creo que se las pasa systemd. Vamos, que no crea nodos para el hardware cuyos módulos carga,
por eso los creamos nosotros a mano en el script de inicio, como vas a ver.
Los nodos del hardware que está built-in en el kernel sí que los crea el kernel, pero para ello tiene que tener la funcionalidad
CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y.

--Como montamos tmpfs en /dev, los módulos que se crean en cada sesión son creados en RAM, así que se pierden en cada reinicio.
Supongo que es posible tener nodos estáticos, pero ni idea de momento.

--TIENES QUE SABER ENTENDER LA LÍNEA con la que se lanza el programa único que vas a correr en un sistema mínimo.
Por ejemplo, para lanzar sh yo uso:
exec setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'
¿Y por qué no hago simplemente /bin/sh? Porque entonces no estaría corriendo en una TTY, lo podrías ver con el comando "tty".

Bueno, pues lo que hacemos en la línea, consta de dos stages:
STAGE 1:
	-EXEC lanza una tarea que va a tener el mismo PID que tiene la tarea llamante. Y la tarea llamante muere, o sea que
	 en cuanto a su PID es como se clona en la tarea lanzada por EXEC. La nueva tarea nunca retorna a la llamante, claro.
	 Esto de que la nueva tarea tenga el mismo PID que la llamante es importante porque el proceso init es el que tiene PID1,
	 y si muere init, el kernel da un kernel panic.
	-SETSID (set session id) le dice a una tarea que le pasamos como parámetro que se ejecute en una nueva sesión.
	 Esto nos interesa porque, si estuviese en la misma sesión, al morir el proceso padre por el EXEC, el hijo muere también.

	 O SEA, este nuevo proceso corre en una nueva sesión, pero con el mismo PID, el PID 1, que no podemos dejar morir
	 porque el kernel paniquea. Esto es lo que conseguimos con un SETSID dentro de un EXEC.
     1st stage purely does setsid on a 2nd stage script
STAGE 2:
	-EXEC lanza sh redireccionando toda su entrada y salida a la tty1, y se hace con EXEC para que sh tenga el PID 1.

--Cuando nos dé un error a la salida, al intentar montar / como read-only ("target / is busy" o algo así) podemos ver qué
fds a ficheros de / tenemos abiertos haciendo:
ls -l /proc/*/fd/*
La mayoría de lo que verás ahí son character devices, que no tienen nada que ver. Ahí puedes ver si están abiertos en modo
lectura, escritura, ejecución... Si no pone "w" en la cadena del modo de apertura, no hay problema.
ls -lL /proc/*/fd/*
Ahí, lo que tenga permisos que empiecen por c (como crw---------) es un character device,y lo que no, pues es un fichero.
Si al hacer "ls -lL" ves ficheros que tienen "w" en los permisos, no pasa nada, porque son eso, los permisos, no el modo
en el que está abierto.
El verdadero problema es que sea un fichero y además esté abierto en modo escritura.
DE TODOS MODOS, tal como está el sistema, el error "target / busy" lo da cuando has editado el fichero que contiene
el script de inicio, nada más. Así que edítalo desde fuera y ya, no desde el propio sistema. Ni idea de por qué pasa,
NO ES IMPORTANTE.

--Cuando en un programa encontremos que hacer un open() a /dev/tty devuelve -1 (es decir, al abrir el FD de la tty en uso)
y al mirar el ERRNO nos diga "can't open /dev/tty, no such device or address",
o lo que es lo mismo, cuando nos diga lo de "no such device or address" al hacer un echo hola > /dev/tty,
significa que SÍ TENEMOS el nodo /dev/tty, pero que no hay una TTY activaa (tty1, tty2, etc)
por lo que /dev/tty digamos que no apunta a ninguna parte (si la TTY activa es tty1, /dev/tty apunta a /dev/tty1, etc).
Cuando digo que una TTY es la TTY activa, es que se está viendo en pantalla (se cambiaría con CRTL+ALT+Fn, como sabes).
POR ESO tenemos que lanzar sh de manera que vaya a parar a una TTY (idealmente la tty1, que es la que está usando el kernel
para sacar sus mensajes, porque le hemos pasado console=tty1 en la línea de comandos del kernel, recuerda).
Puedes saber sobre qué TTY está corriendo sh o lo que sea simplemente con el comando "tty".
Y puedes saber sobre qué TTY corre cada programa en ejecución con ps -a.

--SOBRE LO ANTERIOR: ES POSILBE hacer un open() pasándole 0 en vez de /dev/tty a open(), si no has puesto en ningún TTY el SH
o el programa único que hayas lanzado en modo singleuser, y/o ni siquiera tienes un nodo /dev/tty que apunte
a una tty de verdad (/dev/tty1, etc..) creado. Y funciona.
E incluso se puede hacer el típico de KDSKBMODE a K_OFF para que no haya leak de teclas a la consola, o K_XLATE
para que vuelva a producir pulsaciones de teclas a la consola, etc.. con el fd que nos ha devuelto open() pasándole 0
en vez de una TTY.
Lo que pasa es que con SDL2 no hay forma de restaurar el teclado ("ioctl(0, KDSKBMODE, K_XLATE") al salir, porque el ioctl falla con
"bad file descriptor". (O sea, el ioctl devuelve -1, pero luego miramos errno con: 
printf("ERRORNO after ioctl was: %s\n", strerror(errno));
Y ahí vemos lo del "bad file descriptor".
(Sí funciona si lo restauramos nada más hacer el K_OFF para silenciarlo, pero si lo hacemos a la salida ya no funciona).
Esto pasa porque SDL2 hace en alguna parte un close() a un fd que vale 0, o vamos, que le llega 0 a un close.
Pero eso escapa completamente a nuestro control.

--Partimos de la premisa de que al kernel le pasamos console=tty1, claro. Si usamos otra tty, pues habrá que crear esa otra TTY
y mandar el sh a correr en esa otra tty.

*******************
*FIN NOTAS PREVIAS*
*******************

El siguiente script es el que puedes poner como script mínimo de arranque para levantar un sistema usable sin systemd
ni ningún otro proceso init.
Yo lo he puesto como /root/minimal, con permisos de ejecución, y luego en cmdline.txt he puesto
init=/root/minimal rw
Lo de rw es directamente para montar el root como read-write.

**************************************
* OTRAS NOTAS PARA AFINAR EL SISTEMA *
**************************************

TAMBIÉN puedes poner en cmdline.txt para que no salga el cursor parpadeante:
vt.global_cursor_default=0

******************
*COSAS PENDIENTES*
******************
TODO: 
-Tunear lo de la escritura en disco para que sea inmediata. Mira los parámetros: vm.dirty_background_ratio y
vm.dirty_ratio.

-En lugar de usar esa línea tan larga de setsid para lanzar sh en la tty1, usar cttyhack, que es parte de busybox.
Pero para eso habría que pasarse a busybox. Puede convenir porque además trae mdev en vez de udev, que creo que
crea los nodos sin depender de rules externas, así que nos ahorramos lo de hacerlo a mano. Investigarlo.

-Pasar de udev a mdev, que es lo que se usa en busybox. Para poner en marcha mdev una vez instalado, lee:
https://git.busybox.net/busybox/plain/docs/mdev.txt
La alternativa se supone que es tener un kernel con devtmpfs activado (opciones CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y
de la configuración del kernel), ya que un kernel con devtmpfs crea los nodos necesarios, pero lo malo es que eso no
carga los módulos necesarios.
Tampoco sé si mdev carga los módulos automáticamente, se supone que sí. Pero vamos, que con devtmpfs no es suficiente para
la carga de módulos.


******************
* NOTAS DE AYUDA *
******************
NOTA ADICIONAL POR SI TE HACE FALTA: Para ver la configuración del kernel en ejecución, tienes que insertar un módulo y luego
sacarla de un fichero, tal que así:
sudo modprobe configs
zcat /proc/config.gz > kernel_config

NOTA ADICIONAL POR SI TE HACE FALTA. Tira de google a partir de esto si quieres reiniciar con el saludo de los tres dedos.
You can change the behaviour of CTRL-ALT-DEL from rebooting: To disable CTRL-ALT-DEL from rebooting your computer (or to have it do something different), you can edit the /etc/inittab file

NOTA ADICIONAL POR SI TE HACE FALTA.
Para loguearte como usuario, se podría tirar de agetty:
getty -n -l /bin/sh 9600 tty1
