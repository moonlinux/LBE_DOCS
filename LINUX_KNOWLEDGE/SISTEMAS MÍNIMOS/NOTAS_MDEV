Fuentes:

MANUAL DE BUILDROOT, DONDE SE EXPLICA QUÉ ES MDEV, DEVTMPFS... LEER LO PRIMERO (buscar MDEV):
https://buildroot.org/downloads/manual/manual.html

GUÍA DE MIGRACIÓN DE UDEV A MDEV: 					https://wiki.gentoo.org/wiki/Mdev
OTRAS NOTAS MUY BUENAS SOBRE CÓMO FUNCIONA MDEV: 	http://lists.busybox.net/pipermail/busybox/2015-August/083255.html

CONCEPTOS BÁSICOS
=================

-DEVTMPFS: El sistema de archivos virtual donde el kernel hace aparecer y desaparecer los nodos de dispositivo cuando los conectamos o desconectamos.
           RECUERDA: El kernel hace esto por sí mismo, NO hace falta MDEV para hacer aparecer o desaparecer nodos en /dev.
           Para que el kernel se encargue de crear los nodos, tiene que tener la opción CONFIG_DEVTMPFS=y.
           Y para que el kernel automonte el DEVTMPS en /dev (estando así /dev en RAM, no en el disco, y creando allí el kernel los nodos),
           tiene que tener la opción CONFIG_DEVTMPFS_MOUNT=y.
           En la mayoría de los kernels, ambas vienen por defecto activadas, así que no hace falta que hagas "mount -t devtmpfs none /dev"
           en el script mínimo de inicio, ya viene montado DEVTMPFS en /dev y todo.

-MDEV: Es una utilidad de espacio de usuario que es parte de BUSYBOX, y que el kernel llama cuando se conecta o desconecta un dispositivo.
       ¿Y para qué la llama si los nodos ya los crea el kernel en /dev usando DEVTMPFS? Pues porque MDEV nos permite establecer permisos o titularidad
       de los nodos de dispositivo, nos permite llamar a un script cuando se conecta o desconecta tal o cual dispositivo, etc...
       Todo ello, según lo que especifiquemos en /etc/mdev.conf

LA SECUENCIA DE ARRANQUE CON MDEV
=================================

TIENES UNA SECUENCIA TÍPICA DE ARRANQUE CON MDEV EN EL SCRIPT "minimal2".

LO PRIMERO, sería tener mdev disponible como comando desde el principio del arranque, para ello al menos una vez tenemos que hacer:
ln -s /bin/busybox /dev/mdev

TAMBIÉN ten en cuenta que el kernel automonta DEVTMPFS en /dev, siempre y cuando tenga la opción CONFIG_DEVTMPFS_MOUNT=y, que es lo más normal,
así que NORMALMENTE no necesitas montar el DEVTMPFS manualmente en tu custom init porque ya lo hace el kernel (esto es algo relativamente moderno,
asú que puede que te encuentres instrucciones de cuando no era así y había que hacer "mount -t devtmpfs none /dev".
TAMBIÉN, si arrancas con un initramfs o un initrd, tienes que hacer LO PRIMERO DEL INIT SCRIPT el montaje de devtmpfs
con "mount -t devtmpfs none /dev", y luego tendrás que hacer "busybox mdev -s" para recrear los nodos de /dev ya que al montarlo a mano estará vacío.
PERO eso es sólo si alguna vez usas un initramfs o un initrd, NORMALMENTE el kernel automonta DEVTMPS en /dev y ya está.

A PARTE, tienes que tener esto en /etc/mdev.conf si quieres que los módulos se carguen/descarguen automáticamente cuando conectes/desconectes
algo en caliente:

-$MODALIAS=.* root:root 660 @modprobe "$MODALIAS"
-$MODALIAS=.* root:root 660 $modprobe -r "$MODALIAS"

NOTA que la parte en la que dice "$MODALIAS=.*" es lo que se llama el REGEX (regular expression) que, si coincide con algún dispositivo,
se hace lo que le digamos que tenga que hacerse en esa línea.
La documentación de MDEV está en unos TXT que vienen con su código fuente:
git clone --depth 1 git://git.busybox.net/busybox
Y editamos docs/mdev.txt para ver la documentación y ejemplos.
Tienes un MONTÓN más de ejemplos (de hecho, un mdev.conf completo) aquí:
https://github.com/slashbeast/mdev-like-a-boss/blob/master/mdev.conf

NOTA que ambas líneas empiezan con un guión. Esto es para que mdev NO se detenga en la primera línea con la que haga un match con la REGEX/exp.regular
(que es .*, englobando así a TODOS los nombres de módulo de sysfs), sino que continúa leyendo las demás líneas y haciendo lo que se diga en ellas
si también hace match con la REGEX de cada una de ellas.

(¡¡¡OJO!!!)NOTA QUE PODRÍAMOS DEJAR SÓLO LA PRIMERA LÍNEA Y SIN GUIÓN, PARA NO DETECTAR DESCONEXIONES, SÓLO CONEXIONES,
Y ASÍ NO TENER SALTOS EN LA EMULACIÓN,
(pero claro, entonces tenemos que salir de RetroArch si queremos reconectar un mando, conectar otro nuevo, etc).

NOTA también que en una el comando modprobe se precede de '@' y en la otra se precede de '$'.
Pues la de '@' es para que el comando se ejecute cuando el evento de hotplug es de CONEXIÓN ($ACTION=add) y la de '$' para que el comando se ejecute
cuando el evento de hotplug es de DESCONEXIÓN ($ACTION=remove).

NOTA que por raro que parezca, en la regla de descarga de módulo, también le damos el propietario y los permisos: sin eso, no funciona.

NOTA que hacen falta ambas líneas, no se puede poner el comando de carga y el de descarga en la misma, no funciona.

NOTA QUE SI ALGUNA VEZ QUISIERAS que se automonte algo al conectarlo, etc... ahí en vez de "modprobe" puedes llamar al script de cosecha propia que quieras.
Puedes hacer que ocurra lo que quieras poniéndolo ahí y si hay match del REGEX, se ejecutará.

root:root es la propiedad de los nodos creados, y 660 los permisos.
(Son los valores por defecto, los explicitamos sólo para dejarlo documentado)

Para que funcione la GPU, deberías tener los nodos del sistema gráfico. Son
/dev/dri/card0
/dev/dri/card1
/dev/dri/renderD128
..Y en el caso de la raspberry pi, los debería crear el módulo VC4 al cargarse.

(En caso de no crearse, VER NOTAS DEL FICHERO "CREACIÓN MANUAL DE NODOS")

PARA QUE FUNCIONE RETROARCH
===========================

En Devuan, la implementación de udev es eudev, y la implementación de libudev es libeudev. Eudev/libeudev que no dependen de systemd,
pero libeudev está muerta y por eso estamos aquí.
Nos vamos a referir genéricamente a udev/eudev como udev, y a libeudev/libudev como libudev.
Bueno: la cosa es que el backend UDEV de RetroArch (RA) usa libudev. Y LIBUDEV NECESITA EL SERVICIO UDEV CORRIENDO PARA FUNCIONAR.
Como no lo tenemos, el backend UDEV de RetroArch no funciona. Olvídate de permisos o propiedad de los nodos de /dev/input/event*, etc
El problema es simplemente que NO tenemos el servicio UDEV corriendo, aunque tengamos LIBUDEV instalada.
Así que tenemos dos alternativas para que RetroArch funcione sin el servidio UDEV:

-Usar el backend LINUXRAW, en lugar del backend UDEV.
Su principal desventaja frente a UDEV es que no soporta hot-plugging mientras RetroArch corre, hay que salirse de RA,
conectar los mandos que queramos usar y volver a entrar.
Para usarlo, tenemos que ponerlo en DOS SITIOS de retroarch.conf:

input_driver="linuxraw"
input_joypad_driver="linuxraw"

También recuerda que al pasar a usar LINUXRAW, tienes que reconfigurar los controles de la cruz del pad. Sólo los de la cruz,
los demás si los dejas como estaban en UDEV funcionan.
También recuerda que al pasar a usar LINUXRAW, las teclas de aceptar y cancelar en el teclado pasan a ser Z y X. Esto no se puede configurar,
están hardcodeadas. Pero vamos, RetroArch tiene una GUI muy orientada a mandos, así que no importa. 

-Usar libudev-zero, que es un drop-in replacement de UDEV que no necesita ningún servicio corriendo.
Puede ser necesario cuando volvamos a Wayland, ya que no sé si LINUXRAW funcionará allí.
Para ello:
	-Clonamos su repo: git clone --depth 1 https://github.com/illiliti/libudev-zero.git

	-Borramos a mano libudev (en Devuan es libeudev, un drop-in replacement de udev que no depende de systemd, pero los ficheros son los mismos):
	apt-get purge libeudev-dev
	rm /usr/lib/aarch64-linux-gnu/libudev*
	rm /usr/lib/aarch64-linux-gnu/pkgconfig/libudev.pc
	rm -R /usr/lib/udev
	(Lo borramos a mano porque borrarlo usando "apt-get purge" se lleva por delante componentes del sistema muy importantes como el propio apt!)

	NO OLVIDES, TRAS DESINSTALARLO, LIMPIAR LA CACHÉ DE LIBRERÍAS:
	rm /etc/ld.so.cache
	ldconfig

	-Compilamos e instalamos libudev-zero:
	CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" make -j4
	make install
	(OJO, como sabes, al no especificarle un PREFIX=... a "make install", se instalará en /usr/local, donde están todas mis librerías de
	 compilación propia, como SDL2, etc.. es lo normal).

	-RECOMPILAMOS RetroArch normalmente, que ahora debería detectar la librería libudev correspondiente a libudev-zero.
	ESTO ES MUY IMPORTANTE. SI PASAS DE USAR UDEV/EUDEV A USAR UDEV-ZERO, HAY QUE RECOMPILAR RETROARCH.

	-SI QUEREMOS TENER HOTPLUGGING como en el UDEV original (es decir: poder poner y quitar mandos mientras RetroArch está funcionando),
	tenemos que compilar el helper que trae libudev-zero, instalarlo en /usr/local/bin, y añadir unas líneas a /etc/mdev.conf.
	Se hace tal que así:
		cd contrib
		gcc helper.c -o udevzero-helper -march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer
		cp udevzero-helper /usr/local/bin
	
		Y ahora añadimos esto a nuestro /etc/mdev.conf (está sacado de contrib/mdev.conf, modificado para que encuentre el helper
		con el nombre que le hemos puesto nosotros cuando lo hemos compilado, que lo hemos llamado udevzero-helper como lo podíamos
		haber llamado pepito):
		SUBSYSTEM=input;.* root:input 660 */usr/local/bin/udevzero-helper
		
Por si quieres volver a EUDEV:

	-Para desinstalar libudev-zero sería:
	make uninstall

	-Para instalar de nuevo libeudev:
	apt-get install --reinstall libeudev1
	apt-get install --reinstall libeudev-dev
