#!/bin/sh

#################################################
# BLOQUE MDEV                                   #
#################################################

# ¡¡¡¡CUIDADO!!!! ANTES DE PODER USAR MDEV, DEBEMOS CREAR UN LINK SIMBÓLICO A BUSYBOX CON:
# "ln -s /bin/busybox /bin/mdev"

# Para que se creen y borren automáticamente los nodos en /dev al conectar y desconectar cosas,
# lo que se usa es DEVTMPFS, que es parte del kernel. O SEA, es el kernel el que crea y borra
# los nodos en /dev, NO hace falta MDEV para ello.
# Para que funcione DEVTMPFS, el kernel ha de tener las opciones CONFIG_DEVTMPFS=y, CONFIG_DEVTMPFS_MOUNT=y,
# cosa que es lo más común.

# MDEV lo llama el kernel cuando se conecta o desconecta algo, y usamos para dos cosas:
# Para cargar / descargar los módulos necesarios automáticamente, y para establecer los permisos
# y propiedad de los nodos de dispositivo en /dev automáctiacemte también.
# Estas dos cosas se las especificamos a MDEV teniendo en /etc/mdev.conf esta línea:
# MODALIAS=.* root:root 0660 @modprobe -b "$MODALIAS"

# Además, para que vayan gráficos y audio, es necesario tener sysfs y proc montados.
# En algunos kernels, como el de Devuan, ya viene montado /sys, así que la línea de montaje de /sys
# la tengo comentada por eso.
# mount -t sysfs none /sys
mount -t proc proc /proc

# Montamos /dev en tmpfs para que esté en RAM y no en disco.
# Esto implica que /dev queda vacío desde este momento, aunque el /dev original en disco tenga
# los nodos de dispositivo que habrá creado el kernel usando DEVTMPFS, pero ese /dev en disco
# ya no lo vamos a ver ni a usar, por eso luego le tenemos que pedir a mdev que nos recree los nodos.
mount -t tmpfs mdev /dev

# El sistema devpts (NO confundir con el gran DEVTMPFS, ¡ojo!) es otro sistema de archivos virtual
# que vive en /dev/pts y que contiene esclavos multiplexados de /dev/ptmx, siendo cada uno de esos
# esclavos la representación de un emulador de terminal (como xterm en X11,
# o un terminal de wayland, o un terminal de acceso por SSH. Como usamos SSH,
# pues tenemos que montar esto o nos dará un error "PTY allocation failed" al intentar entrar).
mkdir /dev/pts
mount devpts /dev/pts -t devpts

# Le decimos al kernel que llame a MDEV cuando haya un hotplug/unplug,
# MDEV lo usamos para cargar automáticamente los módulos correspondientes, para lo cual
# le tenemos que decir a MDEV que llame a modprobe, cosa que le decimos poniendo
# esta línea en /etc/mdev.conf
# MODALIAS=.* root:root 0660 @modprobe -b "$MODALIAS"
echo /bin/mdev > /proc/sys/kernel/hotplug

# Le decimos a mdev que escanee /sys y recree los nodos de dispositivos en /dev de lo que encuentre
# Sabemos que el principal encargado de crear los nodos en /dev es el kernel mediante DEVTMFS, NO MDEV,
# pero es que más arriba hemos montado /dev en TMPFS para que esté en RAM, así que /dev estará vacío
# si no le decimos a mdev que recree los nodos: el kernel los habrá creado antes, pero claro... en disco.
# Así que si no montásemos /dev en TMPFS, no haría falta pedirle a MDEV que recree los nodos en /dev ahora).
busybox mdev -s

# Cargamos los módulos del hardware que YA tenemos conectado.
# Cuando conectemos nuevo hardware, se encargará MDEV porque será llamado por el kernel en cada evento
# de conexión/desconexión, pero para el hardware que tenemos conectado al arrancar lo tenemos que
# hacer nosotros porque no hay tales eventos que desencadenen las llamadas a MDEV.
find /sys/devices -name modalias -type f -print0 | xargs -0 sort -u | xargs modprobe -ab 2>/dev/null

#################################################
# FIN BLOQUE MDEV                               #
#################################################

# Ponemos a punto el governor de cada core, ahora que ya tenemos el sysfs preparado
# y cargados los módulos que permiten controlar la frecuencia de la CPU de la Pi.
for numcore in 0 1 2 3
do
 echo performance > /sys/devices/system/cpu/cpu$numcore/cpufreq/scaling_governor
done

# Re-montamos el root como lectura/escritura.
# Añadimos la opción "sync" después de otra coma para que las escrituras sean inmediatas,
# lo que mejora mucho la predictibilidad del sistema al no haber escrituras retardadas.
mount -o remount,rw,sync,noatime,nodiratime /

# Montamos también la partición de BOOT
mount /dev/mmcblk0p10 /boot -o rw,sync,noatime,nodiratime

# Montamos /tmpfs y /var/log en RAM, para que no se escriban temporales ni logs
# en disco.
# OJO, no especificamos un tamaño, así que como mucho pueden ocupar el 50% de la RAM.
mount -t tmpfs tmpfs /tmp
mount -t tmpfs tmpfs /var/log

# MUY IMPORTANTE exportar $HOME o las configuraciones de los programas
# se empezarán a guardar en /. Así que esto hay que hacerlo SIEMPRE.
export HOME=/root

# Setupcon configura la fuente y el teclado de la consola,
# leyendo la configuración de /etc/default/console-setup y /etc/default/keyboard.
hostname minimal
setupcon

# Restablecemos la última fecha conocida de /etc/fake-hwclock.data, para que
# al menos no estemos en los 70s. Importante para qie GIT funcione.
fake-hwclock load >> /dev/null

# Antes de establecer el volúmen, tenemos que reproducir un audio aunque sea
# inexistente, o el controlador del volúmen por software (softvol) no estará
# disponible aún.
# Algunos dispositivos como el vc4hdmi no tienen control de volúmen por hw.
#aplay  /dev/zero -s 1 -q
#amixer set PCM 230 -q

# El lanzamiento del bash se hace mediante setsid y exec en dos stages:
# En el STAGE 1, setsid inicia una nueva sesión y manda un primer sh ahí,
# y en el STAGE 2 exec ejecuta otro sh con el mismo PID que el sh anterior,
# que tiene PID 1 (Siempre hay que tener un PID 1 o el kernel da un panic
# por matar el proceso init). La entrada y salida de este segundo sh
# es redireccionada a tty1.
# Se puede usar bash o bien sh. Si usamos bash, hay que pasarle el --login
# porque si no, no lee /etc/profile y nos faltan cosas en el $PATH.
setsid sh -c 'cd /root;exec bash --login </dev/tty1 >/dev/tty1 2>&1'

# En caso de querer un único programa corriendo:
# setsid sh -c 'exec /usr/local/bin/retroarch </dev/tty1 >/dev/tty1 2>&1'

# Salvamos la última fecha conocida, que va al fichero /etc/fake-hwclock.data
fake-hwclock save

# Matamos todos los procesos que se han lanzado desde este script,
# para que no haya nada accediendo a directorios que cuelguen del rootfs.
pkill -P 1

# Desmontamos todo lo que hemos montado.
# El desmontaje conlleva la sincronización de los discos.
umount /sys
umount /proc
umount /tmp
umount /var/log
umount /boot

# El desmontaje del rootfs de un kernel en ejecución no se supone que sea posible,
# así que lo re-montamos como sólo lectura y así el kernel puede seguir usándolo aunque
# ya no se pueda escribir en él.
# (Una alternativa sería hacer un swicth_root a un rootfs en initramfs).
# NOTA: El bucle de espera en realidad no debería ser necesario porque ahí arriba has matado
# todos los procesos lanzados por este script así que no debe haber nada accediendo a
# directorios que cuelguen de /, pero se deja a modo de documentación.
# IMPORTANTE: El re-montaje falla SIEMPRE si has editado este fichero mientras el
# sistema lo estaba usando. Para confirmar que sigue abierto usa "lsof|grep minimal".
busy=true
while $busy
do
  mount / -o remount,ro 2> /dev/null
  if [ $? -eq 0 ] # Si el último comando ejecutado tuvo éxito, $? es 0. 
  then
   busy=false
   echo Filesystem umount successfull.
  else
   echo -n '.'  # Escribimos algo para que se vea que el script sigue vivo.
   sleep 1      # Esperamos un segundo a reintentar.
  fi  
done

# Dependiendo de si quieres reiniciar o apagar al salir, usa una o la otra.
# Poweroff va con dos -f, sí, no es un error, es para que no contacte con el
# gestor de procesos, que no existe.
reboot -f
#poweroff -f -f
