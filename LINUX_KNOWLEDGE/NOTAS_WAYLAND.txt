INSTALAR WAYLAND
================

Lo primero: para correr COMPOSITORS BASADOS EN WLROOTS (DWL, TINYWL, SWAY, WAYBOX, CAGE) necesitas WAYLAND y WLROOTS, ya que la mayoría de los compositores se basan en WLROOTS.
A su vez, WLROOTS necesita WAYLAND-PROTOCOLS y LIBSEAT.
LUEGO A PARTE ESTÁ WESTON, QUE NO ESTÁ BASADO EN WLROOTS NI LO NECESITA.
***LIBSEAT ES NECESARIO PARA COMPOSITORES BASADOS EN WLROOTS Y AHORA TAMBIÉN PARA WESTON (ANTES NO HACÍA FALTA, PERO AHORA, WESTON NECESITA
O BIEN LIBSEAT O BIEN, SI USAS SYSTEMD, EL SERVICIO SYSTEMD-LOGIND ACTIVO: UNA DE LAS DOS COSAS).
***LIBSEAT SÓLO ES NECESARIO SI NO TENEMOS CORRIENDO EL SERVICIO "LOGIND" QUE EN SYSTEMD ES "systemd-logind"
   Y QUE EN OTROS INIT DISTINTOS DE SYSTEMD ES "elogind".
   LÓGICAMENTE, EN UN SISTEMA "MINIMAL" DE LOS MIOS, PARA USAR UN COMPOSITOR BASADO EN WLROOTS, LIBSEAT HACE FALTA PORQUE NO TIENES
   NINGÚN SERVICIO DE LOGIN CORRIENDO!

WLROOTS tiene un renderer Vulkan, que desde WESTON no puedes aprovechar por no basarse en WLROOTS.

PARTE 1: WAYLAND EN SÍ (libwayland)
-----------------------------------

Instalamos dependencias previas:
apt-get install libffi-dev --no-install-recommends

Bajamos la última release estable de:
https://gitlab.freedesktop.org/wayland/wayland/-/releases

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddtd_validation=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

PARTE 2: WAYLAND-PROTOCOLS
--------------------------
Bajamos la ultima release estable de:
https://gitlab.freedesktop.org/wayland/wayland-protocols/-/releases

Cofiguramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false ..

ninja -j4
sudo ninja install

PARTE 3: INSTALAR WLROOTS (NO NECESARIO PARA WESTON!!)
------------------------------------------------------
-Previamente necesitamos KMS/DRM funcionando. Así que deberías ser capaz de ejecutar los tests de SDL2 sobre KMSDRM.

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev hwdata --no-install-recommends
-Instalamos manualmente la dependencia LIBSEAT, que no está como paquete en DEBIAN 11. Para ello tenemos que instalarla desde backports.
--Instalamos el repositorio de backports, que son versiones del siguiente DEBIAN backporteados para el actual:
		echo "deb http://deb.debian.org/debian bullseye-backports main" | sudo tee /etc/apt/sources.list.d/bullseye-backports.list
		apt-get update
--Instalamos libseat-dev especificando que la instalamos desde backports:
		apt-get -t bullseye-backports install libseat-dev

-Instalamos otra dependencia previa: libinput desde su última versión estable, ya que Debian no tiene una versión
 suficientemente actual ni siquiera en backports.
---Instalamos dependencias previas de libinput: apt-get install libmtdev-dev libevdev-dev
---Nos bajamos los últimos sources estables de libinput de: https://gitlab.freedesktop.org/libinput/libinput/-/releases
---Configuramos libinput con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibwacom=false -Ddebug-gui=false -Dtests=false -Ddocumentation=false 

--Instalamos más dependencias previas:
apt-get install glslang-dev glslang-tools
--SÓLO SI VAMOS A USAR EL RENDERER VULKAN: Actualizamos nuestra versión de libvulkan y libvulkan-dev,
ya que WLROOTS necesita una reciente, para lo cual actualizamos a la version de backports:
		apt-get -t bullseye-backports install libvulkan1 --no-install-recommends
		apt-get -t bullseye-backports install libvulkan-dev --no-install-recommends (<---Este probablemente no se te actualize, don't worry.)

-Instalar WLROOTS en sí. Para ello:

--Bajamos los últimos sources de WLROOTS estables de aquí: https://gitlab.freedesktop.org/wlroots/wlroots/-/releases

--Configuramos, compilamos e instalamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=false -Dxwayland=disabled \
-Dbackends=drm,libinput -Drenderers=gles2 -Dxcb-errors=disabled ..

ninja -j4
sudo ninja install

RECUERDA que WLROORS soporta renderizado con Vulkan, por lo que los renderers basados en WLROOTS (como DWL, SWAY, WAYBOX...) pueden usarlo.
Para ello tendriamos que pasar a meson: -Drenderers=gles2,vulkan
Y lanzaríamos el compositor que queramos con:
WLR_RENDERER=vulkan <compositor>
(OJO!! WESTON NO USA WLROOTS!!)

=================================================================
PARTE 4: INSTALAR WESTON (EL COMPOSITOR DE REFERENCIA DE WAYLAND)
=================================================================

-Instalamos dependencias previas, libinput-dev:
sudo apt-get install libinput-dev --no-install-recommends

-Instalamos dependencias previas: libseat-dev
--Instalamos el repositorio de backports, que son versiones del siguiente DEBIAN backporteados para el actual:
		echo "deb http://deb.debian.org/debian bullseye-backports main" | sudo tee /etc/apt/sources.list.d/buster-backports.list
		apt-get update
--Instalamos libseat-dev especificando que la instalamos desde backports:
		apt-get -t bullseye-backports install libseat-dev

-Instalamos manualmente una dependencia previa, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas de CAIRO: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de: https://gitlab.freedesktop.org/cairo/cairo/-/releases
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dzlib=disabled -Dtests=disabled -Ddwrite=disabled ..

-Instalar WESTON en sí:
Bajamos los últimos sources estables de:
https://gitlab.freedesktop.org/wayland/weston/-/releases

Editamos desktop-shell/shell.c, vamos a la función set_fullscreen() y ahí...
(Queda pendiente hacer como que se clicka en la surface para que el pointer constraint en aplicaciones fullscreen se aplique inmediatamente,
ver issue: https://gitlab.freedesktop.org/wayland/weston/-/issues/667)

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dbackend-headless=false -Dbackend-rdp=false -Dscreenshare=false -Dremoting=false -Dpipewire=false \
-Dbackend-drm-screencast-vaapi=false -Dbackend-vnc=false -Dbackend-x11=false \
-Dxwayland=false -Dsystemd=false -Dpipewire=false -Dshell-ivi=false \
-Dcolor-management-lcms=false -Dcolor-management-lcms=false -Dtools=terminal -Dwcap-decode=false \
-Dtest-junit-xml=false -Dimage-webp=false -Ddoc=false -Dbackend-drm-screencast-vaapi=false -Ddemo-clients=false \
-Dwcap-decode=false ..

ninja -j4
sudo ninja install

// BLOQUE PARA USUARIOS NORMALES NO ROOT
Ahora hacemos setuid-root al ejecutable weston, creamos el grupo weston y añadimos al usuario al grupo weston:
sudo chmod 4755 /usr/local/bin/weston
sudo gropuadd weston
sudo usermod -a -G weston pi
// FIN BLOQUE PARA USUARIOS NORMALES NO ROOT

Ahora creamos ~/.config/weston.ini con este contenido:
(RECUERDA que weston.ini puede estar en cualquier ruta que exportes en $XDG_CONFIG_HOME)
(RECUERDA que puedes ver los modos de vídeo disponibles con: modetest |grep -50 modes
 PERO lo mejor es poner mode=current y así no hay cambio de modo.)
(RECUERDA que si, como en este ejemplo, tienes puesto el cursor-theme llamado adwaita, tienes que instalarlo con:
 apt-get install adwaita-icon-theme).

#
# Contenido de weston.ini
#

[core]
# El valor por defecto de "shell" es "desktop". Kiosk es un shell más ligero,
# que sólo es para que se ejecute un programa, en nuestro caso el foot.
shell=kiosk
idle-time=0

[shell]
locking=false
binding-modifier=alt
animation=zoom
startup-animation=fade
cursor-theme=adwaita
cursor-size=24
background-image=none
background-color=0xFF555555

[terminal]
font=monospace
font-size=18

[launcher]
icon=/usr/local/share/weston/terminal.png
#path=/usr/local/bin/weston-terminal --shell=/bin/bash
path=/usr/local/bin/foot

[input-method]
path=/usr/local/libexec/weston-keyboard

[output]
name=HDMI-A-1
mode=current

[keyboard]
keymap_layout=es
vt-switching=false

[autolaunch]
# Podríamos poner "watch" a "true" si usamos el shell "kiosk" en la sección [core],
# ya que así Weston termina al cerrar el foot (y se reinicia o se apaga el sistema).
path=/usr/local/bin/foot
watch=false

#
# Aquí acaba el contenido de weston.ini
#

// BLOQUE SÓLO PARA DEBIAN CON SYSTEMD, PARA LANZAR WESTON COMO SERVICIO

Creamos /etc/systemd/system/weston.service con el contenido:

#############

[Unit]
Description=weston - User service

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=%h
ExecStart=
ExecStart=-/usr/local/bin/weston
Restart=always

[Install]
WantedBy=graphical.target

#############
*NOTA: El WorkingDirectory puesto a "%h" significa usar nuestro $HOME, que sera /root si no eres otro usario. 
*NOTA: Si tuvieramos que añadir mas servicios, irian con:
[Install]
WantedBy=default.target
...en vez de graphical.target, porque lo que nos interesa es que esos servicios se lancen sea cual sea el target
que tengamos puesto como default, NO nos interesa que se lancen solo cuando el target puesto como default sea graphical.
El caso de un compositor wayland es especial, porque solo se tiene que lanzar cuando el target sea graphical).
*NOTA
-Podemos ver los targets activos con: systemctl list-units --type target
-Podemos ver los targets que hay en el sistema, aunque no esten activos, mirando en /lib/systemd/system

Establecemos graphical.target como target por defecto:
systemctl set-default graphical.target
Podemos comprobarlo con:
systemctl get-default
(Si alguna vez quisieramos volver a un modo de texto, estableceriamos el target multi-user como target por defecto:
systemctl set-default multi-user.target
Y NO HARIA FALTA VOLVER A DESACTIVAR EL SERVICIO WESTON, YA QUE NOS QUEDAMOS EN EL TARGET MULTI-USER Y DE ESE MODO
NO SE CARGA EL SERVICIO WESTON).

Ahora activamos el servicio WESTON con:
systemctl enable weston.service
(Recuerda que lo que hace esto es crear el symlink /etc/systemd/system/graphical.target.wants/weston.service apuntando
a /etc/systemd/system/weston.service, que es logico porque el target graphical.target necesita weston.target tal como hemos
especificado en la UNIT de weston). 

Desactivamos el autologin en TTY con:
systemctl disable getty@tty1

// FIN BLOQUE SÓLO PARA DEBIAN CON SYSTEMD

Podemos lanzar WESTON con:
weston -f '' -l ''
(Lo de -f '' -l '' es para que no mande logs a la consola ni a ningún lado).
(Se sale con Ctrl+Alt+Backspace)

SI TE DA EL ERROR: "Error: Failed to connect to parent Wayland compositor: No such file or directory"
...Es porque estás exportando WAYLAND_DISPLAY=... (posiblemente en bashrc, para debugear programas por ssh) y Weston interpreta
que ya hay un servidor Wayland corriendo, y peta. No lo exportes y funcionará.

############################################################
# SI NECESITAS AYUDA CON WAYLAND:                          #
# -https://gitlab.freedesktop.org/wayland/weston/-/issues  #
# -DRM/KMS: Canal #dri-devel en irc.oftc.net               #
# -WESTON:  Canal #wayland en irc.oftc.net                 #
# -WLROOTS: Canal #sway-devel en irc.libera.chat		   #
############################################################

Investigar si se puede hacer simplemente:
sudo -E weston -t /dev/tty7 -u pi

QUITAR ERRORES DE WESTON
========================

--Para quitar los errores:
	could not load cursor 'dnd-move'
	could not load cursor 'dnd-copy'

	Instalamos:
	apt-get adwaita-icon-theme --no-install-recommends

	Y añadimos en .config/weston.ini, en la sección [shell]:

	[shell]
	cursor-theme=adwaita
(Se podría usar otro tema más ligero, pero no lo conozco).

AÑADIR ATAJOS DE TECLADO A WESTON
=================================

TIENES DOS OPCIONES:

1) RECOMENDADO: Añadir los atajos a mano:
Para ello, editamos desktop-shell/shell.c y:

-Añadimos #include <fcntl.h> a los includes del principio.
-Añadimos estas funciones (justo encima de la función shell_add_bindings(), si quieres):

/* Process executed via keybind failed. status is the exit value. */
static void 
process_cleanup(struct weston_process *process, int status)
{
        free(process);
}

/**
 * Much like system(3) but doesn't wait for exit and outputs to /dev/null.
 */
static pid_t
system_nowait(const char *file, char *const argv[])
{
	pid_t pid = fork();

	if (pid)
		return pid;

	int fd = open("/dev/null", O_WRONLY);

	dup2(fd, 1);
	dup2(fd, 2);

	close(fd);

	execvp(file, argv);
	exit(1);
}

static void 
terminal_binding_callback(struct weston_keyboard *keyboard,
                         const struct timespec *time, uint32_t key, 
                         void *data)
{
        struct weston_compositor *compositor = data;

        pid_t spawn = system_nowait("weston-terminal",
                                   (char * const[]) {"weston-terminal", "--shell=/bin/bash", NULL, NULL});

        if (spawn == -1) {
                weston_log("Failed spawning process %s\n", (char *) data);
                return;
        }    

        struct weston_process *wp = malloc(sizeof(*wp));;
        wp->pid = spawn;
        wp->cleanup = process_cleanup;

        wet_watch_process(compositor, wp);
}

-En la función shell_add_bindings(), añadimos (debajo de la última llamada a "weston_compositor_add_key_binding()", si quieres):

        /* Add binding for launching terminal with CTRL + ALT + T */
        weston_compositor_add_key_binding(ec, KEY_T, MODIFIER_CTRL | MODIFIER_ALT,
                                          terminal_binding_callback, ec);
                                          
Y YA ESTÁ. Como ves, podemos añadir todos los atajos que queramos muy fácilmente, añadiéndolos como nuevas llamadas a
weston_compositor_add_key_binding().

FUENTE: Sacado del código del "weston keybinder", cuyo primer commit está aquí:
https://github.com/tarvi-verro/weston-binder/commit/40b3112f221ef3a1c42f536d8047b8565ee3f2d8
(Hay mucho más código del necesario ahí porque tiene que parsear las opciones del .ini, etc.
 Fíjate sólo en binder_add_bindings() y binder_callback_ctrl_alt(). ).
 
2) Compila e instala el "weston keybinder": 

git clone --depth 1 https://github.com/tarvi-verro/weston-binder.git
make -j4
cp binder.so /usr/local/lib/aarch64-linux-gnu/weston/

Y ahora sólo queda añadir a ~/.config/weston.ini la carga del módulo keybinder que acabas de compilar, así como los atajos que quieras. 

Para cargar el módulo:

[core]
modules=binder.so

Y un atajo de teclado sería por ejemplo:

[keybind]
key=ctrl+alt+t
exec=weston-terminal --shell=/bin/bash

CONSTRUIR UN ESCRITORIO COMPLETO BASADO EN WAYLAND
==================================================

NOTA PREVIA: Mucha de la información viene de aquí: https://github.com/natpen/awesome-wayland

---PARTE 1 - EL COMPOSITOR---

-Elegimos un compositor que sea stacking, no tiling.
Si insistes en usar Weston, puedes añadir nuevos keyboard shortcuts con esto:
https://github.com/tarvi-verro/weston-binder

---PARTE 2 - EL TOOLKIT---

-Compilamos un toolkit que soporte Wayland.
Básicamente elegimos entre GTK y QT. GTK es más ligero y sencillo de compilar (QT son varios paquetes).

Para compilar GTK3 (la versión más compatible con programas actualmente y que a la vez tiene soporte WAYLAND es GTK3)
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
-Configuramos como:
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dprint-cloudprint=disabled -Dvulkan=enabled -Dxinerama=disabled -Dintrospection=disabled -Ddemos=false \
-Dbuild-examples=false -Dbuild-tests=false
ninja -j4
sudo ninja install

Para compilar GTK4 sería:
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dvulkan=enabled -Dintrospection=disabled -Ddemos=false -Dbuild-examples=false -Dbuild-tests=false 
ninja -j4
sudo ninja install

---PARTE 3 - LAS APLICACIONES---

-Compilamos un file browser que soporte GTK. Elegimos pcmanfm, que soporta tanto GTK como QT. Otra alternativa sería thunar.
Para compilar PCMANFM:

Empezamos con una dependencia, libfm:
-Bajamos los últimos sources estables de: https://github.com/lxde/libfm/releases

Ahora vamos con PCMANFM en sí:
-Bajamos los últimos sources estables de: https://github.com/lxde/pcmanfm/releases

INSTALAR DWL, EL COMPOSITOR DE ESCRITORIO BASADO EN WLROOTS MÁS BÁSICO QUE HAY (DOCS: "EVERY FRAME IS PERFECT")
===============================================================================================================

Clonamos su repo:

git clone --depth 1 https://github.com/djpohly/dwl.git
(OJO, para compilarlo contra la última versión de los sources de WLROOTS en lugar de la versión estable,
tendríamos que clonar el branch "wlroots-next"). 

Aplicamos este parche para que el confinamiento del puntero funcione (para no tener puntero pegajoso en los lados
en Scummvm a pantalla completa):
https://github.com/djpohly/dwl/wiki/pointerConstraints
patch -p1 < <NOMBRE_PARCHE>

Editamos dwl.c, nos vamos a la función createmon() y comentamos las llamadas a wlr_output_enable() y wlr_output_set_mode() que hay allí,
ya que ambas causan full modesettings y por tanto apagado y encendido de la pantalla (AKA flickering).
(Si piensas que un compositor debería detectar si un output ya está enabled antes de llamar wlr_output_enable() sobre él, recuerda
que según emersion, detectar si un conector está activado NO ES FIABLE, por eso los compositores llaman wlr_output_enable() por sistema).

Compilamos con:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make -j4

Se sale de dwl con ALT+SHIFT+Q

Si al compilar da un error de que no encuentra "wlr/backend/libinput.h" es porque compilaste WLROOTS sin pasarle libinput
a -Dbackends. Deberías pasarle tanto "drm" como "libinput", así: -Dbackends=drm,libinput.
Lo tienes en las instrucciones de compilación de WLROOTS.

Para quitar el borde rojo cuando la ventana está activa, edita config.h y en "focuscolor" quita la componente roja.

TINYWL+, UN COMPOSITOR BASADO EN TINYWL PERO CON MÁS FUNCIONES
==============================================================

https://cppdig.com/c/a-simple-stacking-wayland-compositor-based-on-tinywl

CAGE, UN COMPOSITOR PARA APLICACIONES EMBEDIDAS
===============================================

Bajamos los últimos sources estables de:
https://github.com/Hjdskes/cage/releases

Compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. --buildtype=release

ninja -j4
sudo ninja install

Lanzaríamos el programa que queramos así:
-Lo primero, lanzamos el seatd, para loguear al usuario Pi en un asiento y poder lanzar el cage:
sudo seatd -u pi &
-Ahora lanzamos el cage y le pasamos el ejecutable que queramos:
cage <nombre_ejecutable>
Y si es con parámetros, usamos -- entre cage y el nombre del ejecutable, así:
cage -- <nombre_ejecutable> <parámetros>

FOOT, UN EMULADOR DE TERMINAL PARA WAYLAND
==========================================

Instalamos dependencias previas:
apt-get install libfontconfig-dev libncurses-dev --no-install-recommends

Bajamos la última versión estable de aquí:
https://codeberg.org/dnkl/foot/releases

Configuramos y compilamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddocs=disabled -Dgrapheme-clustering=disabled -Dtests=false -Dime=false ..

ninja -j4
ninja install

Creamos ~/config/foot/foot.ini con este contenido:
(OJO: Puedes tener foot/foot.ini donde quieras si exportas un valor de $XDG_CONFIG_HOME).

shell=bash
term=xterm-256color
font=monospace:size=20
title=Command Console

initial-window-size-chars=98x24
#initial-window-mode=fullscreen
#initial-window-mode=maximized

-Para tener una fuente chula en vez de la monospace por defecto:
	-Instalamos: apt-get install fonts-jetbrains-mono
	-En el foot.ini: font=JetBrainsMono:size=20

-Para tener un cursor como el de la TTY (aunque yo prefiero últimamente style=block):
[cursor]
style=underline
blink=yes

-Para instalar un tema, simplemente cópiate el contenido del tema que quieras (están en /usr/local/shared/foot/themes)
 al final del foot.ini, y listo.

KITTY, UN EMULADOR DE TERMINAL PARA WAYLAND
-------------------------------------------

--Requisito previo: GLFW, que es lo que usa Kitty para dibujar en pantalla.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

AHORA VAMOS A POR KITTY EN SÍ...

--Clonamos su repo, configuramos y compilamos:

git clone --depth 1 https://github.com/kovidgoyal/kitty

CFLAGS="-march=native -mtune=native" \
./configure

make -j4

--Lo lanzamos en modo fullscreen con:
kitty --start-as fullscreen
(NO, no falta ningún guión).

--Para ajustar la fuente, podemos editar su configuración. Para ello, desde dentro de Kitty, hacemos CTRL+SHIFT+F2,
cambiamos lo que sea y guardamos.
De este modo, se nos crea ~/.config/kitty/kitty.conf, que podemos editar luego y cambiar lo que queramos.

DEBUGEAR PROGRAMAS SOBRE WAYLAND POR SSH
========================================

LO PRIMERO ES ENTENDER cómo va esto.
Los programas que corren en Wayland necesitan XDG_RUNTIME_DIR (que en nuestro sistema mínimo apunta a /run, almacenado en RAM),
para así poder encontrar el fichero "wayland-0", o "wayland-1" o lo que sea, que estará en XDG_RUNTIME_DIR cuando haya una sesión wayland en marcha.
Y del otro lado, el compositor debe exportar WAYLAND_DISPLAY=wayland-0, WAYLAND_DISPLAY=wayland-1...

Vamos, que tenemos que tener seteadas correctamente las variables de entorno XDG_RUNTIME_DIR y WAYLAND_DISPLAY
en el PC normal.

Se hace asi:
Miramos en el sistema "servidor" el valor de las variables:
env | grep XDG_RUNTIME_DIR
env | grep WAYLAND_DISPLAY

Exportamos en el PC de debugueo:
export XDG_RUNTIME_DIR=/run                 <---(Sólo si, NO USANDO systemd, hemos exportado XDG_RUNTIME_DIR=/run en /etc/minimal).
export WAYLAND_DISPLAY=wayland-1

(Puedes elegir que valor exporta Weston en WAYLAND_DISPLAY con el parametro -S).
(Normalmente, si usasemos SSH usaría PAM y pillaría las mismas variables de entorno para todas las sesiones de un usuario).

HABILITAR LOGS DE DEBUGGING DE DRM
==================================

echo 0x19F | sudo tee /sys/module/drm/parameters/debug

dmesg -C

DEBUGUEAR O INVESTIGAR PROBLEMAS DE WLROOTS
===========================================

-Activamos el modo debug del driver DRM del kernel, con 
echo 0x19F | sudo tee /sys/module/drm/parameters/debug
-Con GDB, nos ponemos en atomic_commit(), y justo antes de que se ejecute drmAtomicCommit(), hacemos un "dmesg -C" para limpiar dmesg,
ejecutamos drmAtomicCommit(), y ejecutamos dmesg. Vemos qué propiedades se van a modificar: son las de las líneas en que pone: "Added..."
-Si ahí no vemos errores ni propiedades problemáticas, volvemos a iniciar el compositor con GDB y nos vamos a atomic_crtc_commit(), y
vamos viendo cúales de las llamadas de atomic_add() se ejecutan entre atomic_begin() y atomic_finish(), y ahí ya vemos clarísimamente qué
propiedades del CONNECTOR o del CRTC se van a modificar en la siguiente llamada a atomic_commit(). Porque recuerda que todas estas funciones
están double-buffered, es decir, no tienen efectos hasta que haya una llamada a atomic_commit().


* Un problema muy típico es que se modifiquen propiedades que necesitan full modeset sin que se esté haciendo un full modeset,
es decir, sin que se esté activando el flag DRM_MODE_ATOMIC_ALLOW_MODESET.
Las propiedades que necesitan un full modeset son:
-Que se cambie el CRTC de un conector
-Que se cambie el modo de vídeo de un CRTC
-Que se cambie el estado entre ACIVO/INACTIVO de un CRTC
-...Y que hayamos averiguado por las malas, que se cambie el max_bpc de un CONNECTOR

NNN, FILE MANAGER LIGERO PARA EMULADOR DE TERMINAL
==================================================

Bajamos la última estable de:
https://github.com/jarun/nnn/releases

Compilamos e instalamos con:
CFLAGS="-march=native -mtune=native" make O_NORL=1 O_NERD=1 -j4
make install

Para tener iconos gráficos junto a los nombres de archivo, tenemos que tener una fuente puesta en el emulador de terminal que los soporte,
es decir que por ejemplo el emulador de terminal FOOT tiene que tener una fuente parcheada con NERD. Tienes las instrucciones para instalarlas
en la sección de cómo instalar SWAY.

Si no te salen iconos al lado de los ficheros a pesar de haber instalado la nerdfont, simplemente reinicia la terminal
y vuelve a lanzar nnn, y ya deberían salir.

PARA QUE LANCE SCRIPTS EJECUTABLES, QUE TENEMOS QUE DARLE LA EXTENSIÓN .run:

1) Copiamos el contenido del directorio "plugins" que viene con los sources a ~/.config/nnn/plugins/
(El directorio ~/.config/nnn/plugins/ se crea la primera vez que ejecutamos nnn).

2) La idea es que no se pueda ejecutar cualquier cosa, sino sólo los .run que nosotros creemos. A tal efecto,
editamos ~/.config/nnn/plugins/nuke y añadimos, debajo de la sección "Log files", por ejemplo, nuestra propia sección para lanzar archivos .run:
## Run files
        run)
            /usr/bin/sh "${FPATH}"
            exit 0;;

3) Ahora tenemos que decirle a nnn con qué plugin queremos abrir los archivos. Para ello, creamos un script que setee ciertas
variables de entorno y luego lance el nnn, que llamaremos /usr/local/bin/run_nnn, con el contenido:
export PATH=$PATH:$HOME/.config/nnn/plugins
export NNN_OPENER=nuke
(NOTA: NO podemos añadir el seteo de estas variables de entorno a .bash_profile, ni a /etc/profile ni a /etc/environment porque
todos esos ficheros son leidos por un bash, que nosotros no lanzamos porque lanzamos directamente nnn: por eso las seteamos
en el script de lanzamiento de nnn, ese tal /usr/local/bin/n).

4) Como la idea es que si usamos nnn sea nuestro shell y no tener que escribir comandos, añadimos a ~/.config/foot/foot.ini:
shell=n

PARA QUE LANCE AUTOMÁTICAMENTE ROMS DE SISTEMAS EMULADOS

Donde hemos añadido lo de los archivos .run, añadimos debajo cosas como estas:

        ## NES files
        nes)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/nestopia_libretro.so -- "${FPATH}"
            exit 0;;

        ## Master System, Megadrive and SG-1000 files (Don't use .md extension because these are
        ## markdown text files!)
        smd|sms|sg)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/genesis_plus_gx_libretro.so -- "${FPATH}"
            exit 0;;

        ## PCE files
        pce)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_pce_libretro.so -- "${FPATH}"
            exit 0;;

        ## Gameboy & Gameboy Color files
        gb|gbc)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/gambatte_libretro.so -- "${FPATH}"
            exit 0;;

        ## GBA files
        gba)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mgba_libretro.so -- "${FPATH}"
            exit 0;;

        ## SNES files
        smc|sfc)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_supafaust_libretro.so -- "${FPATH}"
            exit 0;;

        ## LYNX files
        lnx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_lynx_libretro.so -- "${FPATH}"
            exit 0;;

        ## FBNEO files
        fbneo)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so -- "${FPATH}"
            exit 0;;

        ## MSX files
        msx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=msx -- "${FPATH}"
            exit 0;;

		## PSX files (Eliminamos la extensión .psx y añadimos la extensión .chd, porque en realidad cargamos los .chd).
        psx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/swanstation_libretro.so -- "${FPATH%.psx}.chd"
            exit 0;;
            
        ## MCD files (Eliminamos la extensión .mcd y añadimos la extensión .chd, porque en realidad cargamos los .chd).
        mcd)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/genesis_plus_gx_libretro.so -- "${FPATH%.mcd}.chd"
            exit 0;;

		## PCD files (Eliminamos la extensión .pcd y añadimos la extensión .chd, porque en realidad cargamos los .chd).
        pcd)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_pce_fast_libretro.so -- "${FPATH%.pcd}.chd"
            exit 0;;

		## Virtual Boy VB files (Ponemos un modo de vídeo de 50Hz)
        vb)
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@50
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_vb_libretro.so -- "${FPATH%}"
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60
            exit 0;;

		## Amiga HDF files (Ponemos un modo de vídeo de 50Hz)
        hdf)
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@50
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/puae_libretro.so -- "${FPATH%}"
            wlr-randr --output HDMI-A-1 --custom-mode 1920x1080@60
            exit 0;;

...Y para crear los .fbneo, nos vamos al directorio de arcade o de neogeo o de lo que sea y creamos un link simbólico de cada .zip, así:
for file in *.zip; do ln -s -- "$file" "${file%.zip}.fbneo"; done

...Y para crear los .msx, nos vamos al directorio de msx y creamos un link simbólico de cada .zip, así:
for file in *.zip; do ln -s -- "$file" "${file%.zip}.msx"; done

...Y para crear los .psx, nos vamos al directorio de PlayStation y creamos un link simbólico de cada .chd, así:
for file in *.chd; do ln -s -- "$file" "${file%.chd}.psx"; done

...Y para crear los .mcd, nos vamos al directorio de MegaCD y creamos un link simbólico de cada .chd, así:
for file in *.chd; do ln -s -- "$file" "${file%.chd}.mcd"; done

...Y para crear los .pcd, nos vamos al directorio de PCE-CD y creamos un link simbólico de cada .chd, así:
for file in *.chd; do ln -s -- "$file" "${file%.chd}.pcd"; done

NOTAS PARA PODER USAR WAYLAND EN EL FUTURO
==========================================

Actualmente no es alternativa de uso diario porque todo lo de Vulkan va a tener lag debido a que siempre va a darnos un swapchain de 4:
https://github.com/libretro/RetroArch/issues/13812
Que da lugar a esta issue en gitlab:
https://gitlab.freedesktop.org/mesa/mesa/-/issues/6249
Hasta que no se resuelvan esas dos issues, Wayland no sirve para Vulkan sin latencia.

Es un problema común de TODAS las implementaciones de Vulkan en Wayland, da igual que sea AMD, VC4, INTEL...
Todo se reduce a que se haga un merge de esto en MESA:
https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12086

Se podría usar GLES2 para RetroArch en lugar de Vulkan, pero el backend de contexto WAYLAND de RetroArch tampoco tiene un
mecanismo explícito para esperar a que se complete el eglSwapBuffers() que hacemos en gfx_ctx_wl_swap_buffers()
en gfx/drivers_context/wayland_ctx.c, así que simplemente se está haciendo eglSwapBuffers() y el driver decide. Mal.

INTENTO DE COMPILAR MUTTER, EL COMPOSITOR DE GNOME
==================================================

Instalamos dependencias previas:
apt-get install libgraphene-1.0-dev --no-install-recommends
(OJO: para desinstalar libgraphene y sus dependencias, tenemos que hacerlo manualmente así o nos deja basura:
apt-get purge gir1.2-freedesktop gir1.2-glib-2.0 gir1.2-graphene-1.0 gobject-introspection libgirepository-1.0-1 libgirepository1.0-dev libgraphene-1.0-0 libgraphene-1.0-dev python3-markdown)

apt-get install python3-docutils libatk1.0-dev libgdk-pixbuf2.0-bin --no-install-recommends

Instalamos otra dependencia previa, gtk3+ (OJO, es GTK3+, NO GTK3 NI GTK4!!!, SINO QUE DEBE SER EL QUE LLEVA EL "PLUS"):
-Nos bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk+ 
(Yo uso https://download.gnome.org/sources/gtk+/3.24/gtk%2B-3.24.34.tar.xz , ya que es lo que indica Linux From Scratch
 que hace falta para compilar mutter).
-Configuramos gtk3+ con:
meson .. -Dbuildtype=release -Ddemos=false -Dx11_backend=false -Dintrospection=false -Ddemos=false -Dexamples=false

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Instalamos dependencias previas: apt-get install libglib2.0-dev libfontconfig-dev
-Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

AHORA VAMOS CON MUTTER EN SÍ
-Clonamos su repo:
git clone --depth 1 https://github.com/GNOME/mutter.git
-Configuramos con:
meson -Dbuildtype=release ..

INSTALAR SWAY, COMPOSITOR TILING
================================

Instalamos dependencias previas:
apt-get install libjson-c-dev --no-install-recommends

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Instalamos dependencias previas: apt-get install libglib2.0-dev libfontconfig-dev
-Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

-Instalamos otra dependencia previa: libinput desde su última versión estable, ya que Debian no tiene una versión suficientemente actual
ni siquiera en backports.
-Instalamos dependencias previas de libinput: apt-get install libmtdev-dev libevdev-dev
-Nos bajamos los últimos sources estables de libinput de: https://gitlab.freedesktop.org/libinput/libinput/-/releases
-Configuramos libinput con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release -Dlibwacom=false -Ddebug-gui=false -Dtests=false -Ddocumentation=false 

Ahora vamos a por SWAY en sí:
-Bajamos la última estable o RC de: https://github.com/swaywm/sway/releases
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dswaybar=false -Dswaynag=false -Dgdk-pixbuf=disabled \
-Dfish-completions=false -Dzsh-completions=false -Ddefault-wallpaper=false -Dman-pages=disabled ..

Copiamos el fichero "config" que viene con los sources a ~/.config/sway/config, y hacemos ahí los cambios que queramos, como por ejemplo:
(Vamos buscando los comentarios y dejamos debajo los valores que queramos)

-Para que la tecla MOD sea ALT, de manera que todos los demás atajos funcionen:
# Logo key. Use Mod1 for Alt.
set $mod Mod1

-Para que se use el modo de vídeo actual:
output HDMI-A-1 resolution 1280x720@60 position 0,0

-Para tener el teclado en castellano:
input type:keyboard {
        xkb_layout es
}

-Para lanzar el terminal con CTRL+ALT+T:
# Start a terminal
bindsym Ctrl+$mod+t exec $term

-Para cerrar ventanas con ALT+F4:
# Kill focused window
bindsym $mod+f4 kill

-Para cerrar SWAY con CTRL+ALT+BACKSPACE, sin confirmación ni chorradas:
# Exit sway (logs you out of your Wayland session)
bindsym $mod+Ctrl+backspace exec swaymsg exit

-Para ocultar el cursor del ratón cuando no lo estamos usando (al cabo de 3 segundos en este ejemplo):
seat seat0 hide_cursor 3000

-Para lanzar el terminal "foot" al arrancar Sway:
exec swaymsg "workspace 1; exec foot;"

-Para escalar la fuente monospace por defecto:
font monospace 16

-Para tener una fuente chula en vez de la monospace por defecto, tanto por defecto en el escritorio como en la terminal:
	-Bajamos el zip de una fuente parcheada nerdfont de aquí: https://www.nerdfonts.com/font-downloads
	 (Son fuentes que podrías instalarte como paquetes desde Debian, pero estas versiones parcheadas Nerd traen glifos
	 que permiten mostrar iconos gráficos en la consola.)
	 Por ejemplo, yo me suelo bajar JetBrainsMono. Metemos los contenidos del zip en /usr/local/share/fonts/truetype/jetbrains.
	-Instalamos la herramientra que nos permite regenerar la caché de fuentes del sistema: apt-get install fontconfig
	-Regeneramos la caché de fuentes del sistema, y confirmamos qué fuentes de la famila JetBrains están reconocidas en él:
		fc-cache -f -v
	    fc-list | grep JetBrains
	-Supongamos que queremos, de entre las fuentes listadas que tenemos en la caché, la llamada "JetBrainsMono Nerd Font". Pues pondremos:
		-En el ~/.config/sway/config: font JetBrainsMono Nerd Font 14
	    -En el ~/.config/foot/foot.ini: font=JetBrainsMono Nerd Font:size=10
	
-Para evitar que las ventanas maximizadas tengan bordes, que sobre todo los verticales quedan muy feos (se puede poner
vertical, horizontal o both):
hide_edge_borders both

-Para que las ventanas no tengan el nombre arriba:
default_border none

-Para que no haga eso tan molesto de que cada vez que pones el raton en una ventana, esa ventana pilla el foco:
focus_follows_mouse no

-Para que las ventanas no tengan borde ni nombre ni nada:
default_border none

-Para que las ventanas sean "floating windows" en lugar de tiling (NO recomendado):

for_window [app_id=".*"] floating enable
for_window [app_id=".*"] border normal

-Para implementar un ALT+TAB que cambia a la ventana de la izquierda, y con ALT+SHIFT+TAB a la ventana de la derecha, 
añade en la seccion Key Bindings:
bindsym $mod+Tab focus left
bindsym $mod+Shift+Tab focus right

-PARA MAS OPCIONES: https://manpages.ubuntu.com/manpages/focal/man5/sway.5.html

LANZAR SWAY COMO SERVICIO DE SYSTEMD
====================================

Creamos /etc/systemd/system/sway.service con el contenido:

#############

[Unit]
Description=sway - User service

[Service]
Type=oneshot
User=root
Group=root
PAMName=login
WorkingDirectory=%h
ExecStart=
ExecStart=-/usr/local/bin/sway
ExecStartPost=/usr/bin/systemctl poweroff
Restart=on-failure

[Install]
WantedBy=graphical.target

#############
*NOTA: Tal como está, está pensado para que al salir de SWAY el sistema se apague. Esto nos interesa porque puede que no
 arranquemos a una consola de comandos y por tanto no tendríamos manera de apagarlo a mano sin esto.
 Si quisiésemos que al salir de SWAY se volviese a levantar el servicio, pondríamos Restart=always y quitaríamos las líneas
 de Type=oneshot y ExecStartPost=...
*NOTA: El WorkingDirectory puesto a "%h" significa usar nuestro $HOME, que sera /root si no eres otro usario. 
*NOTA: Si tuvieramos que añadir mas servicios, irian con:
[Install]
WantedBy=default.target
...en vez de graphical.target, porque lo que nos interesa es que esos servicios se lancen sea cual sea el target
que tengamos puesto como default, NO nos interesa que se lancen solo cuando el target puesto como default sea graphical.
El caso de sway es especial, porque solo se tiene que lanzar cuando el target sea graphical).
*NOTA
-Podemos ver los targets activos con: systemctl list-units --type target
-Podemos ver los targets que hay en el sistema, aunque no esten activos, mirando en /lib/systemd/system

Establecemos graphical.target como target por defecto:
systemctl set-default graphical.target
Podemos comprobarlo con:
systemctl get-default
(Si alguna vez quisieramos volver a un modo de texto, estableceriamos el target multi-user como target por defecto:
systemctl set-default multi-user.target
Y NO HARIA FALTA VOLVER A DESACTIVAR EL SERVICIO SWAY, YA QUE NOS QUEDAMOS EN EL TARGET MULTI-USER Y DE ESE MODO
NO SE CARGA EL SERVICIO SWAY.)

Ahora activamos el servicio SWAY con:
systemctl enable sway.service
(Recuerda que lo que hace esto es crear el symlink /etc/systemd/system/graphical.target.wants/sway.service apuntando
a /etc/systemd/system/sway.service, que es logico porque el target graphical.target necesita sway.target tal como hemos
especificado en la UNIT de sway). 

Desactivamos el autologin en TTY con:
systemctl disable getty@tty1

Ahora ya configuramos el BASH.
Al principio del todo de ~/.bashrc ponemos esto para evitar problemas con el saludo y el scp:
# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

Para añadir al PATH el diretorio actual, que no nos muestre todo el rato el usuario y el hostname,
y que nos muestre un mensaje de bienvenida y la IP añadimos en ~/.bashrc:
PATH=$PATH:.
PS1="\W "
MY_IP=$(ip -4 addr show wlan0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')

echo "                                               "
echo " ^_^    Welcome to Debian 11 GNU/Linux aarch64."
echo "(O,O)   Service management is done via SystemD."
echo "/)_)    This computer's local IP is $MY_IP"
echo " ¨ ¨    Have fun!"  
echo "     "

Para poder ejecutar por ssh programas que corran sobre Wayland:
export XDG_RUNTIME_DIR=/var/run/user/0
export WAYLAND_DISPLAY=wayland-1
(OJO: Si no funciona con estos valores, mira qué valores tienen estas variables de entorno en el sistema "servidor").

Para que no se vea el cursor parpadeante de la TTY, añadimos a cmdline.txt:
vt.global_cursor_default=0

INSTALAR LABWC, COMPOSITOR WINDOW-STACKING
==========================================

Instalamos dependencias previas:
apt-get install libxml2-dev --no-install-recommends

-Instalamos manualmente una dependencia previa, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas de CAIRO: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de: https://gitlab.freedesktop.org/cairo/cairo/-/releases
--Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dzlib=disabled -Dtests=disabled -Ddwrite=disabled ..

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Instalamos dependencias previas: apt-get install libglib2.0-dev libfontconfig-dev
-Desinstalamos el pango del sistema: apt-get purge libpango* && apt-get autoremove
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibthai=disabled -Dxft=disabled ..

Instalar labwc en sí:

Bajamos la última release estable de aquí:
https://github.com/labwc/labwc/releases

Configuramos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dxwayland=disabled ..

Podemos lanzar un programa a la vez que el compositor con:
labwc -s foot
Pero lo suyo es meterlo en ~/.config/labwc/autostart así:
/usr/local/bin/foot >/dev/null 2>&1 &

////BLOQUE CONFIGURACIÓN DE LABWC////
(info sacada de esta guía: https://labwc.github.io/getting-started.html)
(para ver todas las opciones posibles: https://github.com/labwc/labwc/blob/master/docs/rc.xml.all)

--Para teclado en español creamos ~/.config/labwc/environment con el contenido:
XKB_DEFAULT_LAYOUT=es

--Para que se lanze el foot automáticamente, creamos ~/.config/labwc/autostart con el contenido:
/usr/local/bin/foot

AHORA CREAMOS  ~/.config/labwc/rc.xml Y LE VAMOS AÑADIENDO COSAS:

<?xml version="1.0" ?>
<labwc_config>

	<core>
		<reuseOutputMode>yes</reuseOutputMode>
	</core>

	<keyboard>
		<keybind key="C-A-t"><action name="Execute" command="foot" /></keybind>
		<keybind key="C-A-KP_Delete"><action name="Execute" command="reboot" /></keybind>
		<keybind key="C-A-BackSpace"><action name="Exit" /></keybind>
		<keybind key="A-Tab"><action name="NextWindow" /></keybind>
		<keybind key="A-F4"><action name="Close" /></keybind>
	</keyboard>

	<theme>
    	<name>Numix-Clone</name>
    	<cornerRadius>0</cornerRadius>
    	<font> 
                <name>sans</name>
                <size>14</size>
        </font>
	</theme>


</labwc_config>

--Para poder ver los eventos de teclado, podemos verlo desde un ordenador con X11 (son los mismos eventos),
pero si nos empeñamos en verlo desde wayland, podemos usar wev:
git clone --depth 1 https://git.sr.ht/~sircmpwn/wev
CFLAGS="-march=native -mtune=native" make -j4
make install

--Para ver más acciones de labwc (como lo de Execute, Exit, etc...) que podrías asignar a combinaciones de teclado:
https://labwc.github.io/labwc-actions.5.html

--Para ver ejemplos de atajos de teclado posibles:
https://github.com/labwc/labwc/blob/master/docs/rc.xml.all

--Para instalar temas:
----Metemos los temas que queramos en ~/.local/share/themes. Cada tema debe incluir un directorio llamado "openbox-3".
    Por ejemplo, el tema "BL-Lithium" tendrá que estar en "~/.local/share/themes/BL-Lithium" y dentro tendrá un directorio "openbox-3"
    Vamos a instalar un pack de temas muy buenos:
    git clone --depth 1 https://github.com/BunsenLabs/bunsen-themes.git
    cd bunsen-themes/themes
    cp -R * ~/.local/share/themes 
----Ahora, en rc.xml, ponemos el nombre del tema que queramos usar en la etiqueta <name>nombre_tema</name> de la categoría <theme>
    Por ejemplo: <name>Numix-Clone</name>
----OPCIONAL: Si te gusta un tema y quieres modificar cosas, edita su fichero "themerc", todos tienen uno.
	Por ejemplo, algunos temas no ponen bordes a las ventanas. Puedes cambiar eso poniendo border.width a 4 o así.

--Para tener fondo de pantalla:
Nos bajamos la última estable de aquí: https://github.com/swaywm/swaybg/releases
Configuramos, compilamos e instalamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dgdk-pixbuf=disabled -Dman-pages=disabled ..

Y en ~/.config/labwc/autostart:

swaybg -i grid.png >/dev/null 2>&1 &

RELOJ EN WAYLAND
================

git clone --depth 1 https://git.sr.ht/~leon_plickat/wlclock

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

ninja -j4
ninja install

Y en ~/.config/labwc/autostart:
wlclock --border-size 4 --position top-left --size 150 --layer bottom --background-colour "#22373f" --b    order-colour "#152126" >/dev/null 2>&1 &

GAMESCOPE, EL MICROCOMPOSITOR DE STEAM
======================================

-Instalamos dependencias previas:
apt-get install libx11-dev libx11-xcb-dev libxdamage-dev libxcomposite-dev libxrender-dev libxxf86vm-dev libxtst-dev libxres-dev libxmu-dev --no-install-recommends

-Instalamos dependencia previa, hwdata.
--Primero desinstalamos la versión de Debian, ya que le faltan los archivos de pkg-config
y el buildsystem de gamescope no la detecta:
apt-get purge hwdata
apt-get autoremove
--Ahora nos bajamos la última estable de:
https://github.com/vcrhonek/hwdata/releases
Descomprimimos y directamente hacemos:
./config
make install
(NO hay que compilar nada)

git clone --depth 1 https://github.com/Plagman/gamescope.git
cd gamescope
git -c submodule."subprojects/openvr".update=none submodule update --init

(^NOTA: el "git submodule update..." lo hacemos así para evitar a toda costa que se descargue el submódulo openvr, que no lo vamos a usar
y ocupa 500 MB...)

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Denable_openvr_support=false -Dpipewire=disabled -Dxwayland=disabled ..

ninja -j4
ninja install

Y ahora podemos lanzar lo que queramos con:
gamescope -- <ejecutable>

O podemos lanzar el gamescope desde la TTY directamente como otro compositor cualquiera con:
gamescope -e -f -- foot

CAMBIAR LA RESOLUCIÓN AL VUELO EN WAYLAND
=========================================

Usamos wlr-randr para ello.

Clonamos su repo:
git clone --depth 1 https://git.sr.ht/~emersion/wlr-randr

Configuramos, compilamos e instalamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

ninja -j4
ninja install

Se usa igual que xrandr.

Para poner 720p:
wlr-randr --output HDMI-A-1 --mode 1280x720@60

Para poner un modo de 50Hz:
wlr-randr --output HDMI-A-1 --mode 1920x1080@50

Para RetroArch, de todos modos, no debería hacerse así.
Por ejemplo para que RA nos ponga un modo de 50Hz al lanzar el core de Virtual Boy, activamos la opción video_autoswitch_refresh_rate = "1"
en retroach.cfg, y en los overrides del core (en este caso .config/retroarch/config/Beetle VB/Beetle VB.cfg) ponemos
video_refresh_rate = "50.005001". Esa frecuencia se ha detectado poniendo el modo de vídeo a 50Hz con wlr-ranrd y entrando en RA.
Y al cargar una ROM de ese core, debería cambiarnos el modo de vídeo a 50Hz. (OJO: En Wayland de momento no funciona, sólo en KMS/DRM).
