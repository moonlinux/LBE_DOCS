INSTALAR WAYLAND
================

Lo primero: para correr COMPOSITORS BASADOS EN WLROOTS (DWL, TINYWL, SWAY, WAYBOX, CAGE) necesitas WAYLAND y WLROOTS, ya que la mayoría de los compositores se basan en WLROOTS.
A su vez, WLROOTS necesita WAYLAND-PROTOCOLS y LIBSEAT.
LUEGO A PARTE ESTÁ WESTON, QUE NO ESTÁ BASADO EN WLROOTS NI LO NECESITA.
***LIBSEAT ES NECESARIO PARA COMPOSITORES BASADOS EN WLROOTS Y AHORA TAMBIÉN PARA WESTON (ANTES NO HACÍA FALTA, PERO AHORA, WESTON NECESITA
O BIEN LIBSEAT O BIEN, SI USAS SYSTEMD, EL SERVICIO SYSTEMD-LOGIND ACTIVO: UNA DE LAS DOS COSAS).
***LIBSEAT SÓLO ES NECESARIO SI NO TENEMOS CORRIENDO EL SERVICIO "LOGIND" QUE EN SYSTEMD ES "systemd-logind"
   Y QUE EN OTROS INIT DISTINTOS DE SYSTEMD ES "elogind".
   LÓGICAMENTE, EN UN SISTEMA "MINIMAL" DE LOS MIOS, PARA USAR UN COMPOSITOR BASADO EN WLROOTS, LIBSEAT HACE FALTA PORQUE NO TIENES
   NINGÚN SERVICIO DE LOGIN CORRIENDO!

WLROOTS tiene un renderer Vulkan, que desde WESTON no puedes aprovechar por no basarse en WLROOTS.

PARTE 1: WAYLAND EN SÍ (libwayland)
-----------------------------------

Instalamos dependencias previas:
apt-get install libffi-dev --no-install-recommends

Bajamos la última release estable de:
https://wayland.freedesktop.org/releases.html

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddtd_validation=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

PARTE 2: WAYLAND-PROTOCOLS
--------------------------
Bajamos la ultima release estable de:
https://wayland.freedesktop.org/releases.html

Cofiguramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false ..

ninja -j4
sudo ninja install

PARTE 3: WLROOTS (NO NECESARIO PARA WESTON!!)
---------------------------------------------
-Previamente necesitamos KMS/DRM funcionando. Así que deberías ser capaz de ejecutar los tests de SDL2 sobre KMSDR.

LO PRIMERO, SEATD (SÓLO SI NO TENEMOS SYSTEMD!)

-Si no tenemos systemd (sistema "minimal"), o si tenemos systemd sin los servicios "systemd-logind" o "elogind"
(que es lo más normal, porque siempre lo deshabilitas), necesitamos libseat/seatd.
Para instalar libseat:

Clonamos su repo:
git clone --depth 1 https://git.sr.ht/~kennylevinsen/seatd

--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=disabled -Dlibseat-logind=disabled -Dman-pages=disabled ..

ninja -j4
sudo ninja install

--seatd se lanzará, cuando nos haga falta, con:
seatd -u root -l silent &

// BLOQUE PARA DEBIAN 12, QUE YA TIENE UN PAQUETE LIBSEAT, ASÍ QUE ES TODO MÁS SENCILLO:

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev libinput-dev libseat-dev --no-install-recommends
(OJO: Si no estás usando libudev-zero, que es lo que usas en sistemas mínimos, también debes instalar libudev-dev).

// FIN BLOQUE DEBIAN 12

// BLOQUE SÓLO PARA DEBIAN 11, YA QUE NO TIENE EL PAQUETE LIBSEAT

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev --no-install-recommends
(OJO: Si no estás usando libudev-zero, que es lo que usas en sistemas mínimos, debes instalar también libudev-dev).
-Instalamos manualmente la dependencia LIBSEAT, que no está como paquete en DEBIAN 11. Para ello tenemos que instalarla desde backports.
--Instalamos el repositorio de backports, que son versiones del siguiente DEBIAN backporteados para el actual:
		echo "deb http://deb.debian.org/debian bullseye-backports main" | sudo tee /etc/apt/sources.list.d/buster-backports.list
		apt-get update
--Instalamos libseat-dev especificando que la instalamos desde backports:
		apt-get -t bullseye-backports install libseat-dev

// FIN BLOQUE DEBIAN 11

--Instalamos dependencias previas:
apt-get install glslang-dev glslang-tools
--Actualizamos nuestra versión de libvulkan y libvulkan-dev, ya que WLROOTS necesita una reciente si activamos
el renderer VULKAN, para lo cual actualizamos a la version de backports:
		apt-get -t bullseye-backports install libvulkan1
		apt-get -t bullseye-backports install libvulkan-dev (<---Este probablemente no se te actualize, don't worry.)

-Instalar WLROOTS en sí. Para ello:

--Bajamos los últimos sources de WLROOTS estables de aquí: https://gitlab.freedesktop.org/wlroots/wlroots/-/releases

--En nuestro compositor (dwl, cage...) buscamos la llamada a wlr_output_set_mode(), y la quitamos.

--Configuramos, compilamos e instalamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=false -Dxwayland=disabled \
-Dbackends=drm,libinput -Drenderers=gles2,vulkan -Dxcb-errors=disabled ..

ninja -j4
sudo ninja install

RECUERDA que WLROORS soporta renderizado con Vulkan, por lo que los renderers basados en WLROOTS (como DWL, SWAY, WAYBOX...) pueden usarlo.
Para ello, lanzaríamos el compositor que queramos con:
WLR_RENDERER=vulkan <compositor>
(OJO!! WESTON NO USA WLROOTS!!)

=================================================================
PARTE 4: INSTALAR WESTON (EL COMPOSITOR DE REFERENCIA DE WAYLAND)
=================================================================

////////////////// BLOQUE DEBIAN SIN SYSTEMD

Tenemos que instalar nuestras propias compilaciones de libinput y de libsead/seatd (es lo mismo libseat que seatd).
Lo de libinput es porque compila contra UDEV, y en los sistemas sin systemd usamos libudev-zero, compilada por nosotros,
por lo que si usamos el libinput de Debian, falla el linkado de Weston.

PRIMERO VAMOS A POR LIBINPUT
-Instalamos dependencias previas: apt-get install libmtdev-dev libevdev-dev --no-install-recommends
-Bajamos las últimas estables de aquí:
https://www.freedesktop.org/software/libinput/libinput-1.19.4.tar.xz
-Configuramos y compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false -Dinstall-tests=false -Dlibwacom=false -Ddebug-gui=false ..

ninja -j4
ninja install

SEGUNDO VAMOS A POR LIBSEAT/SEATD
Clonamos su repo:
git clone --depth 1 https://git.sr.ht/~kennylevinsen/seatd

--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=disabled -Dlibseat-logind=disabled -Dman-pages=disabled ..

ninja -j4
sudo ninja install

--seatd se lanzará, cuando nos haga falta, con:
seatd -u root -l silent &

/////////////////////////////// FIN BLOQUE DEBIAN SIN SYSTEMD


/////////////////////////////// BLOQUE DEBIAN CON SYSTEMD

-Instalamos dependencias previas, libinput-dev:
sudo apt-get install libinput-dev --no-install-recommends

-Instalamos dependencias previas: libseat-dev
--Instalamos el repositorio de backports, que son versiones del siguiente DEBIAN backporteados para el actual:
		echo "deb http://deb.debian.org/debian bullseye-backports main" | sudo tee /etc/apt/sources.list.d/buster-backports.list
		apt-get update
--Instalamos libseat-dev especificando que la instalamos desde backports:
		apt-get -t bullseye-backports install libseat-dev

/////////////////////////////// FIN BLOQUE DEBIAN CON SYSTEMD

-Instalamos manualmente la dependencia previa de WESTON, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de aquí:
https://gitlab.freedesktop.org/cairo/cairo/-/releases
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

ninja -h4
sudo ninja install

-Instalar WESTON en sí:
Bajamos los últimos sources estables de:
https://gitlab.freedesktop.org/wayland/weston/-/releases

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dbackend-headless=false -Dbackend-rdp=false -Dscreenshare=false -Dbackend-x11=false \
-Dxwayland=false -Dremoting=false -Dsystemd=false -Dpipewire=false -Dshell-ivi=false \
-Dcolor-management-lcms=false -Dcolor-management-lcms=false -Dlauncher-logind=false -Dtools=terminal -Dwcap-decode=false \
-Dtest-junit-xml=false -Dimage-webp=false -Ddoc=false -Dbackend-drm-screencast-vaapi=false -Ddemo-clients=false ..

ninja -j4
sudo ninja install

// BLOQUE PARA USUARIOS NORMALES NO ROOT
Ahora hacemos setuid-root al ejecutable weston, creamos el grupo weston y añadimos al usuario al grupo weston:
sudo chmod 4755 /usr/local/bin/weston
sudo gropuadd weston
sudo usermod -a -G weston pi
// FIN BLOQUE PARA USUARIOS NORMALES NO ROOT

Ahora creamos ~/.config/weston.ini con este contenido:
(RECUERDA que weston.ini puede estar en cualquier ruta que exportes en $XDG_CONFIG_HOME)
(RECUERDA que puedes ver los modos de vídeo disponibles con: modetest |grep -50 modes
 PERO lo mejor es poner mode=current y así no hay cambio de modo.)
(RECUERDA que si, como en este ejemplo, tienes puesto el cursor-theme llamado adwaita, tienes que instalarlo con:
 apt-get install adwaita-icon-theme).

#
# Contenido de weston.ini
#

[core]
idle-time=0

[shell]
locking=false
binding-modifier=alt
animation=zoom
startup-animation=fade
cursor-theme=adwaita
cursor-size=24
background-image=none
background-color=0xFF555555

[terminal]
font=monospace
font-size=18

[launcher]
icon=/usr/local/share/weston/terminal.png
path=/usr/local/bin/weston-terminal --shell=/bin/bash

[input-method]
path=/usr/local/libexec/weston-keyboard

[output]
name=HDMI-A-1
mode=current

[keyboard]
keymap_layout=es
vt-switching=false

#
# Aquí acaba el contenido de weston.ini
#


// BLOQUE SÓLO PARA DEBIAN CON SYSTEMD (sin systemd, ya se exporta XDG_RUNTIME en el script de inicio /etc/minimal)

Añadimos esto a /etc/profile

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

(OJO: Si estás como root, XDG_RUNTIME_DIR sería directamente /run ya que estando como root no hay login manager.
Y de todos modos esto ya lo exportas en /etc/minimal si estás arrancando tu propio sistema mínimo).

// FIN BLOQUE SÓLO PARA DEBIAN CON SYSTEMD

Ahora lanzamos WESTON:
weston -f '' -l ''
(Lo de -f '' -l '' es para que no mande logs a la consola ni a ningún lado).
(Se sale con Ctrl+Alt+Backspace)

Si queremos que se autoarranque, tenemos dos opciones:

1) FORMA MÁS ELEGANTE: USANDO UN SERVICIO DE SYSTEMD.

ESTO A SU VEZ SE PUEDE HACER DE DOS MANERAS:

1.1) OPCIÓN 1

Añadimos esto a /etc/profile (que se ejecutará al ejecutarse weston,
ya que se loguea como el usuario que le pasamos a weston con la opción -u):

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

Creamos el fichero /etc/systemd/system/weston.service mínimo (ya que lo hacemos todo en el /etc/profile), con el contenido:

# Service to launch Weston on boot, on the TTY specified to weston.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
ExecStart=/usr/bin/sudo -E /usr/local/bin/weston -t /dev/tty7 -u pi

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

1.2) OPCIÓN 2

NO añadimos nada a /etc/profile, pero creamos este fichero /etc/systemd/system/weston.service,
que es mucho más grande porque se hace en él lo que haríamos en el /etc/profile.
Además, si te fijas, se usa openvt y en la otra opción no se usa:

# Service to launch Weston on boot, on the first available tty using openvt
# REMEMBER that the openvt "--console=..." parameter specifies a TTY.
# Don't use a TTY on which you have setup getty autologin, it won't work.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
Environment="XDG_RUNTIME_DIR=/run/user/1000"
ExecStartPre=/usr/bin/sudo /bin/mkdir -p /run/user/1000
ExecStartPre=/usr/bin/sudo /bin/chown pi:pi /run/user/1000
ExecStartPre=/bin/chmod 0700 /run/user/1000
ExecStart=/usr/bin/sudo -E -- /bin/openvt -v -w -s -- su pi -l -c "XDG_RUNTIME_DIR=/run/user/1000 /usr/local/bin/weston -- $OPTARGS 2>~/.weston-errors"

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

FIN DE OPCIONES: DE AQUÍ EN ADELANTE ES TODO COMÚN.

Ahora hacemos sudo systemctl enable weston.service (lo que nos creará un symlink en /etc/systemd/system/multiuser.want/, ya que
es necesario para el target "multiuser").

OJO!! NO es compatible con tener autologin en la TTY en la que lanzamos el WESTON. Aunque como nosotros lo lanzamos en TTY7 no hay problema.
PERO por ejemplo, si lo lanzásemos en la TTY1 o TTY2, tendríamos que deshabilitar el autologin en la TTY1 o en la TTY2,
ya que NO ES COMPATIBLE con este método y el servicio falla si lo tienes activo.
sudo systemctl disable getty@tty1
sudo systemctl disable getty@tty2

RECUERDA que si te quedas sin acceso al sistema porque WESTON no arranca y no tienes manera de restablecer el autologin desde la propia Pi,
puedes restablecer los servicios de autologin a mano creando sendos links simbólicos en el directorio del target multiuser, así:
sudo ln -s getty@tty1.service.d multi-user.target.wants/getty@tty1.service
sudo ln -s getty@tty2.service.d multi-user.target.wants/getty@tty2.service
(En realidad, lo único que hace systemctl enable o disable es crear o borrar estos links simbólicos).

2) FORMA MÁS CHAPUCERA: Que se autoarranque al hacerse nuestro típco autologin en la TTY1 (mirar cómo hacer el autologin en la TTY1 y la TTY2),
simplemente tenemos que añadir esto al fichero ~/.profile del usuario para el cual está hecho el autologin:

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

# Start Weston automatically.
if [[ -z "$DISPLAY" ]] && [[ $(tty) = /dev/tty1 ]]; then
	weston
	logout
fi

############################################################
# SI NECESITAS AYUDA CON WAYLAND:                          #
# -https://gitlab.freedesktop.org/wayland/weston/-/issues  #
# -DRM/KMS: Canal #dri-devel en irc.oftc.net               #
# -WESTON:  Canal #wayland en irc.oftc.net                 #
# -WLROOTS: Canal #sway-devel en irc.libera.chat		   #
############################################################

Investigar si se puede hacer simplemente:
sudo -E weston -t /dev/tty7 -u pi

QUITAR ERRORES DE WESTON
========================

--Para quitar los errores:
	could not load cursor 'dnd-move'
	could not load cursor 'dnd-copy'

	Instalamos:
	apt-get adwaita-icon-theme --no-install-recommends

	Y añadimos en .config/weston.ini, en la sección [shell]:

	[shell]
	cursor-theme=adwaita
(Se podría usar otro tema más ligero, pero no lo conozco).

AÑADIR ATAJOS DE TECLADO A WESTON
=================================

TIENES DOS OPCIONES:

1) RECOMENDADO: Añadir los atajos a mano:
Para ello, editamos desktop-shell/shell.c y:

-Añadimos #include <fcntl.h> a los includes del principio.
-Añadimos estas funciones (justo encima de la función shell_add_bindings(), si quieres):

/* Process executed via keybind failed. status is the exit value. */
static void 
process_cleanup(struct weston_process *process, int status)
{
        free(process);
}

/**
 * Much like system(3) but doesn't wait for exit and outputs to /dev/null.
 */
static pid_t
system_nowait(const char *file, char *const argv[])
{
	pid_t pid = fork();

	if (pid)
		return pid;

	int fd = open("/dev/null", O_WRONLY);

	dup2(fd, 1);
	dup2(fd, 2);

	close(fd);

	execvp(file, argv);
	exit(1);
}

static void 
terminal_binding_callback(struct weston_keyboard *keyboard,
                         const struct timespec *time, uint32_t key, 
                         void *data)
{
        struct weston_compositor *compositor = data;

        pid_t spawn = system_nowait("weston-terminal",
                                   (char * const[]) {"weston-terminal", "--shell=/bin/bash", NULL, NULL});

        if (spawn == -1) {
                weston_log("Failed spawning process %s\n", (char *) data);
                return;
        }    

        struct weston_process *wp = malloc(sizeof(*wp));;
        wp->pid = spawn;
        wp->cleanup = process_cleanup;

        wet_watch_process(compositor, wp);
}

-En la función shell_add_bindings(), añadimos (debajo de la última llamada a "weston_compositor_add_key_binding()", si quieres):

        /* Add binding for launching terminal with CTRL + ALT + T */
        weston_compositor_add_key_binding(ec, KEY_T, MODIFIER_CTRL | MODIFIER_ALT,
                                          terminal_binding_callback, ec);
                                          
Y YA ESTÁ. Como ves, podemos añadir todos los atajos que queramos muy fácilmente, añadiéndolos como nuevas llamadas a
weston_compositor_add_key_binding().

FUENTE: Sacado del código del "weston keybinder", cuyo primer commit está aquí:
https://github.com/tarvi-verro/weston-binder/commit/40b3112f221ef3a1c42f536d8047b8565ee3f2d8
(Hay mucho más código del necesario ahí porque tiene que parsear las opciones del .ini, etc.
 Fíjate sólo en binder_add_bindings() y binder_callback_ctrl_alt(). ).
 
2) Compila e instala el "weston keybinder": 

git clone --depth 1 https://github.com/tarvi-verro/weston-binder.git
make -j4
cp binder.so /usr/local/lib/aarch64-linux-gnu/weston/

Y ahora sólo queda añadir a ~/.config/weston.ini la carga del módulo keybinder que acabas de compilar, así como los atajos que quieras. 

Para cargar el módulo:

[core]
modules=binder.so

Y un atajo de teclado sería por ejemplo:

[keybind]
key=ctrl+alt+t
exec=weston-terminal --shell=/bin/bash

CONSTRUIR UN ESCRITORIO COMPLETO BASADO EN WAYLAND
==================================================

NOTA PREVIA: Mucha de la información viene de aquí: https://github.com/natpen/awesome-wayland

---PARTE 1 - EL COMPOSITOR---

-Elegimos un compositor que sea stacking, no tiling.
Por ahora, Weston es el que instalamos. Pero para el tema de los atajos de teclado nos puede interesar waybox o labwc.
Si insistes en usar Weston, puedes añadir nuevos keyboard shortcuts con esto:
https://github.com/tarvi-verro/weston-binder

---PARTE 2 - EL TOOLKIT---

-Compilamos un toolkit que soporte Wayland.
Básicamente elegimos entre GTK y QT. GTK es más ligero y sencillo de compilar (QT son varios paquetes).

Para compilar GTK3 (la versión más compatible con programas actualmente y que a la vez tiene soporte WAYLAND es GTK3)
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
-Configuramos como:
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dprint-cloudprint=disabled -Dvulkan=enabled -Dxinerama=disabled -Dintrospection=disabled -Ddemos=false \
-Dbuild-examples=false -Dbuild-tests=false
ninja -j4
sudo ninja install

Para compilar GTK4 sería:
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dvulkan=enabled -Dintrospection=disabled -Ddemos=false -Dbuild-examples=false -Dbuild-tests=false 
ninja -j4
sudo ninja install

---PARTE 3 - LAS APLICACIONES---

-Compilamos un file browser que soporte GTK. Elegimos pcmanfm, que soporta tanto GTK como QT. Otra alternativa sería thunar.
Para compilar PCMANFM:

Empezamos con una dependencia, libfm:
-Bajamos los últimos sources estables de: https://github.com/lxde/libfm/releases

Ahora vamos con PCMANFM en sí:
-Bajamos los últimos sources estables de: https://github.com/lxde/pcmanfm/releases

DWL, EL COMPOSITOR DE ESCRITORIO BASADO EN WLROOTS MÁS BÁSICO QUE HAY
=====================================================================

Clonamos su repo:

git clone --depth 1 https://github.com/djpohly/dwl.git
(OJO, para compilarlo contra la última versión de los sources de WLROOTS en lugar de la versión estable,
tendríamos que clonar el branch "wlroots-next"). 

Editamos dwl.c y comentamos las llamadas a wlr_output_set_mode() y wlr_output_set_custom_mode(), etc
Podemos quitar todo ese bloque, vamos.

Compilamos con:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make -j4

PARA EJECUTARLO SIN SYSTEMD:
Necesitamos seatd instalado (Se explica en este mismo documento más arriba).
Lanzaríamos seatd como daemon y justo a continuación dlw, así:

seatd -u root -l silent &
dwl

Se sale de dwl con ALT+SHIFT+Q

Si al compilar da un error de que no encuentra "wlr/backend/libinput.h" es porque compilaste WLROOTS sin pasarle libinput
a -Dbackends. Deberías pasarle tanto "drm" como "libinput", así: -Dbackends=drm,libinput.
Lo tienes en las instrucciones de compilación de WLROOTS.

Para que no te cambie la resolución a la resolución preferida del monitor, usa el parche monitor-config de aquí:
https://github.com/djpohly/dwl/wiki/Patches
Te lo bajas y haces: patch -p1 < monfig.patch
(Si falla, entra en el discord de DWL y díselo a Palanix, que es el encargao).

Para quitar el borde rojo cuando la ventana está activa, edita config.h y en "focuscolor" quita la componente roja.

TINYWL+, UN COMPOSITOR BASADO EN TINYWL PERO CON MÁS FUNCIONES
==============================================================

https://cppdig.com/c/a-simple-stacking-wayland-compositor-based-on-tinywl

CAGE, UN COMPOSITOR PARA APLICACIONES EMBEDIDAS
===============================================

Bajamos los últimos sources estables de:
https://github.com/Hjdskes/cage/releases

Compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. --buildtype=release

ninja -j4
sudo ninja install

Lanzaríamos el programa que queramos así:
-Lo primero, lanzamos el seatd, para loguear al usuario Pi en un asiento y poder lanzar el cage:
sudo seatd -u pi &
-Ahora lanzamos el cage y le pasamos el ejecutable que queramos:
cage <nombre_ejecutable>
Y si es con parámetros, usamos -- entre cage y el nombre del ejecutable, así:
cage -- <nombre_ejecutable> <parámetros>

FOOT, UN EMULADOR DE TERMINAL PARA WAYLAND
==========================================

Instalamos dependencias previas:
apt-get install libfontconfig-dev libncurses-dev --no-install-recommends

Bajamos la última versión estable de aquí:
https://codeberg.org/dnkl/foot/releases

Configuramos y compilamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddocs=disabled -Dgrapheme-clustering=disabled -Dtests=false -Dime=false ..

ninja -j4
ninja install

Creamos ~/config/foot/foot.ini con este contenido:
(OJO: Puedes tener foot/foot.ini donde quieras si exportas un valor de $XDG_CONFIG_HOME).

shell=bash
term=xterm-256color
font=monospace:size=24

#initial-window-size-chars=90x20
initial-window-mode=fullscreen

KITTY, UN EMULADOR DE TERMINAL PARA WAYLAND
-------------------------------------------

--Requisito previo: GLFW, que es lo que usa Kitty para dibujar en pantalla.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

AHORA VAMOS A POR KITTY EN SÍ...

--Clonamos su repo, configuramos y compilamos:

git clone --depth 1 https://github.com/kovidgoyal/kitty

CFLAGS="-march=native -mtune=native" \
./configure

make -j4

--Lo lanzamos en modo fullscreen con:
kitty --start-as fullscreen
(NO, no falta ningún guión).

--Para ajustar la fuente, podemos editar su configuración. Para ello, desde dentro de Kitty, hacemos CTRL+SHIFT+F2,
cambiamos lo que sea y guardamos.
De este modo, se nos crea ~/.config/kitty/kitty.conf, que podemos editar luego y cambiar lo que queramos.

DEBUGEAR PROGRAMAS SOBRE WAYLAND POR SSH
========================================

LO PRIMERO ES ENTENDER cómo va esto.
Los programas que corren en Wayland necesitan XDG_RUNTIME_DIR (que en nuestro sistema mínimo apunta a /run, almacenado en RAM),
para así poder encontrar el fichero "wayland-0", o "wayland-1" o lo que sea, que estará en XDG_RUNTIME_DIR cuando haya una sesión wayland en marcha.
Y del otro lado, el compositor debe exportar WAYLAND_DISPLAY=wayland-0, WAYLAND_DISPLAY=wayland-1...

Vamos, que tenemos que tener seteadas correctamente las variables de entorno XDG_RUNTIME_DIR y WAYLAND_DISPLAY
en el PC normal.

Se hace asi:
Miramos en el sistema "servidor" el valor de las variables:
env | grep XDG_RUNTIME_DIR
env | grep WAYLAND_DISPLAY

Exportamos en el PC de debugueo:
export XDG_RUNTIME_DIR=/run                 <---(Sólo si, NO USANDO systemd, hemos exportado XDG_RUNTIME_DIR=/run en /etc/minimal).
export WAYLAND_DISPLAY=wayland-1

(Puedes elegir que valor exporta Weston en WAYLAND_DISPLAY con el parametro -S).
(Normalmente, si usasemos SSH usaría PAM y pillaría las mismas variables de entorno para todas las sesiones de un usuario).

HABILITAR LOGS DE DEBUGGING DE DRM
==================================

echo 0x19F | sudo tee /sys/module/drm/parameters/debug

dmesg -C

DEBUGUEAR O INVESTIGAR PROBLEMAS DE WLROOTS
===========================================

-Activamos el modo debug del driver DRM del kernel, con 
echo 0x19F | sudo tee /sys/module/drm/parameters/debug
-Con GDB, nos ponemos en atomic_commit(), y justo antes de que se ejecute drmAtomicCommit(), hacemos un "dmesg -C" para limpiar dmesg,
ejecutamos drmAtomicCommit(), y ejecutamos dmesg. Vemos qué propiedades se van a modificar: son las de las líneas en que pone: "Added..."
-Si ahí no vemos errores ni propiedades problemáticas, volvemos a iniciar el compositor con GDB y nos vamos a atomic_crtc_commit(), y
vamos viendo cúales de las llamadas de atomic_add() se ejecutan entre atomic_begin() y atomic_finish(), y ahí ya vemos clarísimamente qué
propiedades del CONNECTOR o del CRTC se van a modificar en la siguiente llamada a atomic_commit(). Porque recuerda que todas estas funciones
están double-buffered, es decir, no tienen efectos hasta que haya una llamada a atomic_commit().


* Un problema muy típico es que se modifiquen propiedades que necesitan full modeset sin que se esté haciendo un full modeset,
es decir, sin que se esté activando el flag DRM_MODE_ATOMIC_ALLOW_MODESET.
Las propiedades que necesitan un full modeset son:
-Que se cambie el CRTC de un conector
-Que se cambie el modo de vídeo de un CRTC
-Que se cambie el estado entre ACIVO/INACTIVO de un CRTC
-...Y que hayamos averiguado por las malas, que se cambie el max_bpc de un CONNECTOR

NNN, FILE MANAGER LIGERO PARA EMULADOR DE TERMINAL
==================================================

Bajamos la última estable de:
https://github.com/jarun/nnn/releases

Nos bajamos la nerdfont que queramos de aquí para tener iconos al lado de los ficheros:
https://www.nerdfonts.com/font-downloads
Descomprimimos el zip, y mandamos la fuente TTF que queramos usar a /usr/local/share/fonts/nerdfont.ttf

Compilamos e instalamos con:
CFLAGS="-march=native -mtune=native" make O_NORL=1 O_NERD=1 -j4
make install

Si no te salen iconos al lado de los ficheros a pesar de haber instalado la nerdfont, simplemente reinicia la terminal
y vuelve a lanzar nnn, y ya deberían salir.

PARA QUE LANCE SCRIPTS EJECUTABLES, QUE TENEMOS QUE DARLE LA EXTENSIÓN .run:

1) Editamos plugins/nuke y añadimos, debajo de la sección "Log files", por ejemplo, nuestra propia sección para lanzar archivos .run:
## Run files
        run)
            /usr/bin/sh "${FPATH}"
            exit 0;;

2) Copiamos todos los plugins a ~/.config/nnn/plugins/
(El directorio ~/.config/nnn/plugins/ se crea la primera vez que ejecutamos nnn).

3) Añadimos a ~/.bashrc:
export NNN_OPENER=~/.config/nnn/plugins/nuke
(La idea es que no se pueda ejecutar cualquier cosa, sino sólo los .run que nosotros creemos).

PARA QUE LANCE AUTOMÁTICAMENTE ROMS DE SISTEMAS EMULADOS

Donde hemos añadido lo de los archivos .run, añadimos debajo cosas como estas:

        ## NES files
        nes)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/nestopia_libretro.so -- "${FPATH}"
            exit 0;;

        ## SMS files
        sms)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/genesis_plus_gx_libretro.so -- "${FPATH}"
            exit 0;;

        ## PCE files
        pce)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mednafen_pce_fast_libretro.so -- "${FPATH}"
            exit 0;;

        ## MD files
        md)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/genesis_plus_gx_libretro.so -- "${FPATH}"
            exit 0;;

        ## GBA files
        gba)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/mgba_libretro.so -- "${FPATH}"
            exit 0;;

        ## SNES files
        smc|sfc)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/snes9x_libretro.so -- "${FPATH}"
            exit 0;;

        ## FBNEO files
        fbneo)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so -- "${FPATH}"
            exit 0;;

        ## MSX files
        msx)
            /usr/local/bin/retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=msx -- "${FPATH}"
            exit 0;;

...Y para crear los .fbneo, nos vamos al directorio de arcade o de neogeo o de lo que sea y creamos un link simbólico de cada .zip, así:
for file in *.txt; do ln -s -- "$file" "${file%.zip}.fbneo"; done

...Y para crear los .msx, nos vamos al directorio de msx y creamos un link simbólico de cada .zip, así:
for file in *.txt; do ln -s -- "$file" "${file%.zip}.msx"; done

NOTAS PARA PODER USAR WAYLAND EN EL FUTURO
==========================================

Actualmente no es alternativa de uso diario porque todo lo de Vulkan va a tener lag debido a que siempre va a darnos un swapchain de 4:
https://github.com/libretro/RetroArch/issues/13812
Que da lugar a esta issue en gitlab:
https://gitlab.freedesktop.org/mesa/mesa/-/issues/6249
Hasta que no se resuelvan esas dos issues, Wayland no sirve para Vulkan sin latencia.

Es un problema común de TODAS las implementaciones de Vulkan en Wayland, da igual que sea AMD, VC4, INTEL...
Todo se reduce a que se haga un merge de esto en MESA:
https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12086

Se podría usar GLES2 para RetroArch en lugar de Vulkan, pero el backend de contexto WAYLAND de RetroArch tampoco tiene un
mecanismo explícito para esperar a que se complete el eglSwapBuffers() que hacemos en gfx_ctx_wl_swap_buffers()
en gfx/drivers_context/wayland_ctx.c, así que simplemente se está haciendo eglSwapBuffers() y el driver decide. Mal.

INTENTO DE COMPILAR MUTTER, EL COMPOSITOR DE GNOME
==================================================

Instalamos dependencias previas:
apt-get install libgraphene-1.0-dev --no-install-recommends
(OJO: para desinstalar libgraphene y sus dependencias, tenemos que hacerlo manualmente así o nos deja basura:
apt-get purge gir1.2-freedesktop gir1.2-glib-2.0 gir1.2-graphene-1.0 gobject-introspection libgirepository-1.0-1 libgirepository1.0-dev libgraphene-1.0-0 libgraphene-1.0-dev python3-markdown)

apt-get install python3-docutils libatk1.0-dev libgdk-pixbuf2.0-bin --no-install-recommends

Instalamos otra dependencia previa, gtk3+ (OJO, es GTK3+, NO GTK3 NI GTK4!!!, SINO QUE DEBE SER EL QUE LLEVA EL "PLUS"):
-Nos bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk+ 
(Yo uso https://download.gnome.org/sources/gtk+/3.24/gtk%2B-3.24.34.tar.xz , ya que es lo que indica Linux From Scratch
 que hace falta para compilar mutter).
-Configuramos gtk3+ con:
meson .. -Dbuildtype=release -Ddemos=false -Dx11_backend=false -Dintrospection=false -Ddemos=false -Dexamples=false

Instalamos otra diferencia previa, PANGO:
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Cofiguramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

AHORA VAMOS CON MUTTER EN SÍ
-Clonamos su repo:
git clone --depth 1 https://github.com/GNOME/mutter.git
-Configuramos con:
meson -Dbuildtype=release ..

INSTALAR SWAY, COMPOSITOR TILING
================================

Instalamos dependencias previas:
apt-get install libjson-c-dev --no-install-recommends

Instalamos otra diferencia previa, PANGO, ya que la que trae Debian depende de mierdas de X11:
-Bajamos los últimos sources estables de: https://github.com/GNOME/pango/tags
-Cofiguramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

Ahora vamos a por sway en sí:
-Clonamos su repo:
git clone --depth 1 https://github.com/swaywm/sway.git
-Configuramos con:
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

Copiamos el fichero "config" que viene con los sources a ~/.config/sway/config, y hacemos ahí los cambios que queramos, como por ejemplo:
(Vamos buscando los comentarios y dejamos debajo los valores que queramos)

-Para que la tecla MOD sea ALT, de manera que todos los demás atajos funcionen:
# Logo key. Use Mod1 for Alt.
set $mod Mod1

-Para que se use el modo de vídeo actual:
output HDMI-A-1 resolution 1280x720 position 0,0

-Para tener el teclado en castellano:
input type:keyboard {
        xkb_layout es
}

-Para lanzar el terminal con CTRL+ALT+T:
# Start a terminal
bindsym Ctrl+$mod+t exec $term

-Para cerrar ventanas con ALT+F4:
# Kill focused window
bindsym $mod+f4 kill

-Para cerrar SWAY con CTRL+ALT+BACKSPACE, sin confirmación ni chorradas:
# Exit sway (logs you out of your Wayland session)
bindsym $mod+Ctrl+backspace exec swaymsg exit

INSTALAR LABWC, COMPOSITOR WINDOW-STACKING
==========================================

Clonamos su repo:

git clone --depth 1 https://github.com/labwc/labwc.git

Configuramos con:

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dxwayland=disabled ..
