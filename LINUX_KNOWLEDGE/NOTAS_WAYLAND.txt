INSTALAR WAYLAND
================

Lo primero: para correr WAYBOX, CAGE, o cualquier otro compositor, necesitas WAYLAND y WLROOTS.
A su vez, WLROORS necesita WAYLAND-PROTOCOLS y LIBSEAT

PARTE 1: WAYLAND EN SÍ
----------------------
Bajamos la última release estable de:
https://wayland.freedesktop.org/releases.html

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release -Ddtd_validation=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

PARTE 2: WAYLAND-PROTOCOLS
--------------------------
Bajamos la ultima release estable de:
https://wayland.freedesktop.org/releases.html

Cofiguramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release -Dtests=false ..

ninja -j4
sudo ninja install

PARTE 3: WLROOTS
----------------
-Previamente necesitamos KMS/DRM funcionando. Así que deberías ser capaz de ejecutar los tests de SDL2 sobre KMSDR.

// BLOQUE PARA DEBIAN 11, QUE YA TIENE UN PAQUETE LIBSEAT Y SU VERSIÓN DE LIBINPUT ES ACTUAL, ASÍ QUE ES TODO MÁS SENCILLO:

-Instalamos dependencias previas: sudo apt-get install libudev-dev libpixman-1-dev libxkbcommon-dev libinput-dev libseat-dev --no-install-recommends

// FIN BLOQUE DEBIAN 11

// BLOQUE SÓLO PARA DEBIAN 10, YA QUE NO TIENE EL PAQUETE LIBSEAT Y SU VERSIÓN DE LIBINPUT ES VIEJA

-Instalamos dependencias previas: sudo apt-get install libudev-dev libpixman-1-dev libxkbcommon-dev --no-install-recommends
-Instalamos manualmente la dependencia LIBSEAT, que no está como paquete en DEBIAN 10. Para ello:
--Bajamos los últimos sources estables de aquí: https://git.sr.ht/~kennylevinsen/seatd
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release -Dexamples=disabled ..

ninja -j4
sudo ninja install

-Instalamos manualmente la dependencia LIBINPUT, que la versión que trae DEBIAN 10 es vieja y no nos vale. Para ello:
--Instalamos dependencias previas de LIBINPUT: sudo apt-get install libmtdev-dev
--Bajamos los últimos sources estables de aquí: http://www.freedesktop.org/software/libinput
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release -Dlibwacom=false -Ddebug-gui=false -Dtests=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

// FIN BLOQUE DEBIAN 10

-Instalamos WLROOTS en sí. Para ello:
--Bajamos los últimos sources estables de aquí: https://github.com/swaywm/wlroots/releases
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release -Dexamples=false -Dxwayland=disabled -Dx11-backend=disabled -Dxcb-errors=disabled ..

ninja -j4
sudo ninja install

PARTE 4: WESTON (EL COMPOSITOR DE REFERENCIA, PARA UN DESCRITORIO COMPLETO USA WAYBOX)
--------------------------------------------------------------------------------------

-Instalamos dependencias previas:
sudo apt-get install libpam0g-dev libfontconfig1-dev libevdev-dev --no-insta--recommends

-Instalamos manualmente su dependencia previa, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Bajamos los últimos sources estables de aquí:
https://gitlab.freedesktop.org/cairo/cairo/-/tags
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release ..

ninja -h4
sudo ninja install

-Instalamos WESTON en sí:
Bajamos los últimos sources estables de:
https://gitlab.freedesktop.org/wayland/weston/-/tags
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dbuildtype=release -Dbackend-headless=false -Dbackend-rdp=false -Dscreenshare=false -Dbackend-x11=false -Dbackend-fbdev=false \
-Dxwayland=false -Dremoting=false -Dsystemd=false -Dpipewire=false -Dshell-ivi=false \
-Dcolor-management-lcms=false -Dcolor-management-colord=false -Dlauncher-logind=false -Dtools=terminal -Dwcap-decode=false \
-Dtest-junit-xml=false -Dimage-webp=false -Ddoc=false -Dbackend-drm-screencast-vaapi=false -Ddemo-clients=false ..

ninja -j4
sudo ninja install

Ahora hacemos setuid-root al ejecutable weston-launch, creamos el grupo weston-launch y añadimos al usuario al grupo weston-launch:
sudo chmod 4755 /usr/local/bin/weston-launch
sudo gropuadd weston-launch
sudo usermod -a -G weston-launch pi

Ahora creamos ~/.config/weston.ini con este contenido:
(RECUERDA que puedes ver los modos de vídeo disponibles con: modetest |grep -50 modes
 PERO lo mejor es poner mode=current y así no hay cambio de modo.)

#
# Contenido de weston.ini
#

[core]
idle-time=0

[shell]
locking=false
animation=zoom
startup-animation=fade

[terminal]
font=monospace
font-size=18

[launcher]
icon=/usr/local/share/weston/terminal.png
path=/usr/local/bin/weston-terminal

[input-method]
path=/usr/local/libexec/weston-keyboard

[output]
name=HDMI-A-1
mode=current

[keyboard]
keymap_layout=es
vt-switching=false

#
# Aquí acaba el contenido de weston.ini
#

Ahora añadimos esto a /etc/profile

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

Ahora lanzamos WESTON:
weston-launch
(Se sale con Ctrl+Alt+Backspace)

Si queremos que se autoarranque, tenemos dos opciones:

1) FORMA MÁS ELEGANTE: USANDO UN SERVICIO DE SYSTEMD.

ESTO A SU VEZ SE PUEDE HACER DE DOS MANERAS:

1.1) OPCIÓN 1

Añadimos esto a /etc/profile (que se ejecutará al ejecutarse weston-launch,
ya que se loguea como el usuario que le pasamos a weston-launch con la opción -u):

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

Creamos el fichero /etc/systemd/system/weston.service mínimo (ya que lo hacemos todo en el /etc/profile), con el contenido:

# Service to launch Weston on boot, on the TTY specified to weston-launch.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
ExecStart=/usr/bin/sudo -E /usr/local/bin/weston-launch -t /dev/tty7 -u pi

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

1.2) OPCIÓN 2

NO añadimos nada a /etc/profile, pero creamos este fichero /etc/systemd/system/weston.service,
que es mucho más grande porque se hace en él lo que haríamos en el /etc/profile.
Además, si te fijas, se usa openvt y en la otra opción no se usa:

# Service to launch Weston on boot, on the first available tty using openvt
# REMEMBER that the openvt "--console=..." parameter specifies a TTY.
# Don't use a TTY on which you have setup getty autologin, it won't work.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
Environment="XDG_RUNTIME_DIR=/run/user/1000"
ExecStartPre=/usr/bin/sudo /bin/mkdir -p /run/user/1000
ExecStartPre=/usr/bin/sudo /bin/chown pi:pi /run/user/1000
ExecStartPre=/bin/chmod 0700 /run/user/1000
ExecStart=/usr/bin/sudo -E -- /bin/openvt -v -w -s -- su pi -l -c "XDG_RUNTIME_DIR=/run/user/1000 /usr/local/bin/weston-launch -- $OPTARGS 2>~/.weston-errors"

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

FIN DE OPCIONES: DE AQUÍ EN ADELANTE ES TODO COMÚN.

Ahora hacemos sudo systemctl enable weston.service (lo que nos creará un symlink en /etc/systemd/system/multiuser.want/, ya que
es necesario para el target "multiuser").

OJO!! NO es compatible con tener autologin en la TTY en la que lanzamos el WESTON. Aunque como nosotros lo lanzamos en TTY7 no hay problema.
PERO por ejemplo, si lo lanzásemos en la TTY1 o TTY2, tendríamos que deshabilitar el autologin en la TTY1 o en la TTY2,
ya que NO ES COMPATIBLE con este método y el servicio falla si lo tienes activo.
sudo systemctl disable getty@tty1
sudo systemctl disable getty@tty2

RECUERDA que si te quedas sin acceso al sistema porque WESTON no arranca y no tienes manera de restablecer el autologin desde la propia Pi,
puedes restablecer los servicios de autologin a mano creando sendos links simbólicos en el directorio del target multiuser, así:
sudo ln -s getty@tty1.service.d multi-user.target.wants/getty@tty1.service
sudo ln -s getty@tty2.service.d multi-user.target.wants/getty@tty2.service
(En realidad, lo único que hace systemctl enable o disable es crear o borrar estos links simbólicos).

2) FORMA MÁS CHAPUCERA: Que se autoarranque al hacerse nuestro típco autologin en la TTY1 (mirar cómo hacer el autologin en la TTY1 y la TTY2),
simplemente tenemos que añadir esto al fichero ~/.profile del usuario para el cual está hecho el autologin:

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

# Start Weston automatically.
if [[ -z "$DISPLAY" ]] && [[ $(tty) = /dev/tty1 ]]; then
	weston-launch
	logout
fi

############################################################
# SI NECESITAS AYUDA CON WAYLAND:                          #
# -https://gitlab.freedesktop.org/wayland/weston/-/issues  #
# -Canal #wayland en irc.oftc.net                          #
############################################################

Investigar si se puede hacer simplemente:
sudo -E weston-launch -t /dev/tty7 -u pi

AÑADIR NUEVOS ATAJOS DE TECLADO A WESTON
========================================

Compila e instala el "weston keybinder": es muy sencillo.

git clone --depth 1 https://github.com/tarvi-verro/weston-binder.git
make -j4
sudo make install

Y ahora sólo queda añadir a ~/.config/weston.ini la carga del módulo keybinder que acabas de compilar, así como los atajos que quieras. 

Para cargar el módulo:

[core]
modules=binder.so

Y un atajo de teclado sería por ejemplo:

[keybind]
key=ctrl+alt+t
exec=weston-terminal

NOTA: Si alguna vez el weston keybinder deja de funcionar, puedes añadir key bindings a mano en los sources de weston.
Se definen en: weston/src/shell.c, en la función shell_add_bindings().
Mira un ejemplo aquí:
https://github.com/tarvi-verro/weston-binder/commit/40b3112f221ef3a1c42f536d8047b8565ee3f2d8
(Hay mucho más código del necesario ahí porque tiene que parsear las opciones del .ini, etc.
 Fíjate sólo en binder_add_bindings() y binder_callback_alt(). ).
 
CONSTRUIR UN ESCRITORIO COMPLETO BASADO EN WAYLAND
==================================================

NOTA PREVIA: Mucha de la información viene de aquí: https://github.com/natpen/awesome-wayland

---PARTE 1 - EL COMPOSITOR---

-Elegimos un compositor que sea stacking, no tiling.
Por ahora, Weston es el que instalamos. Pero para el tema de los atajos de teclado nos puede interesar waybox o labwc.
Si insistes en usar Weston, puedes añadir nuevos keyboard shortcuts con esto:
https://github.com/tarvi-verro/weston-binder

---PARTE 2 - EL TOOLKIT---

-Compilamos un toolkit que soporte Wayland.
Básicamente elegimos entre GTK y QT. GTK es más ligero y sencillo de compilar (QT son varios paquetes).

Para compilar GTK3 (la versión más compatible con programas actualmente y que a la vez tiene soporte WAYLAND es GTK3)
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
-Configuramos como:
mkdir b4
cd b4
CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dprint-cloudprint=disabled -Dvulkan=enabled -Dxinerama=disabled -Dintrospection=disabled -Ddemos=false \
-Dbuild-examples=false -Dbuild-tests=false
ninja -j4
sudo ninja install

Para compilar GTK4 sería:
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
mkdir b4
cd b4
CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dvulkan=enabled -Dintrospection=disabled -Ddemos=false -Dbuild-examples=false -Dbuild-tests=false 
ninja -j4
sudo ninja install

---PARTE 3 - LAS APLICACIONES---

-Compilamos un file browser que soporte GTK. Elegimos pcmanfm, que soporta tanto GTK como QT. Otra alternativa sería thunar.
Para compilar PCMANFM:

Empezamos con una dependencia, libfm:
-Bajamos los últimos sources estables de: https://github.com/lxde/libfm/releases

Ahora vamos con PCMANFM en sí:
-Bajamos los últimos sources estables de: https://github.com/lxde/pcmanfm/releases

CAGE, UN COMPOSITOR PARA APLICACIONES EMBEDIDAS
-----------------------------------------------

Bajamos los últimos sources estables de:
https://github.com/Hjdskes/cage/releases

Compilamos con:
mkdir b4
cd b4

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson .. --buildtype=release

ninja -j4
sudo ninja install

Lanzaríamos el programa que queramos así:
-Lo primero, lanzamos el seatd, para loguear al usuario Pi en un asiento y poder lanzar el cage:
sudo seatd -u pi
-Ahora lanzamos el cage y le pasamos el ejecutable que queramos:
cage <nombre_ejecutable>
Y si es con parámetros, usamos -- entre cage y el nombre del ejecutable, así:
cage -- <nombre_ejecutable> <parámetros>

KITTY, UN EMULADOR DE TERMINAL PARA WAYLAND
-------------------------------------------

--Requisito previo: GLFW, que es lo que usa Kitty para dibujar en pantalla.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mcpu=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

make -j4
sudo make install

AHORA VAMOS A POR KITTY EN SÍ...

--Clonamos su repo, configuramos y compilamos:

git clone --depth 1 https://github.com/kovidgoyal/kitty

CFLAGS="-march=armv8-a+crc+simd -mtune=cortex-a72 -ftree-vectorize -pipe -fomit-frame-pointer" \
./configure

make -j4

--Lo lanzamos en modo fullscreen con:
kitty --start-as fullscreen
(NO, no falta ningún guión).

--Para ajustar la fuente, podemos editar su configuración. Para ello, desde dentro de Kitty, hacemos CTRL+SHIFT+F2,
cambiamos lo que sea y guardamos.
De este modo, se nos crea ~/.config/kitty/kitty.conf, que podemos editar luego y cambiar lo que queramos.


