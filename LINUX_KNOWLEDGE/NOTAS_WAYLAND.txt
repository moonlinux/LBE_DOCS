INSTALAR WAYLAND
================

Lo primero: para correr SWAY, WAYBOX, CAGE ... necesitas WAYLAND y WLROOTS, ya que la mayoría de los compositores se basan en WLROOTS.
A su vez, WLROOTS necesita WAYLAND-PROTOCOLS y LIBSEAT.
***LIBSEAT SÓLO ES NECESARIO PARA COMPOSITORES BASADOS EN WLROOTS, POR LO QUE EN WESTON NO HACE FALTA PORQUE WESTON NO ESTÁ BASADO EN WLROOTS.
***LIBSEAT SÓLO ES NECESARIO SI NO TENEMOS CORRIENDO EL SERVICIO "LOGIND" QUE EN SYSTEMD ES "systemd-logind"
   Y QUE EN OTROS INIT DISTINTOS DE SYSTEMD ES "elogind".
   LÓGICAMENTE, EN UN SISTEMA "MINIMAL" DE LOS MIOS, PARA USAR UN COMPOSITOR BASADO EN WLROOTS, LIBSEAT HACE FALTA PORQUE NO TIENES
   NINGÚN SERVICIO DE LOGIN CORRIENDO
***PERO SI VAS A USAR WESTON, NO HACE FALTA LIBSEAT NUNCA!!!

Pero OJO, WESTON NO SE BASA EN WLROOTS. NO NECESITAS WLROOTS PARA WESTON. WESTON ES "STANDALONE". Lo malo de eso, es que WLROOTS tiene
un renderer Vulkan, que desde WESTON no puedes aprovechar por no basarse en WLROOTS.

PARTE 1: WAYLAND EN SÍ (libwayland)
-----------------------------------

Bajamos la última release estable de:
https://wayland.freedesktop.org/releases.html

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddtd_validation=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

PARTE 2: WAYLAND-PROTOCOLS
--------------------------
Bajamos la ultima release estable de:
https://wayland.freedesktop.org/releases.html

Cofiguramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false ..

ninja -j4
sudo ninja install

PARTE 3: WLROOTS (NO NECESARIO PARA WESTON!!)
---------------------------------------------
-Previamente necesitamos KMS/DRM funcionando. Así que deberías ser capaz de ejecutar los tests de SDL2 sobre KMSDR.

LO PRIMERO, SEATD (SÓLO SI NO TENEMOS SYSTEMD!)

-Si no tenemos systemd (sistema "minimal"), o si tenemos systemd sin los servicios "systemd-logind" o "elogind"
(que es lo más normal, porque siempre lo deshabilitas), necesitamos libseat/seatd.
Para instalar libseat:

Clonamos su repo:
git clone --depth 1 https://git.sr.ht/~kennylevinsen/seatd

--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=disabled -Dlibseat-logind=disabled -Dman-pages=disabled ..

ninja -j4
sudo ninja install

--seatd se lanzará, cuando nos haga falta, con:
seatd -u root -l silent &

// BLOQUE PARA DEBIAN 12, QUE YA TIENE UN PAQUETE LIBSEAT, ASÍ QUE ES TODO MÁS SENCILLO:

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev libinput-dev libseat-dev --no-install-recommends
(OJO: Si no estás usando libudev-zero, que es lo que usas en sistemas mínimos, también debes instalar libudev-dev).

// FIN BLOQUE DEBIAN 12

// BLOQUE SÓLO PARA DEBIAN 11, YA QUE NO TIENE EL PAQUETE LIBSEAT

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev --no-install-recommends
(OJO: Si no estás usando libudev-zero, que es lo que usas en sistemas mínimos, debes instalar también libudev-dev).
-Instalamos manualmente la dependencia LIBSEAT, que no está como paquete en DEBIAN 11. Para ello:
--Bajamos los últimos sources estables de aquí: https://git.sr.ht/~kennylevinsen/seatd
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=false ..

ninja -j4
sudo ninja install

-Instalamos manualmente la dependencia LIBINPUT, que la versión que trae DEBIAN 11 es vieja y no nos vale. Para ello:
--Instalamos dependencias previas de LIBINPUT: sudo apt-get install libmtdev-dev
--Bajamos los últimos sources estables de aquí: http://www.freedesktop.org/software/libinput
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibwacom=false -Ddebug-gui=false -Dtests=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

// FIN BLOQUE DEBIAN 11

--Instalamos dependencias previas:
apt-get install glslang-dev glslang-tools
--Actualizamos nuestra versión de libvulkan y libvulkan-dev, ya que WLROOTS necesita una reciente si activamos
el renderer VULKAN, para lo cual:
	--Instalamos el repositorio de backports, que son versiones del siguiente DEBIAN backporteados para el actual:
		echo "deb http://deb.debian.org/debian bullseye-backports main" | sudo tee /etc/apt/sources.list.d/buster-backports.list
		apt-get update
	--Actualizamos nuestra versión de libvulkan (como ves tenemos que especificarle que la pille de backports):
		apt-get -t bullseye-backports install libvulkan1
		apt-get -t bullseye-backports install libvulkan-dev (<---Este probablemente no se te actualize, don't worry.)

-Instalamos WLROOTS en sí. Para ello:

--Bajamos los últimos sources de WLROOTS estables de aquí: https://gitlab.freedesktop.org/wlroots/wlroots/-/releases

--En nuestro compositor (dwl, cage...) buscamo la llamada a wlr_output_set_mode(), y la quitamos.

--Configuramos, compilamos e instalamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=false -Dxwayland=disabled \
-Dbackends=drm,libinput -Drenderers=gles2,vulkan -Dxcb-errors=disabled ..

ninja -j4
sudo ninja install

RECUERDA que WLROORS soporta renderizado con Vulkan, por lo que los renderers basados en WLROOTS (como DWL, SWAY, WAYBOX...) pueden usarlo.
Para ello, lanzaríamos el compositor que queramos con:
WLR_RENDERER=vulkan <compositor>
(OJO!! WESTON no usa WLROOTS)

PARTE 4: WESTON (EL COMPOSITOR DE REFERENCIA, PARA UN DESCRITORIO COMPLETO USA WAYBOX)
--------------------------------------------------------------------------------------

// BLOQUE DEBIAN SIN SYSTEMD

Tenemos que instalar nuestras propias compilaciones de libinput, ya que compila contra UDEV
y en los sistemas sin systemd usamos libudev-zero, compilada por nosotros, por lo que si usamos
el libinput de Debian, falla el linkado de Weston.

Pues eso, compilamos e instalamos libinput:
-Instalamos dependencias previas: apt-get install libmtdev-dev libevdev-dev --no-install-recommends
-Bajamos las últimas estables de aquí:
https://www.freedesktop.org/software/libinput/libinput-1.19.4.tar.xz
-Configuramos y compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false -Dinstall-tests=false -Dlibwacom=false -Ddebug-gui=false ..

ninja -j4
ninja install

// FIN BLOQUE DEBIAN SIN SYSTEMD


// BLOQUE DEBIAN CON SYSTEMD

-Instalamos dependencias previas:
sudo apt-get install libinput-dev --no-install-recommends

// FIN BLOQUE DEBIAN CON SYSTEMD

-Instalamos manualmente la dependencia previa de WESTON, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de aquí:
https://gitlab.freedesktop.org/cairo/cairo/-/releases
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

ninja -h4
sudo ninja install

-Instalamos WESTON en sí:
Bajamos los últimos sources estables de:
https://gitlab.freedesktop.org/wayland/weston/-/tags
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dbackend-headless=false -Dbackend-rdp=false -Dscreenshare=false -Dbackend-x11=false \
-Dxwayland=false -Dremoting=false -Dsystemd=false -Dpipewire=false -Dshell-ivi=false \
-Dcolor-management-lcms=false -Dcolor-management-colord=false -Dlauncher-logind=false -Dtools=terminal -Dwcap-decode=false \
-Dtest-junit-xml=false -Dimage-webp=false -Ddoc=false -Dbackend-drm-screencast-vaapi=false -Ddemo-clients=false ..

ninja -j4
sudo ninja install

// BLOQUE PARA USUARIOS NORMALES NO ROOT
Ahora hacemos setuid-root al ejecutable weston, creamos el grupo weston y añadimos al usuario al grupo weston:
sudo chmod 4755 /usr/local/bin/weston
sudo gropuadd weston
sudo usermod -a -G weston pi
// FIN BLOQUE PARA USUARIOS NORMALES NO ROOT

Ahora creamos ~/.config/weston.ini con este contenido:
(RECUERDA que weston.ini puede estar en cualquier ruta que exportes en $XDG_CONFIG_HOME)
(RECUERDA que puedes ver los modos de vídeo disponibles con: modetest |grep -50 modes
 PERO lo mejor es poner mode=current y así no hay cambio de modo.)
(RECUERDA que si, como en este ejemplo, tienes puesto el cursor-theme llamado adwaita, tienes que instalarlo con:
 apt-get install adwaita-icon-theme).

#
# Contenido de weston.ini
#

[core]
idle-time=0

[shell]
locking=false
binding-modifier=alt
animation=zoom
startup-animation=fade
cursor-theme=adwaita
cursor-size=24
background-image=none
background-color=0xFF555555

[terminal]
font=monospace
font-size=18

[launcher]
icon=/usr/local/share/weston/terminal.png
path=/usr/local/bin/weston-terminal --shell=/bin/bash

[input-method]
path=/usr/local/libexec/weston-keyboard

[output]
name=HDMI-A-1
mode=current

[keyboard]
keymap_layout=es
vt-switching=false

#
# Aquí acaba el contenido de weston.ini
#


// BLOQUE SÓLO PARA DEBIAN CON SYSTEMD (sin systemd, ya se exporta XDG_RUNTIME en el script de inicio /etc/minimal)

Añadimos esto a /etc/profile

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

(OJO: Si estás como root, XDG_RUNTIME_DIR sería directamente /run ya que estando como root no hay login manager.
Y de todos modos esto ya lo exportas en /etc/minimal si estás arrancando tu propio sistema mínimo).

// FIN BLOQUE SÓLO PARA DEBIAN CON SYSTEMD

Ahora lanzamos WESTON:
weston -f '' -l ''
(Lo de -f '' -l '' es para que no mande logs a la consola ni a ningún lado).
(Se sale con Ctrl+Alt+Backspace)

Si queremos que se autoarranque, tenemos dos opciones:

1) FORMA MÁS ELEGANTE: USANDO UN SERVICIO DE SYSTEMD.

ESTO A SU VEZ SE PUEDE HACER DE DOS MANERAS:

1.1) OPCIÓN 1

Añadimos esto a /etc/profile (que se ejecutará al ejecutarse weston,
ya que se loguea como el usuario que le pasamos a weston con la opción -u):

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

Creamos el fichero /etc/systemd/system/weston.service mínimo (ya que lo hacemos todo en el /etc/profile), con el contenido:

# Service to launch Weston on boot, on the TTY specified to weston.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
ExecStart=/usr/bin/sudo -E /usr/local/bin/weston -t /dev/tty7 -u pi

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

1.2) OPCIÓN 2

NO añadimos nada a /etc/profile, pero creamos este fichero /etc/systemd/system/weston.service,
que es mucho más grande porque se hace en él lo que haríamos en el /etc/profile.
Además, si te fijas, se usa openvt y en la otra opción no se usa:

# Service to launch Weston on boot, on the first available tty using openvt
# REMEMBER that the openvt "--console=..." parameter specifies a TTY.
# Don't use a TTY on which you have setup getty autologin, it won't work.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
Environment="XDG_RUNTIME_DIR=/run/user/1000"
ExecStartPre=/usr/bin/sudo /bin/mkdir -p /run/user/1000
ExecStartPre=/usr/bin/sudo /bin/chown pi:pi /run/user/1000
ExecStartPre=/bin/chmod 0700 /run/user/1000
ExecStart=/usr/bin/sudo -E -- /bin/openvt -v -w -s -- su pi -l -c "XDG_RUNTIME_DIR=/run/user/1000 /usr/local/bin/weston -- $OPTARGS 2>~/.weston-errors"

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

FIN DE OPCIONES: DE AQUÍ EN ADELANTE ES TODO COMÚN.

Ahora hacemos sudo systemctl enable weston.service (lo que nos creará un symlink en /etc/systemd/system/multiuser.want/, ya que
es necesario para el target "multiuser").

OJO!! NO es compatible con tener autologin en la TTY en la que lanzamos el WESTON. Aunque como nosotros lo lanzamos en TTY7 no hay problema.
PERO por ejemplo, si lo lanzásemos en la TTY1 o TTY2, tendríamos que deshabilitar el autologin en la TTY1 o en la TTY2,
ya que NO ES COMPATIBLE con este método y el servicio falla si lo tienes activo.
sudo systemctl disable getty@tty1
sudo systemctl disable getty@tty2

RECUERDA que si te quedas sin acceso al sistema porque WESTON no arranca y no tienes manera de restablecer el autologin desde la propia Pi,
puedes restablecer los servicios de autologin a mano creando sendos links simbólicos en el directorio del target multiuser, así:
sudo ln -s getty@tty1.service.d multi-user.target.wants/getty@tty1.service
sudo ln -s getty@tty2.service.d multi-user.target.wants/getty@tty2.service
(En realidad, lo único que hace systemctl enable o disable es crear o borrar estos links simbólicos).

2) FORMA MÁS CHAPUCERA: Que se autoarranque al hacerse nuestro típco autologin en la TTY1 (mirar cómo hacer el autologin en la TTY1 y la TTY2),
simplemente tenemos que añadir esto al fichero ~/.profile del usuario para el cual está hecho el autologin:

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

# Start Weston automatically.
if [[ -z "$DISPLAY" ]] && [[ $(tty) = /dev/tty1 ]]; then
	weston
	logout
fi

############################################################
# SI NECESITAS AYUDA CON WAYLAND:                          #
# -https://gitlab.freedesktop.org/wayland/weston/-/issues  #
# -Canal #wayland en irc.oftc.net                          #
############################################################

Investigar si se puede hacer simplemente:
sudo -E weston -t /dev/tty7 -u pi

QUITAR ERRORES DE WESTON
========================

--Para quitar los errores:
	could not load cursor 'dnd-move'
	could not load cursor 'dnd-copy'

	Instalamos:
	apt-get adwaita-icon-theme --no-install-recommends

	Y añadimos en .config/weston.ini, en la sección [shell]:

	[shell]
	cursor-theme=adwaita
(Se podría usar otro tema más ligero, pero no lo conozco).

AÑADIR NUEVOS ATAJOS DE TECLADO A WESTON
========================================

TIENES DOS OPCIONES:

1) RECOMENDADO: Añadir los atajos a mano:
Para ello, editamos desktop-shell/shell.c y:

-Añadimos #include <fcntl.h> a los includes del principio.
-Añadimos funciones (justo encima de la función shell_add_bindings(), si quieres):

/* Process executed via keybind failed. status is the exit value. */
static void 
process_cleanup(struct weston_process *process, int status)
{
        free(process);
}

/**
 * Much like system(3) but doesn't wait for exit and outputs to /dev/null.
 */
static void
system_nowait(const char *file, char *const argv[])
{
	int pid = fork();

	if (pid)
		return;

	int fd = open("/dev/null", O_WRONLY);

	dup2(fd, 1);
	dup2(fd, 2);

	close(fd);

	execvp(file, argv);
	exit(1);
}

static void 
terminal_binding_callback(struct weston_keyboard *keyboard,
                         const struct timespec *time, uint32_t key, 
                         void *data)
{
        struct weston_compositor *compositor = data;

        pid_t spawn = system_nowait("weston-terminal",
                                   (char * const[]) {"weston-terminal", "--shell=/bin/bash", NULL, NULL});

        if (spawn == -1) {
                weston_log("Failed spawning process %s\n", (char *) data);
                return;
        }    

        struct weston_process *wp = malloc(sizeof(*wp));;
        wp->pid = spawn;
        wp->cleanup = process_cleanup;

        wet_watch_process(compositor, wp);
}

-En la función shell_add_bindings(), añadimos (debajo de la última llamada a "weston_compositor_add_key_binding()", si quieres):

        /* Add binding for launching terminal with CTRL + ALT + T */
        weston_compositor_add_key_binding(ec, KEY_T, MODIFIER_CTRL | MODIFIER_ALT,
                                          terminal_binding_callback, ec);
                                          
Y YA ESTÁ. Como ves, podemos añadir todos los atajos que queramos muy fácilmente, añadiéndolos como nuevas llamadas a
weston_compositor_add_key_binding().

FUENTE: Sacado del código del "weston keybinder", cuyo primer commit está aquí:
https://github.com/tarvi-verro/weston-binder/commit/40b3112f221ef3a1c42f536d8047b8565ee3f2d8
(Hay mucho más código del necesario ahí porque tiene que parsear las opciones del .ini, etc.
 Fíjate sólo en binder_add_bindings() y binder_callback_ctrl_alt(). ).
 
2) Compila e instala el "weston keybinder": 

git clone --depth 1 https://github.com/tarvi-verro/weston-binder.git
make -j4
cp binder.so /usr/local/lib/aarch64-linux-gnu/weston/

Y ahora sólo queda añadir a ~/.config/weston.ini la carga del módulo keybinder que acabas de compilar, así como los atajos que quieras. 

Para cargar el módulo:

[core]
modules=binder.so

Y un atajo de teclado sería por ejemplo:

[keybind]
key=ctrl+alt+t
exec=weston-terminal --shell=/bin/bash

CONSTRUIR UN ESCRITORIO COMPLETO BASADO EN WAYLAND
==================================================

NOTA PREVIA: Mucha de la información viene de aquí: https://github.com/natpen/awesome-wayland

---PARTE 1 - EL COMPOSITOR---

-Elegimos un compositor que sea stacking, no tiling.
Por ahora, Weston es el que instalamos. Pero para el tema de los atajos de teclado nos puede interesar waybox o labwc.
Si insistes en usar Weston, puedes añadir nuevos keyboard shortcuts con esto:
https://github.com/tarvi-verro/weston-binder

---PARTE 2 - EL TOOLKIT---

-Compilamos un toolkit que soporte Wayland.
Básicamente elegimos entre GTK y QT. GTK es más ligero y sencillo de compilar (QT son varios paquetes).

Para compilar GTK3 (la versión más compatible con programas actualmente y que a la vez tiene soporte WAYLAND es GTK3)
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
-Configuramos como:
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dprint-cloudprint=disabled -Dvulkan=enabled -Dxinerama=disabled -Dintrospection=disabled -Ddemos=false \
-Dbuild-examples=false -Dbuild-tests=false
ninja -j4
sudo ninja install

Para compilar GTK4 sería:
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dvulkan=enabled -Dintrospection=disabled -Ddemos=false -Dbuild-examples=false -Dbuild-tests=false 
ninja -j4
sudo ninja install

---PARTE 3 - LAS APLICACIONES---

-Compilamos un file browser que soporte GTK. Elegimos pcmanfm, que soporta tanto GTK como QT. Otra alternativa sería thunar.
Para compilar PCMANFM:

Empezamos con una dependencia, libfm:
-Bajamos los últimos sources estables de: https://github.com/lxde/libfm/releases

Ahora vamos con PCMANFM en sí:
-Bajamos los últimos sources estables de: https://github.com/lxde/pcmanfm/releases

DWL, EL COMPOSITOR DE ESCRITORIO BASADO EN WLROOTS MÁS BÁSICO QUE HAY
=====================================================================

Clonamos su repo:

git clone --depth 1 https://github.com/djpohly/dwl.git

Compilamos con:
CFLAGS="-O2 -march=native -mtune=native" \
CXXFLAGS="-O2 -march=native -mtune=native" \
make -j4

PARA EJECUTARLO SIN SYSTEMD:
Necesitamos seatd instalado (Se explica en este mismo documento más arriba).
Lanzaríamos seatd como daemon y justo a continuación dlw, así:

seatd -u root -l silent &
dwl

Se sale de dwl con ALT+SHIFT+Q

Si al compilar da un error de que no encuentra "wlr/backend/libinput.h" es porque compilaste WLROOTS sin pasarle libinput
a -Dbackends. Deberías pasarle tanto "drm" como "libinput", así: -Dbackends=drm,libinput.
Lo tienes en las instrucciones de compilación de WLROOTS.

Para que no te cambie la resolución a la resolución preferida del monitor, usa el parche monitor-config de aquí:
https://github.com/djpohly/dwl/wiki/Patches
Te lo bajas y haces: patch -p1 < monfig.patch
(Si falla, entra en el discord de DWL y díselo a Palanix, que es el encargao).

Para quitar el borde rojo cuando la ventana está activa, edita config.h y en "focuscolor" quita la componente roja.

TINYWL+, UN COMPOSITOR BASADO EN TINYWL PERO CON MÁS FUNCIONES
==============================================================

https://cppdig.com/c/a-simple-stacking-wayland-compositor-based-on-tinywl

CAGE, UN COMPOSITOR PARA APLICACIONES EMBEDIDAS
===============================================

Bajamos los últimos sources estables de:
https://github.com/Hjdskes/cage/releases

Compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. --buildtype=release

ninja -j4
sudo ninja install

Lanzaríamos el programa que queramos así:
-Lo primero, lanzamos el seatd, para loguear al usuario Pi en un asiento y poder lanzar el cage:
sudo seatd -u pi &
-Ahora lanzamos el cage y le pasamos el ejecutable que queramos:
cage <nombre_ejecutable>
Y si es con parámetros, usamos -- entre cage y el nombre del ejecutable, así:
cage -- <nombre_ejecutable> <parámetros>

FOOT, UN EMULADOR DE TERMINAL PARA WAYLAND
==========================================

Instalamos dependencias previas:
apt-get install libtllist-dev --no-install-recommends

clonamos su repo:
git clone --depth 1 https://codeberg.org/dnkl/foot.git

Configuramos y compilamos con:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddocs=disabled -Dgrapheme-clustering=disabled -Dtests=false -Dime=false ..

ninja -j4
ninja install

Creamos ~/config/foot/foot.ini con este contenido:
(OJO: Puedes tener foot/foot.ini donde quieras si exportas un valor de $XDG_CONFIG_HOME).

shell=bash
term=foot

initial-window-size-chars=90x20

[bell]
urgent=no
notify=no

KITTY, UN EMULADOR DE TERMINAL PARA WAYLAND
-------------------------------------------

--Requisito previo: GLFW, que es lo que usa Kitty para dibujar en pantalla.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

AHORA VAMOS A POR KITTY EN SÍ...

--Clonamos su repo, configuramos y compilamos:

git clone --depth 1 https://github.com/kovidgoyal/kitty

CFLAGS="-march=native -mtune=native" \
./configure

make -j4

--Lo lanzamos en modo fullscreen con:
kitty --start-as fullscreen
(NO, no falta ningún guión).

--Para ajustar la fuente, podemos editar su configuración. Para ello, desde dentro de Kitty, hacemos CTRL+SHIFT+F2,
cambiamos lo que sea y guardamos.
De este modo, se nos crea ~/.config/kitty/kitty.conf, que podemos editar luego y cambiar lo que queramos.

DEBUGEAR PROGRAMAS SOBRE WAYLAND POR SSH
========================================

LO PRIMERO ES ENTENDER cómo va esto.
Los programas que corren en Wayland necesitan XDG_RUNTIME_DIR (que en nuestro sistema mínimo apunta a /run, almacenado en RAM),
para así poder encontrar el fichero "wayland-0", o "wayland-1" o lo que sea, que estará en XDG_RUNTIME_DIR cuando haya una sesión wayland en marcha.
Y del otro lado, el compositor debe exportar WAYLAND_DISPLAY=wayland-0, WAYLAND_DISPLAY=wayland-1...

Vamos, que tenemos que tener seteadas correctamente las variables de entorno XDG_RUNTIME_DIR y WAYLAND_DISPLAY.

///BLOQUE WESTON///

Si usamos WESTON, es posible que los programas de Wayland no necesiten WAYLAND_DISPLAY, con:

export XDG_RUNTIME_DIR=/run # (Sólo si no estamos usando systemd, y sólo si hemos exportado XDG_RUNTIME_DIR=/run en /etc/minimal).
weston -S wayland-0

Y de ese modo ya no hace falta setear WAYLAND_DISPLAY. PERO sólo vale para Weston, con otros compositors sí hace falta.

///BLOQUE RESTO DE COMPOSITORES///

--Para XDG_RUNTIME_DIR--

Miramos qué valor tiene XDG_RUNTIME_DIR en la máquina donde corre WAYLAND:

env | grep XDG_RUNTIME_DIR

...Y exportamos eso en la sesión SSH.

Por ejemplo, si XDG_RUNTIME_DIR tiene el valor /run: 

export XDG_RUNTIME_DIR=/run
<programa>

O bien

WAYLAND_DISPLAY=wayland-0 <programa>

--Para WAYLAND_DISPLAY-- 

Miramos qué valor tiene WAYLAND_DISPLAY en la máquina donde corre WAYLAND:

env | grep WAYLAND_DISPLAY

...Y exportamos eso en la sesión SSH.

Por ejemplo, si WAYLAND_DISPLAY tiene el valor wayland-0: 

export WAYLAND_DISPLAY=wayland-0
<programa>

O bien

WAYLAND_DISPLAY=wayland-0 <programa>

(Normalmente, SSH usaría PAM y pillaría las mismas variables de entorno para todas las sesiones de un usuario, pero PAM
depende de SystemD y no usamos SystemD).

HABILITAR LOGS DE DEBUGGING DE DRM
==================================

echo 0x19F | sudo tee /sys/module/drm/parameters/debug

dmesg -C

AYUDA WLROOTS
=============

irc.libera.chat, canal #sway-devel
irc.oftc.net, canal #dri-devel

DEBUGUEAR O INVESTIGAR PROBLEMAS DE WLROOTS
===========================================

-Activamos el modo debug del driver DRM del kernel, con 
echo 0x19F | sudo tee /sys/module/drm/parameters/debug
-Con GDB, nos ponemos en atomic_commit(), y justo antes de que se ejecute drmAtomicCommit(), hacemos un "dmesg -C" para limpiar dmesg,
ejecutamos drmAtomicCommit(), y ejecutamos dmesg. Vemos qué propiedades se van a modificar: son las de las líneas en que pone: "Added..."
-Si ahí no vemos errores ni propiedades problemáticas, volvemos a iniciar el compositor con GDB y nos vamos a atomic_crtc_commit(), y
vamos viendo cúales de las llamadas de atomic_add() se ejecutan entre atomic_begin() y atomic_finish(), y ahí ya vemos clarísimamente qué
propiedades del CONNECTOR o del CRTC se van a modificar en la siguiente llamada a atomic_commit(). Porque recuerda que todas estas funciones
están double-buffered, es decir, no tienen efectos hasta que haya una llamada a atomic_commit().


* Un problema muy típico es que se modifiquen propiedades que necesitan full modeset sin que se esté haciendo un full modeset,
es decir, sin que se esté activando el flag DRM_MODE_ATOMIC_ALLOW_MODESET.
Las propiedades que necesitan un full modeset son:
-Que se cambie el CRTC de un conector
-Que se cambie el modo de vídeo de un CRTC
-Que se cambie el estado entre ACIVO/INACTIVO de un CRTC
-...Y que hayamos averiguado por las malas, que se cambie el max_bpc de un CONNECTOR
