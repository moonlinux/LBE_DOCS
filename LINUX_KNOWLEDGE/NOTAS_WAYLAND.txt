INSTALAR WAYLAND
================

Lo primero: para correr WAYBOX, CAGE, o cualquier otro compositor, necesitas WAYLAND y WLROOTS.
A su vez, WLROOTS necesita WAYLAND-PROTOCOLS y LIBSEAT

PARTE 1: WAYLAND EN SÍ (libwayland)
-----------------------------------

Bajamos la última release estable de:
https://wayland.freedesktop.org/releases.html

Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Ddtd_validation=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

PARTE 2: WAYLAND-PROTOCOLS
--------------------------
Bajamos la ultima release estable de:
https://wayland.freedesktop.org/releases.html

Cofiguramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false ..

ninja -j4
sudo ninja install

PARTE 3: WLROOTS
----------------
-Previamente necesitamos KMS/DRM funcionando. Así que deberías ser capaz de ejecutar los tests de SDL2 sobre KMSDR.

// BLOQUE PARA DEBIAN MINIMAL (DEBIAN SIN SYSTEMD)

Como no tenemos systemd, para libseat/seatd tenemos que usar el seatd de DEVUAN, ya que libseat normal requiere systemd corriendo
para funcionar.

Clonamos su repo:
git clone --depth 1 https://git.devuan.org/devuan/seatd.git

--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=disabled -Dlogind=disabled -Dman-pages=disabled ..

ninja -j4
sudo ninja install

// FIN BLOQUE PARA DEBIAN MINIMAL (DEBIAN SIN SYSTEMD)

// BLOQUE PARA DEBIAN 12, QUE YA TIENE UN PAQUETE LIBSEAT, ASÍ QUE ES TODO MÁS SENCILLO:

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev libinput-dev libseat-dev --no-install-recommends
(OJO: Si no estás usando libudev-zero, que es lo que usas en sistemas mínimos, también debes instalar libudev-dev).

// FIN BLOQUE DEBIAN 12

// BLOQUE SÓLO PARA DEBIAN 11, YA QUE NO TIENE EL PAQUETE LIBSEAT

-Instalamos dependencias previas: sudo apt-get install libpixman-1-dev libxkbcommon-dev --no-install-recommends
(OJO: Si no estás usando libudev-zero, que es lo que usas en sistemas mínimos, debes instalar también libudev-dev).
-Instalamos manualmente la dependencia LIBSEAT, que no está como paquete en DEBIAN 11. Para ello:
--Bajamos los últimos sources estables de aquí: https://git.sr.ht/~kennylevinsen/seatd
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=false ..

ninja -j4
sudo ninja install

-Instalamos manualmente la dependencia LIBINPUT, que la versión que trae DEBIAN 11 es vieja y no nos vale. Para ello:
--Instalamos dependencias previas de LIBINPUT: sudo apt-get install libmtdev-dev
--Bajamos los últimos sources estables de aquí: http://www.freedesktop.org/software/libinput
--Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dlibwacom=false -Ddebug-gui=false -Dtests=false -Ddocumentation=false ..

ninja -j4
sudo ninja install

// FIN BLOQUE DEBIAN 11

--Instalamos dependencias previas:
apt-get install glslang-dev glslang-tools
--Actualizamos nuestra versión de libvulkan y libvulkan-dev, ya que WLROOT necesita una reciente si activamos
el renderer VULKAN, para lo cual:
	--Instalamos el repositorio de backports, que son versiones del siguiente DEBIAN backporteados para el actual:
		echo "deb http://deb.debian.org/debian bullseye-backports main" | sudo tee /etc/apt/sources.list.d/buster-backports.list
		apt-get update
	--Actualizamos nuestra versión de libvulkan (como ves tenemos que especificarle que la pille de backports):
		apt-get -t bullseye-backports install libvulkan1
		apt-get -t bullseye-backports install libvulkan-dev (<---Este probablemente no se te actualize, don't worry.)
-Instalamos WLROOTS en sí. Para ello:
--Bajamos los últimos sources de WLROOTS estables de aquí: https://gitlab.freedesktop.org/wlroots/wlroots/-/releases
--Configuramos, compilamos e instalamos:

mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dexamples=false -Dxwayland=disabled \
-Dbackends=drm -Drenderers=gles2,vulkan -Dxcb-errors=disabled ..

ninja -j4
sudo ninja install

PARTE 4: WESTON (EL COMPOSITOR DE REFERENCIA, PARA UN DESCRITORIO COMPLETO USA WAYBOX)
--------------------------------------------------------------------------------------

// BLOQUE DEBIAN SIN SYSTEMD

Tenemos que instalar nuestras propias compilaciones de libinput, ya que compila contra UDEV
y en los sistemas sin systemd usamos libudev-zero, compilada por nosotros, por lo que si usamos
el libinput de Debian, falla el linkado de Weston.

Pues eso, compilamos e instalamos libinput:
-Instalamos dependencias previas: apt-get install libmtdev-dev libevdev-dev --no-install-recommends
-Bajamos las últimas estables de aquí:
https://www.freedesktop.org/software/libinput/libinput-1.19.4.tar.xz
-Configuramos y compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dtests=false -Dinstall-tests=false -Dlibwacom=false -Ddebug-gui=false ..

ninja -j4
ninja install

// FIN BLOQUE DEBIAN SIN SYSTEMD


// BLOQUE DEBIAN CON SYSTEMD

-Instalamos dependencias previas:
sudo apt-get install libinput-dev --no-install-recommends

// FIN BLOQUE DEBIAN CON SYSTEMD

-Instalamos manualmente la dependencia previa de WESTON, CAIRO, ya que el paquete de DEBIAN viene con dependencias de X11:
--Instalamos dependencias previas: apt-get install libfontconfig-dev
--Bajamos los últimos sources estables de aquí:
https://gitlab.freedesktop.org/cairo/cairo/-/releases
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release ..

ninja -h4
sudo ninja install

-Instalamos WESTON en sí:
Bajamos los últimos sources estables de:
https://gitlab.freedesktop.org/wayland/weston/-/tags
Configuramos, compilamos e instalamos:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson -Dbuildtype=release -Dbackend-headless=false -Dbackend-rdp=false -Dscreenshare=false -Dbackend-x11=false \
-Dxwayland=false -Dremoting=false -Dsystemd=false -Dpipewire=false -Dshell-ivi=false \
-Dcolor-management-lcms=false -Dcolor-management-colord=false -Dlauncher-logind=false -Dtools=terminal -Dwcap-decode=false \
-Dtest-junit-xml=false -Dimage-webp=false -Ddoc=false -Dbackend-drm-screencast-vaapi=false -Ddemo-clients=false ..

ninja -j4
sudo ninja install

// BLOQUE PARA USUARIOS NORMALES NO ROOT
Ahora hacemos setuid-root al ejecutable weston, creamos el grupo weston y añadimos al usuario al grupo weston:
sudo chmod 4755 /usr/local/bin/weston
sudo gropuadd weston
sudo usermod -a -G weston pi
// FIN BLOQUE PARA USUARIOS NORMALES NO ROOT

Ahora creamos ~/.config/weston.ini con este contenido:
(RECUERDA que puedes ver los modos de vídeo disponibles con: modetest |grep -50 modes
 PERO lo mejor es poner mode=current y así no hay cambio de modo.)

#
# Contenido de weston.ini
#

[core]
idle-time=0

[shell]
locking=false
animation=zoom
startup-animation=fade

[terminal]
font=monospace
font-size=18

[launcher]
icon=/usr/local/share/weston/terminal.png
path=/usr/local/bin/weston-terminal

[input-method]
path=/usr/local/libexec/weston-keyboard

[output]
name=HDMI-A-1
mode=current

[keyboard]
keymap_layout=es
vt-switching=false

#
# Aquí acaba el contenido de weston.ini
#


// BLOQUE SÓLO PARA DEBIAN CON SYSTEMD (sin systemd, ya se exporta XDG_RUNTIME en el script de inicio /etc/minimal)

Añadimos esto a /etc/profile

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

(OJO: Si estás como root, XDG_RUNTIME_DIR sería directamente /run ya que estando como root no hay login manager.
Y de todos modos esto ya lo exportas en /etc/minimal si estás arrancando tu propio sistema mínimo).

// FIN BLOQUE SÓLO PARA DEBIAN CON SYSTEMD

Ahora lanzamos WESTON:
weston -f '' -l ''
(Lo de -f '' -l '' es para que no mande logs a la consola ni a ningún lado).
(Se sale con Ctrl+Alt+Backspace)

Si queremos que se autoarranque, tenemos dos opciones:

1) FORMA MÁS ELEGANTE: USANDO UN SERVICIO DE SYSTEMD.

ESTO A SU VEZ SE PUEDE HACER DE DOS MANERAS:

1.1) OPCIÓN 1

Añadimos esto a /etc/profile (que se ejecutará al ejecutarse weston,
ya que se loguea como el usuario que le pasamos a weston con la opción -u):

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

Creamos el fichero /etc/systemd/system/weston.service mínimo (ya que lo hacemos todo en el /etc/profile), con el contenido:

# Service to launch Weston on boot, on the TTY specified to weston.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
ExecStart=/usr/bin/sudo -E /usr/local/bin/weston -t /dev/tty7 -u pi

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

1.2) OPCIÓN 2

NO añadimos nada a /etc/profile, pero creamos este fichero /etc/systemd/system/weston.service,
que es mucho más grande porque se hace en él lo que haríamos en el /etc/profile.
Además, si te fijas, se usa openvt y en la otra opción no se usa:

# Service to launch Weston on boot, on the first available tty using openvt
# REMEMBER that the openvt "--console=..." parameter specifies a TTY.
# Don't use a TTY on which you have setup getty autologin, it won't work.

[Unit]
Description=Weston Wayland compositor startup
RequiresMountsFor=/run

[Service]
User=pi
EnvironmentFile=-/etc/default/weston
Environment="XDG_RUNTIME_DIR=/run/user/1000"
ExecStartPre=/usr/bin/sudo /bin/mkdir -p /run/user/1000
ExecStartPre=/usr/bin/sudo /bin/chown pi:pi /run/user/1000
ExecStartPre=/bin/chmod 0700 /run/user/1000
ExecStart=/usr/bin/sudo -E -- /bin/openvt -v -w -s -- su pi -l -c "XDG_RUNTIME_DIR=/run/user/1000 /usr/local/bin/weston -- $OPTARGS 2>~/.weston-errors"

# This is like a 'cd' for the service so the terminal emulator starts there.
WorkingDirectory=/home/pi

# These are so Weston restarts an unlimited number of times when we close it.
Restart=always
StartLimitIntervalSec=0
StartLimitBurst=0

# Or, if you prefer, comment out the previous block and uncomment this one
# so system reboots after you close Weston via CTRL+ALT+BACKSPACE.
# ExecStopPost=/usr/bin/sudo -E /sbin/reboot

[Install]
WantedBy=multi-user.target

# Service file ends here.

FIN DE OPCIONES: DE AQUÍ EN ADELANTE ES TODO COMÚN.

Ahora hacemos sudo systemctl enable weston.service (lo que nos creará un symlink en /etc/systemd/system/multiuser.want/, ya que
es necesario para el target "multiuser").

OJO!! NO es compatible con tener autologin en la TTY en la que lanzamos el WESTON. Aunque como nosotros lo lanzamos en TTY7 no hay problema.
PERO por ejemplo, si lo lanzásemos en la TTY1 o TTY2, tendríamos que deshabilitar el autologin en la TTY1 o en la TTY2,
ya que NO ES COMPATIBLE con este método y el servicio falla si lo tienes activo.
sudo systemctl disable getty@tty1
sudo systemctl disable getty@tty2

RECUERDA que si te quedas sin acceso al sistema porque WESTON no arranca y no tienes manera de restablecer el autologin desde la propia Pi,
puedes restablecer los servicios de autologin a mano creando sendos links simbólicos en el directorio del target multiuser, así:
sudo ln -s getty@tty1.service.d multi-user.target.wants/getty@tty1.service
sudo ln -s getty@tty2.service.d multi-user.target.wants/getty@tty2.service
(En realidad, lo único que hace systemctl enable o disable es crear o borrar estos links simbólicos).

2) FORMA MÁS CHAPUCERA: Que se autoarranque al hacerse nuestro típco autologin en la TTY1 (mirar cómo hacer el autologin en la TTY1 y la TTY2),
simplemente tenemos que añadir esto al fichero ~/.profile del usuario para el cual está hecho el autologin:

# Prepare the runtime dir if we haven't done so yet.
if test -z "${XDG_RUNTIME_DIR}"; then
    export XDG_RUNTIME_DIR=/run/user/1000
    if ! test -d "${XDG_RUNTIME_DIR}"; then
        sudo mkdir -p "${XDG_RUNTIME_DIR}"
        sudo chown pi:pi "${XDG_RUNTIME_DIR}"
        chmod 0700 "${XDG_RUNTIME_DIR}"
    fi  
fi

# Start Weston automatically.
if [[ -z "$DISPLAY" ]] && [[ $(tty) = /dev/tty1 ]]; then
	weston
	logout
fi

############################################################
# SI NECESITAS AYUDA CON WAYLAND:                          #
# -https://gitlab.freedesktop.org/wayland/weston/-/issues  #
# -Canal #wayland en irc.oftc.net                          #
############################################################

Investigar si se puede hacer simplemente:
sudo -E weston -t /dev/tty7 -u pi

AÑADIR NUEVOS ATAJOS DE TECLADO A WESTON
========================================

Compila e instala el "weston keybinder": es muy sencillo.

git clone --depth 1 https://github.com/tarvi-verro/weston-binder.git
make -j4
sudo make install

Y ahora sólo queda añadir a ~/.config/weston.ini la carga del módulo keybinder que acabas de compilar, así como los atajos que quieras. 

Para cargar el módulo:

[core]
modules=binder.so

Y un atajo de teclado sería por ejemplo:

[keybind]
key=ctrl+alt+t
exec=weston-terminal

NOTA: Si alguna vez el weston keybinder deja de funcionar, puedes añadir key bindings a mano en los sources de weston.
Se definen en: weston/src/shell.c, en la función shell_add_bindings().
Mira un ejemplo aquí:
https://github.com/tarvi-verro/weston-binder/commit/40b3112f221ef3a1c42f536d8047b8565ee3f2d8
(Hay mucho más código del necesario ahí porque tiene que parsear las opciones del .ini, etc.
 Fíjate sólo en binder_add_bindings() y binder_callback_alt(). ).
 
CONSTRUIR UN ESCRITORIO COMPLETO BASADO EN WAYLAND
==================================================

NOTA PREVIA: Mucha de la información viene de aquí: https://github.com/natpen/awesome-wayland

---PARTE 1 - EL COMPOSITOR---

-Elegimos un compositor que sea stacking, no tiling.
Por ahora, Weston es el que instalamos. Pero para el tema de los atajos de teclado nos puede interesar waybox o labwc.
Si insistes en usar Weston, puedes añadir nuevos keyboard shortcuts con esto:
https://github.com/tarvi-verro/weston-binder

---PARTE 2 - EL TOOLKIT---

-Compilamos un toolkit que soporte Wayland.
Básicamente elegimos entre GTK y QT. GTK es más ligero y sencillo de compilar (QT son varios paquetes).

Para compilar GTK3 (la versión más compatible con programas actualmente y que a la vez tiene soporte WAYLAND es GTK3)
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
-Configuramos como:
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dprint-cloudprint=disabled -Dvulkan=enabled -Dxinerama=disabled -Dintrospection=disabled -Ddemos=false \
-Dbuild-examples=false -Dbuild-tests=false
ninja -j4
sudo ninja install

Para compilar GTK4 sería:
-Bajamos los últimos sources estables de: https://download.gnome.org/sources/gtk/
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. -Dbuildtype=release \
-Dwayland-backend=true -Dx11-backend=false -Dmedia-ffmpeg=disabled -Dmedia-gstreamer=disabled -Dprint-cups=disabled \
-Dvulkan=enabled -Dintrospection=disabled -Ddemos=false -Dbuild-examples=false -Dbuild-tests=false 
ninja -j4
sudo ninja install

---PARTE 3 - LAS APLICACIONES---

-Compilamos un file browser que soporte GTK. Elegimos pcmanfm, que soporta tanto GTK como QT. Otra alternativa sería thunar.
Para compilar PCMANFM:

Empezamos con una dependencia, libfm:
-Bajamos los últimos sources estables de: https://github.com/lxde/libfm/releases

Ahora vamos con PCMANFM en sí:
-Bajamos los últimos sources estables de: https://github.com/lxde/pcmanfm/releases

CAGE, UN COMPOSITOR PARA APLICACIONES EMBEDIDAS
-----------------------------------------------

Bajamos los últimos sources estables de:
https://github.com/Hjdskes/cage/releases

Compilamos con:
mkdir b4
cd b4

CFLAGS="-march=native -mtune=native" \
CXXFLAGS="-march=native -mtune=native" \
meson .. --buildtype=release

ninja -j4
sudo ninja install

Lanzaríamos el programa que queramos así:
-Lo primero, lanzamos el seatd, para loguear al usuario Pi en un asiento y poder lanzar el cage:
sudo seatd -u pi
-Ahora lanzamos el cage y le pasamos el ejecutable que queramos:
cage <nombre_ejecutable>
Y si es con parámetros, usamos -- entre cage y el nombre del ejecutable, así:
cage -- <nombre_ejecutable> <parámetros>

KITTY, UN EMULADOR DE TERMINAL PARA WAYLAND
-------------------------------------------

--Requisito previo: GLFW, que es lo que usa Kitty para dibujar en pantalla.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native"

make -j4
sudo make install

AHORA VAMOS A POR KITTY EN SÍ...

--Clonamos su repo, configuramos y compilamos:

git clone --depth 1 https://github.com/kovidgoyal/kitty

CFLAGS="-march=native -mtune=native" \
./configure

make -j4

--Lo lanzamos en modo fullscreen con:
kitty --start-as fullscreen
(NO, no falta ningún guión).

--Para ajustar la fuente, podemos editar su configuración. Para ello, desde dentro de Kitty, hacemos CTRL+SHIFT+F2,
cambiamos lo que sea y guardamos.
De este modo, se nos crea ~/.config/kitty/kitty.conf, que podemos editar luego y cambiar lo que queramos.


