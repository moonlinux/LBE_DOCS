============================================================================================================================================
LANZAR programas en sus propias CPUs (realtime, nada más puede ejecutarse ahí: garantia total probada con uso masivo de CPU
de housekeeping simultáneo)
============================================================================================================================================

HABIENDO AISLADO LAS CPUs DEL 1 al 3 CON "isolcpus=1-3 nohz_full=1-3" EN CMDLINE.TXT: 
-Para lanzar algo no multithread:
taskset -c 3 ./retroarch
-Para lanzar algo MUY multithread (y que por tanto puede aprovechar varios cores) como el ore swanstation:
chrt -f 80 taskset -c 1-3 ./gzdoom
CUIDADO con el -f 99: si se te cuelgan cosas bájalo a 80, a 50... 80 va bien y es lo que uso ahora.
Con la otra política de tiempo real (SCHED_RR, que se usa pasando -r en lugar de -f pero que nos conviene menos porque reparte
rodajas de tiempo de manera continua y nos conviene más que los threads pillen la CPU y no la suelten hasta que acaben,
es decir, SCHED_FIFO, que es lo que usamos con -f), pasar -r 99 es un peligro y hay cuelgues.

******Establecer una variable de entorno globalmente en el arranque*****************************************************

Aunque hasta ahora lo has hecho de las más peregrinas maneras, el modo "correcto" es en /etc/profile
Basta con poner "export, el nombre de la variable y el valor. Si no pones "export", aparece con echo pero no funciona.
export SDL_VIDEO_DOUBLE_BUFFER=1
Luego puedes comprobarlo con echo $<nombre_variable>, en plan:
echo $SDL_VIDEO_DOUBLE_BUFFER

*******Visualizar los scancodes de las teclas desde la consola TTY*******************************************************

Con el comando showkeys

******IMPRIMIR DESDE UN MAKEFILE*****************************************************************************************

Se hace simplemente con:
@echo "hola mundo!"

PERO OJO: Si te da un error de "missing separator" métele un tabulador delante.

******Hacer que se lean los diagnostics del bootloader de la Raspberry Pi 4 incluso cuando arranca correctamente*******

Editamos los parámetros de configuración del bootloader con:
rpi-eeprom-config --edit

Y añadimos ahí:
HDMI_DELAY=0

Más info sobre parámetros del bootloader aquí:
https://gitee.com/jikexianfeng/documentation/blob/master/hardware/raspberrypi/bcm2711_bootloader_config.md#/jikexianfeng/documentation/blob/master/hardware/raspberrypi/boot_diagnostics.md

******Conectar a una red WIFI desde la Raspberry PI usando el WIFI interno*********************************************

PUEDE QUE NECESITES BAJAR MANUALMENTE EL FIRMWARE DEL WIFI SI AL HACER MODPROBE AL brcmfmac NO TE CREA EL INTERFACE WLAN0.
Si es así, tienes que bajarte los archivos:
brcmfmac43430-sdio.bin
brcmfmac43430-sdio.txt
Que están en:
https://github.com/RPi-Distro/firmware-nonfree/blob/master/brcm
Y meterlos en:
/lib/firmware/brcm/

Instalamos wpasupplicant así:
sudo apt-get install wpasupplicant --no-install-recommends

AHORA VAMOS A POR EL SCRIPT PARA LEVANTAR LA RED:

Lo primero es cargar el módulo del kernel que hace falta:
sudo modprobe brcmfmac

Ahora levantamos el interface wlan0
sudo ifconfig wlan0 up

Ahora tenemos que dejar /etc/wpa_supplicant/wpa_supplicant.conf así:

ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
        ssid="MOVISTAR_7A40"
        psk="E3UHR3Ca3FYgJ4e7elee"
}

Ahora conectamos con la base, pasándole al wpa_supplicant nuestra configuración:
sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B
(El parámetro -B es para que corra en modo daemon, de fondo, retornando al prompt inmediatamente... ¡sin eso, se queda esa consola para él solo!)

OPCION 1 (recomendada)
Nos damos nosotros mismos una IP del rango del router y un gateway:
sudo ip addr add 192.168.1.12/24 dev wlan0
sudo ip route add default via 192.168.1.1

OPCIÓN 2
Obtenemos una IP para wlan0:
sudo dhclient wlan0
Ahora nos damos un gateway, que es la dirección del router en la red a la que acabamos de conectarnos:
sudo ip route add default via 192.168.1.1

...Comprobamos que en /etc/resolv.conf tenemos:
nameserver 8.8.8.8

Y ya deberíamos ser capaces de hacer ping al router en la 192.168.1.1, a la dns de google en 8.8.8.8, y a google.com si nos da la gana.

******LANZAR PROGRAMAS DE WAYLAND SIN TENER UN ESCRITORIO WAYLAND CORRIENDO************************************************************

Esto es posible gracias a CAGE, un compositor (como WESTON) que sólo lanza la aplicación deseada de manera maximizada y exclusiva, y sobre KMS/DRM.
Su repo está aquí:

https://github.com/Hjdskes/cage

Depende de wayland, wlroots y xkbcommon.

Puedes descargar y compilar wayland muy facilmente de aquí, vienen las instrucciones de compilación:
https://github.com/wayland-project/wayland

******Convertir CUE/BIN a CHD*********************************************************************************************************

Instalamos chdman:
sudo apt-get install mame-tools

Y para comprimir de CUE/BIN a CHD:
chdman createcd -i image.cue -o image.chd

Y para comprimir todos los CUE/BIN de un directorio a CHD:
for i in *.cue; do chdman createcd -i "$i" -o "${i%.*}.chd"; done

Y para extraer de CHD a CUE/BIN:
chdman extractcd -i image.chd -o image.cue -ob image.bin

******Descargar desde ARCHIVE.ORG desde la línea de comandos usando un download manager***********************************************

Normalmente se podría usar WGET, pero como hay items que sólo se pueden descargar estando logueado, y como archive.org usa HTTPS y no es posible
loguearse por HTTPS con WGET, pues al final con muchos items no funciona WGET y nos da el famoso error 403: "forbidden".

Así que usamos la librería de python llamada "internearchive", una herramienta de Internet Archive.
Instalamos la librería "internetarchive":

pip install internetarchive

Ahora configuramos la librería ia, para darle nuestro user/pass:

ia configure

Y AHORA instalamos el script downloader en python también que vamos a usar:
(Con ia se puede descargar, pero NO soporta resume así que no me vale).

git clone --depth 1 https://github.com/john-corcoran/internetarchive-downloader.git
sudo cp ia_downloader.py /usr/local/bin/ia_downloader
sudo chmod +x /usr/local/bin/ia_downloader
 
Descargamos tal que así. Para bajarnos una colección completa al directorio actual...:

ia_downloader download no-intro_romsets ./

Para bajarnos sólo unos ítems concretos de una colección (por ejemplo los romsets completos de SNES y Megadrive):

ia_downloader download no-intro_romsets ./ -f Super\ Nintendo Megadrive

Y para continuar si se cortó la bajada anterior:

ia_downloader download no-intro_romsets ./ -f Super\ Nintendo Megadrive -r

Y como lo venimos haciendo ahora, para descargar con una sola línea todos los romsets que solemos usar:

ia_downloader download no-intro_romsets ./ -f Super\ Nintendo Mega Drive headered_NES2.0 Game\ Boy\ \(2022 Game\ Boy\ Color Game\ Gear Master\ System 32X Lynx PC\ Engine Atari\ -\ 2600 Atari\ -\ 5200 Atari\ -\ 7800 Jaguar WonderSwan ColecoVision Virtual\ Boy SG-1000 -r

******Descargar contenidos de ITunes desde Linux sin ITunes***************************************************************************

El programa se llama tunesviewer.
Si te da un error y no te deja buscar, dale a view y desactiva Request HTM5 Mode.
Cambia la búsqueda a Podcast Search.

*******Eliminar la BASURA de repositorios de Micro$oft de Raspbian/RaspberryPiOS*****************************************************

sudo rm /etc/apt/sources.list.d/vscode.list
sudo rm /etc/apt/trusted.gpg.d/microsoft.gpg
sudo apt update

******Hacer que lo que conectamos en un puerto USB siempre aparezca en un nodo de /dev determinado***************************

Mediante UDEV rules. Por ejemplo, para joysticks compatibles con XBOX360 (como el 8bitdo SN30Pro), hacemos esto.

1- Obtenemos la información que necesitamos ejecutando: 

udevadm info --name=/dev/input/js0 --attribute-walk

Mirando el segundo device (es decir, el segundo bloque "looking at parent device...", nos interesan estas cosas:

ATTRS{phys}=="usb-0000:01:00.0-1.3/input0"
ATTRS{name}=="Microsoft X-Box 360 pad"

También nos interesa el SUBSYSTEM, que vemos que es "input".

2) Creamos /etc/udev/rules.d/80-joysticks.rules con un contenido como así:
 
SUBSYSTEMS=="input", ATTRS{name}=="Microsoft X-Box 360 pad", ATTRS{phys}=="usb-0000:01:00.0-1.3/input0", NAME="input/js8"

Recargamos las UDEV RULES sin reiniciar, así:

udevadm control --reload-rules && udevadm trigger

Podemos monitorear los eventos de UDEV con:
udevadm monitor -p

******Probar los dispositivos de audio con speaker-test**********************************************************************

Puedes ver los dispositivos disponibles con: aplay -L
Tiene que ser -L mayúscula.

Ten en cuenta que cada dispositivo puede tener una o varias tarjetas.
Le puedes pasar el dispositivo que quieras a speaker-test en formato dispositivo:tarjeta_que_quieras_de_ese_dispositivo

Por ejemplo, en la Pi4, verás uno de los primeros así:

hw:CARD=vc4hdmi0,DEV=0
    vc4-hdmi-0, MAI PCM i2s-hifi-0
    Direct hardware device without any conversions

Pues puedes pasárselo a speaker-test así:
speaker-test -D default:vc4hdmi0
Donde estás diciéndole a speaker-test que use el dispositivo "default" (la definición específica de "default" para el device
vc4hdmi está en /usr/share/alsa/cards/vc4-hdmi.conf) y que dentro de ese dispositivo "default" use la tarjeta "vc4hdmi0".

Podríamos INTENTAR usar directamente el dispositivo "hw", por ejemplo:
speaker-test -D hw:vc4hdmi0
...Pero "hw" es directamente "Direct hardware device without any conversions", sin DMIX, y sólo acepta un formato
llamado IEC958_SUBFRAME_LE, así que no funciona directamente con speaker-test porque speaker-test
no puede generar audio en formato IEC958_SUBFRAME_LE. De hecho, ningún programa, en general, puede hacer eso.

******Ver los modos soportados de una pantalla/monitor (EDID)****************************************************************

Se puede volcar y ver con:
cat /sys/class/drm/card1-HDMI-A-0/edid | edid-decode

******Sangre roja en el Metal Slug de Neo Geo*********************************************************************************

En QUICK MENU->OPTIONS, ponemos NEO-GEO MODE a UNIBIOS.
Ahora, una vez dentro del juego, mantenemos pulsado START y nos sale un menú donde podemos activar varias cosas,
entre ellas la sangre roja o poner el juego en idiomas locos.

******Cargar juegos de GameMaker (GM) de Android en GNU/Linux****************************************************************

OJO!!! Se tiene que hacer con un Linux de 32bits (armhf).
De momento no es compatible con Linux de 64bit (como aarch64) y cuando lo sea, sólo se podrán usar juegos que funcionen sobre
un GMLoader de 64bit, con lo que no será compatible con juegos de GameMaker versión 2.x como el Maldita Castilla.

Instalamos dependencias previas:
sudo apt-get install libbz2-dev libzip-dev

TAMBIÉN se necesita OpenAL, que tiene su sección en este documento para compilarla e instalarla rápidamente.

Bueno, vamos al lio.
Clonamos el repo:
git clone --depth 1 https://github.com/JohnnyonFlame/droidports.git
git submodule update --init --recursive

Creamos el directorio de compilación, configuramos y compilamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

Ahora es tan simple como cargar el Maldita Castilla con:
./loader Maldita_Castilla.apk
(Se usa la versión para Ouya que está en la página de Locomalito)

Para Metroid am2r, tenemos que bajarnos la versión 1.1 y parchearla a la última versión que haya en ese momento:

-Clonamos el repo de la última versión del auto-parcheador: git clone --depth 1 https://github.com/AM2R-Community-Developers/AM2R-Autopatcher-Linux

-Descargamos el AM2R versión original 1.1 de aquí: https://archive.org/details/am2r1.1
y lo guardamos dentro del directorio AM2R-Autopatcher-Linux como AM2R-Autopatcher-Linux/AM2R_11.zip
(OJO: Bájalo por Torrent, ya sabes que todo lo de Archive se corta si te bajas el .zip directamente)

-Instamos el parcheador xdelta: sudo apt install python xdelta3

-Bajamos la última versión del parche de DISCORD:
wget -O AM2R-Autopatcher-Linux/data/droid.xdelta https://cdn.discordapp.com/attachments/829714741471215667/874800076017504326/droid.xdelta
wget -O AM2R-Autopatcher-Linux/data/android/AM2RWrapper.apk https://cdn.discordapp.com/attachments/829714741471215667/874800183181967400/AM2RWrapper.apk

-Parcheamos!!
cd AM2R-Autopatcher-Linux && python patcher.py
(Te preguntará por el tipo de parche: responde Android. Y no hace falta que instales el pack de sonido de alta calidad porque
ocupa MUCHO más.)

******EDITAR Y CAMBIAR COSAS EN JUEGOS GML COMO EL MALDITA CASTILLA**********************************************************

Por ejemplo, vamos a ver cómo activar en el juego la interpolación bilineal para evitar el shimmering.

Bajamos la versión 0.3.5.8 del Undertale Tool de aquí:
https://github.com/krzys-h/UndertaleModTool/releases

NO usamos la última versión porque se cuelga al salvar archivos de juego después de editarlos.

Instalamos la versión de .NET que nos pida. Por ejemplo, para la versión 0.3.5.8 nos pide .NET 4.6.2, así que hacemos:
winetricks dotnet462

Ejecutamos el UndertaleTool.exe con wine.

Abrimos el archivo assets/game.droid.

PARA CAMBIAR COSAS, desplegamos la categoría CODE, y allí hacemos doble click en el fichero de código que queramos cambiar.
Nos aparecerá la vista DECOMPILED del fichero, que es la que tiene código legible que podemos editar a nuestro gusto.
Entonces nos vamos a a la vista DISSASEMBLY, y CONFIRMAMOS que se ha generado el código equivalente a la línea que hemos añadido.
OJO!!! HASTA QUE NO VAYAMOS A DISSASEMBLY, NO SE GUARDAN LOS CAMBIOS!!!

PARA SABER QUÉ NOS INTERESA CAMBIAR, LO PRIMERO EXPORTAMOS EL CÓDIGO PARA LUEGO PODER BUSCAR EN ÉL (DESDE EL UndertaleModTool NO SE PUEDE).
Para ello, nos vamos a SCRIPTS->BUILTIN SCRIPTS->EXPORT ALL CODE, y una vez exportado ya podemos buscar.
A CONTINUACIÓN, NOTAS DE COSAS QUE YA HEMOS BUSCADO, PARA DEJAR CIERTOS ASPECTOS DEL JUEGO COMO QUERAMOS:

-EDITAMOS "gml_Script_scr_initial_values", y ahí ponemos "global.is_ouya" a 0.
 Eso hace que en "gml_Object_obj_old_tv_Draw_64", se vaya por la ruta de arriba (la del "if (!global.is_ouya)"),
 así que quitamos todos las llamadas a "texture_set_interpolation()" menos la primera, que la ponemos a "true".
 (Esto hace que todo vaya interpolado, naturalmente, y si se activa el overlay irá interpolado también, que dentro
 de lo que cabe queda mejor).
-EDITAMOS "gml_Object_obj_control_Other_2", y ahí podemos desactivar poner el "speedrun" a 0,
configurar los controles, etc.
También podríamos poner el "overlay" a 0, pero no lo recomiendo porque el juego se ve mejor con overlay si ponemos
una resolución adecuada.

Salvamos, sobreescribiendo el archivo .droid, y reempaquetamos el .APK comprimiendo el directorio del juego con ZIP,
PERO SIN COMPRIMIR, SÓLO "STORE".
Para comprimirlo con sólo store y guardando los archivos y directorios como se debe, entramos en el directorio donde tenemos
descomprimido el APK y hacemos:
zip -r -0 maldita.apk *

TIENES UN APK LISTO EN EL DISCO DURO DE BACKUP, CON TODAS LAS MODIFICACIONES A TU GUSTO.

PARA QUE SE VEA BIEN EL OVERLAY:
COMO la imágen que se usa para las scanlines, (CURIOSIDAD: está en SPRITES y se llama "spr_old_tv"), es de 576x432,
tenemos que poner una resolución en cmdline.txt cuya altura (número de líneas) sea múltiplo de 432.
O sea que con una resolución que tenga una altura de 864, ya se ve bien.
PERO además nos interesa que sea 864 de altura y que tenga un ratio de 16:9, por lo que la anchura será 1536.
Los detalles para establecer un modo de vídeo de 1536x864 y con el aspect ratio correcto, los he sacado de:
https://wiki.archlinux.org/title/kernel_mode_setting#Early_KMS_start
El parámetro "video=..." de la línea de parámetros del kernel quedaría así:
video="HDMI-A-1:1536x864@60"


*****CÓMO CARGAR OTROS JUEGOS DE GAME MAKER (GML) CON EL GMLOADER***********************************************************

PARA CARGAR OTROS JUEGOS HECHOS CON GML, LA IDEA BÁSICA SERÍA COGER EL APK DE UN JUEGO ("donor apk"),
DESCOMPRIMIRLO, COPIAR LOS DATOS DEL NUEVO JUEGO A "assets", RENOMBRAR "data.win" A "game.droid", Y RECONSTRUIR EL APK.

PERO OJO! El APK que usas de "donante" tiene que tener una versión del runner que coincida con la versión
que el data.win/data.droid espera.
Así que para saber qué versión del runner espera el data.win/game.droid, lo cargamos con el UnderTaleModTool (UTMT) y
en la caja de texto de la parte de abajo del todo, escribimos una de estas:
Data.GMS2_2_2_302
Data.GM2_2_3
Data.GM2_2_3_1
Data.GM2_2_3_2
(Cuando coincida la versión te dirá TRUE, y cuando no coincida te dirá FALSE).
(Si quieres ver qué más heurustics hay para averiguar la versión, mira en el código fuente del UTMT, aquí:
https://github.com/krzys-h/UndertaleModTool/blob/4b52cb69c0939c4ccf6392838eee2eb5d8b2cfc8/UndertaleModLib/UndertaleData.cs#L60 )
(Si con una de esas te dice algo de "UndertaleData' does not contain a definition for...", significa que necesitas
una versión del UTMT más moderna, que conozca los heuristics de esa versión. EL PROBLEMA ES QUE LAS VERSIONES MODERNAS DE UTMT
PETAN EN LINUX, Y NO SE PUEDE USAR NATIVAMENTE PORQUE USA CIERDA MIERDA QUE LO HACE EXCLUSIVO DE WINDOWS, ASÍ QUE ES WINE O NADA).

CON ESO QUE TE ACABO DE EXPLICAR, DEBERÍAS SER CAPAZ DE AVERIGUAR QUÉ APK PUEDES USAR COMO DONANTE PARA UN data.win/game.droid DETERMINADO.


******PPSSPP, el emulador de PSP en Raspberry Pi 4***************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/hrydgard/ppsspp.git
git submodule update --init --recursive

Configuramos y compilamos:
mkdir b4
cd b4

PARA WAYLAND:
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_WAYLAND_WSI=ON -DUSE_VULKAN_DISPLAY_KHR=OFF -DUSING_X11_VULKAN=OFF -DUSING_GLES2=ON -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

PARA KMSDRM:
cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_WAYLAND_WSI=OFF -DUSE_VULKAN_DISPLAY_KHR=ON -DUSING_X11_VULKAN=OFF -DUSING_GLES2=ON -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

Si nos da un error al linkar relacionado con ffmpeg, tenemos que recompilar ffmpeg interno que trae, lo cual se hace con esta
secuencia de comandos:

pushd ../ffmpeg
./linux_arm64.sh
popd

(Ese error ocurre porque, por defecto, intenta usar un FFMPEG que trae PRE-compilado contra otras libc.. normal que de error!)

Ahora copiamos el directorio "assets" al mismo directorio del ejecutable PPSSPP

Para compilar una versión LIBRETRO:

mkdir b4
cd b4
cmake .. -DLIBRETRO=ON -DUSE_VULKAN_DISPLAY_KHR=ON -DUSE_WAYLAND_WSI=OFF -DUSING_X11_VULKAN=OFF \
-DCMAKE_BUILD_TYPE=Release -DUSING_GLES2=ON -DUSE_DISCORD=OFF \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

*******Compilar el core libretro Yabause***********

Clonamos su repo:

git clone --depth 1 -b kronos https://github.com/libretro/yabause.git

entramos en yabause/src/libretro

make -j4

La bios tiene que ir en ~/.config/retroarch/system/saturn_bios.bin o ~/.config/retroarch/system/kronos/saturn_bios.bin

(OJO: requiere OpenGL 4.1 o algo así, y NO FUNCIONA CON VULKAN, GLES, GLES2 ni GLES3, así que olvídate de que funcione en la Raspberry Pi 4).

*******Compilar el core DOSBOX-CORE**********************************

Este sí sincroniza el vídeo bien (al fin).
(OJO! ¡¡Si estás haciendo experimentos en una TTY con RetroArch en KMS/DRM, mientras tienes las X11 corriendo en otra TTY,
haz de vez en cuando un EXIT en la TTY en la que corres RetroArch, o empezará a ir todo a tirones al cabo de unas cuantas
ejecuciones del RetroArch, y TE VOLVERÁS LOCO BUSCANDO LA EXPLICACIÓN!!)

Clonamos su repo:

git clone --depth 1 https://github.com/libretro/dosbox-core.git

Entramos en el directorio libretro y hacemos:

COMMONFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
make -j4 platform=unix WITH_FAKE_SDL=1 STATIC_LIBCXX=1 \
WITH_FLUIDSYNTH=0 BUNDLED_AUDIO_CODECS=0 BUNDLED_GLIB=0 BUNDLED_LIBSNDFILE=0 WITH_PINHACK=0 WITH_VOODOO=0 WITH_BASSMIDI=0

(Desactivo FLUIDSYNTH porque compila un montón de mierdas como libsndfile y demás que consumen CPU, con la emulación de GRAVIS vas que chutas en DOS).
(También desactivo la emulación de tarjetas Voodoo, el PINHACK que es para ver completas las mesas de pinball sin scroll, etc).

Para que todo vaya suave, en OPTIONS del core:
En TIMING->FRAME TIMING MODE->EXTERNAL
Y para que los juegos a 70HZ también vayan suaves, "SETTINGS->AUDIO->SYNCHRONIZATION->MAXIUM TIMING SKEW" a 20% o más,
para que resamplee de los 70HZ a los ~60HZ de nuestro monitor (a cambio de la suavidad, el se oirá sonido un poco ralentizaaaaaado).

La configuración general (ciclos, emulación de la CPU usada, tarjetas de vídeo y audio, etc) se hace desde las OPTIONS del core.
Y luego, para que en el inicio monte un directorio y se meta en él, debes pasarle un .conf que sólo haga eso, así:

PARA EL TECLADO COMPLETO: En SETTINGS->INPUT->HOTKEYS, en HOTEY ENABLE pon la tecla WINDOWS/PI (se llama "lsuper", lo verás al darle)
y déjalo así para todos los cores.

PARA EVITAR PUSACIONES FANTASMA REPETIDAS AL PULSAR NOSOTROS UNA TECLA O PROBLEMAS CON EL PAD: NO DEBES TENER los botones o el pad mapeados
a teclas del teclado en los settings principales de RetroArch. Ve borrándolas todas con SUPR, y mapeas SÓLO A BOTONES DEL MANDO.
Y TRANQUILO, QUE TE SIGUIES PUDIENDO MOVER CON EL TECLADO, ESO NO TIENE NADA QUE VER.

PARA QUE EL PAD NO SE QUEDE ATASCADO EN UNA DIRECCIÓN AL SALTAR EN LOS JUEGOS:
-En "QUICK MENU->CONTROLS->PORT 1 CONTROLS", usa "Joystick" como "DEVICE TYPE", y pon así los controles direccionales:
D-Pad UP: Left Analog Y-
D-Pad UP: Left Analog Y+
D-Pad UP: Left Analog X-
D-Pad UP: Left Analog X+

PARA EL ASPECT RATIO: Lo de siempre para todos los cores en general: en SETTINGS->VIDEO se pone en 4:3 para todo y fuera.  

PARA EVITAR PANTALLA NEGRA al principio del SUPERFROG si se usa el driver de vídeo VULKAN: desactiva el "FRAME DUPING" en las opciones del core.
(Sólo ocurre con el driver del vídeo VULKAN).

PARA EVITAR QUE SE QUEDE EN EL MENÚ DE RETROARCH AL SALIR, desactiva SETTINGS->CORE->LOAD DUMMY CORE ON CORE SHUTDOWN.

PARA TENER UN PC EQUIVALENTE A UN 386 a 33MHz, pon 7800 ciclos (busca "dosbox cycles equivalent" en google para ver otras equivalencias).

PARA CARGAR EL Might & Magic 2, antes tienes que ejecutar LOADFIX (es un comando del propio DOSBOX), para que no se queje de la memoria.

PARA EVITAR el error de que no encuentra /dev/snd/seq, pues cargar el módulo "snd_seq", o ignorar el error.

#######################
# EMPIEZA EL DOS.CONF #
#######################

[autoexec]

mount c: /home/manuel/dos/juegos
c:

#####################
# ACABA EL DOS.CONF #
#####################

El tema del teclado: para que las teclas se lean todas desde DOS, sin liarse con las hotkeys de RETROARCH,
debes tener un "HOTKEY ENABLE" en "SETTINGS->INPUT"
(yo tengo puestas las comillas simples) para que así al pulsar las teclas no se activen cosas del RetroArch a no ser que pulses
el "HOTKEY ENABLE" que tengas configurado.
PARA QUE NO SE ATASQUEN LAS TECLAS DE DIRECCIÓN MIENTRAS JUEGAS CON TECLADO: Vete a "QUICK MENU->CONTROLS->PORT 1 CONTROLS"
y pon el DEVICE TYPE a "KEYBOARD+MOUSE", y dale a "SAVE CORE REMAP FILE".

Juegos de DOS para bajar: te enganchas el TORRENT y bajas sólo los que vayas queriendo: https://www.retro-exo.com/exodos.html

*******Compilar el core libretro Duckstation (Swanstation)***********

(OJO: en el repo oficial de ducktstation tienes cores ya compilados, pero NO funcionan cuando Retrorch funciona sobre KMSDRM.
NO te molestes en reportarlo, porque el autor de duckstation es un poco gilipollas.)

Clonamos el repo donde mantienen la versión no oficial:
git clone --depth 1 https://github.com/libretro/swanstation.git

Editamos src/duckstation-libretro/libretro_host_interface.cpp y comentamos el contenido de la función
LibretroHostInterface::UpdateGeometry(), dejándola inutilizada por completo.
(Esto evita las ralentizaciones cuando el WipeOut hace el efecto de terremoto de pantalla al sufrir un ataque enemigo).
OJO!!! RECUERDA que debes poner en las opciones del core el ratio a 4:3 porque al comentar UpdateGeometry() no se puede establecer
bien automáticamente.

mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO_CORE=ON \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

ACUÉRDATE DE PONER EL RENDERER DEL CORE EN "SOFTWARE" (No le eches la culpa al shader si hay audio dropouts)...

********CROSSCOMPILAR el core libretro Duckstation************

Puede ser interesante porque no compila en Pi3 con 1GB ni con swap. Crosscompilamos en local.

-Instalamos los paquetes:
sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

-Copiamos el rootfs a /opt/DEBIAN_ROOT, excluyendo home, con:
sudo rsync -av --progress /media/manuel/DEBIAN_ROOT /opt/ --exclude DEBIAN_ROOT/home/pi

-Bajamos la última release estable de aquí:
https://github.com/kivutar/swanstation/releases

-Creamos en el raiz de los sources (o donde nos de la gana) el cmake toolchain file, donde le especificamos todo lo necesario
para crosscompilar para aarch64.
Yo lo he llamado toolchain.cmake, con el contenido:

# Target system
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR aarch64)

SET(CMAKE_SYSROOT /opt/DEBIAN_ROOT)
#set(CMAKE_FIND_ROOT_PATH /opt/DEBIAN_ROOT)

# Cross compiler
SET(CMAKE_C_COMPILER   aarch64-linux-gnu-gcc)
SET(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
SET(CMAKE_LIBRARY_ARCHITECTURE aarch64-linux-gnu)
SET(CMAKE_PREFIX_PATH /opt/DEBIAN_ROOT/usr/lib/aarch64-linux-gnu)

SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

-Ahora creamos el directorio de compilación y nos movemos a él:

mkdir build
cd build

-Configuramos pasándole el cmake toolchain file así:
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO_CORE=ON -DENABLE_CHEEVOS=OFF -DENABLE_DISCORD_PRESENCE=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake ..

-Compilamos con make, y comprobamos el ejecutable, que sea aarch64:
file duckstation_libretro.so

¡¡Y listo!! Menuda aventura macho....

NOTAS ADICIONALES para el core:

SI DUCKSTATION DA SEGFAULT AL SELECCIONAR VULKAN, VE A SETTINGS->VIDEO->OUTPUT Y EN "OUTPUT" SELECCIONA "VULKAN"

******Compilar DUCKSTATION versión NOGUI (directo a KMSDRM!)*****************************************************************

Clonamos duckstation:

git clone --depth 1 https://github.com/stenzek/duckstation.git

Instalamos dependencias previas:

sudo apt-get install libevdev-dev --no-install-recommends
Y si vas a compilar con soporte para wayland, también esto:
sudo apt-get install extra-cmake-modules --no-install-recommends

Configuramos con:

cmake .. \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -DEGL_NO_X11" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -DEGL_NO_X11" \
-DCMAKE_BUILD_TYPE=Release -DENABLE_CHEEVOS=OFF -DENABLE_DISCORD_PRESENCE=OFF -DUSE_X11=OFF -DUSE_DRMKMS=ON \
-DBUILD_NOGUI_FRONTEND=ON -DBUILD_QT_FRONTEND=OFF -DHAVE_EGL=ON -DUSE_WAYLAND=ON -DUSE_SDL2=ON ..

(Hay que dejar el soporte de SDL2 porque EVDEV no implementa aún los ejes de los mandos)

Copia todo el contenido de bin a ~/psx. No copies sólo el ejecutable, o te dará un segfault cuando lo ejecutes.

Si  el ejecutable resultante te da un error con que no puede abrir card1, edita src/common/drm_display.h y cambia card = 1 por card = 0.

La BIOS va en ~/.local/share/duckstation/bios/

PARA LANZAR LOS JUEGOS tienes que pasarle la ruta COMPLETA del .cue, no vale que le pases una ruta relativa a donde estás,
ni que empiezes la ruta en home con ~/, etc. RUTA COMPLETA.

******Compilar el core FLYCAST (UPSTREAM) para Raspberry Pi 4********

Clonamos su repo:
git clone --depth 1 https://github.com/flyinghead/flycast.git
git submodule update --init

Configuramos y compilamos:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DLIBRETRO=ON -DUSE_VULKAN=ON -DUSE_OPENGL=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O3 -fomit-frame-pointer" \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O3 -fomit-frame-pointer"

make -j4

Ahora ponemos la BIOS, llamada "dc_boot.bin", en ~/.config/retroarch/system/

Para que no de segfault al iniciarse desde la TTY, tienes que poner al final de la línea de retroarch: < /dev/null
Y ya podemos lanzar juegos en GDI, CDI o CHD.

******Core PCSX2 libretro****************************

git clone --depth 1 https://github.com/libretro/pcsx2.git
git submodule update --init

Configuramos y compilamos con:

mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DLIBRETRO=ON \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native" \
-DCMAKE_C_FLAGS="-march=native -mtune=native"

******Space Cadet pinball en la Raspberry Pi*********

Bajamos los últimos sources estables de aquí:

https://github.com/k4zmu2a/SpaceCadetPinball/releases

Configuramos y compilamos con:
mkdir b4
cd b4
cmake .. \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
make -j4

Copiamos el ejecutable y los datos del juego (que los tienes ya preparados en el disco duro de backup) y a jugar.
Puedes ajustar la configuración (fullscreen, uncapped framerate, etc..) usando ~/.local/share/SpaceCadetPinball/imgui_pb.ini

******Juegos JAVA que usan GL/GLES en la Raspberry Pi***************************************************************

Lo primero sería compilar esta librería:
https://github.com/LWJGL/lwjgl3

******TIC-80 FANTASY CONSOLE para Raspberry Pi como core libretro***************************************************

Clonamos su repo:
git clone --recursive https://github.com/nesbox/TIC-80 --depth 1

Configuramos con:
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO=ON -DBUILD_SDL=OFF -DDISABLE_NETWORKING=TRUE \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..

Los juegos están en:
https://tic80.com/play?cat=0

******Error tonto: ACLOCAL is missing on your system********

No te falta nada realmente. Sencillamente, hazle un touch a:
aclocal.m4
configure
Makefile.am
Makefile.in

Y ya debería solucionarse. Sin instalar nada.

******Llaves en LibreOffice**********

Antes de esto, aprende a trabajar con marcos de texto, de manera que puedas luego moverlos dentro de las laves y tal sin andar jugando con tabulaciones.
Los marcos de texto se crean con Insert->Text Box. Así de fácil.
Ahora ya, lo de las llaves va así:

1)Abrimos el programa de libreoffice
2)Clickeamos en barra de herramientas opción "ver".
3)Luego de entrar en la opción "ver" continuamos clickeando en "barra de herramientas"
4)Después ingresamos a la opción dibujo para lograr aparecer "la tabla de dibujo".
5)Tocamos en las formas de símbolos (una carita sonriente).
6)Clickeamos en la llave de apertura.
7)Para darle color, forma y espesor clickeamos en la llave con el botón derecho en la opción línea.
8)Cada cual elige como desea su llave.
9)Para rotarla se debe tocar con el botón derecho, posición y tamaño y en el mismo rotación.
10)Y luego cada uno elige la predeterminación que desea.
11)Llave finalizada.

******Medir la temperatura en Raspberry Pi************

vcgencmd measure_temp

******Medir velocidad de la CPU en Raspberry Pi**********

sudo cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq
vcgencmd get_config arm_freq

*****SDL2 en hardware genérico con mi driver KMSDRM******

Lo primero, borra la versión del sistema.
sudo rm -R /usr/lib/libSDL*
sudo rm -R /usr/include/SDL*

VAMOS A DEJAR QUE SE INSTALE EN /usr/local/lib Y /usr/local/include, ASÍ QUE NO LE PASAMOS --prefix=/usr

Antes de compilar, instalamos estas dependencias:
sudo apt-get install libudev-dev libasound2-dev libvorbis-dev libpng-dev libjpeg-dev libfreetype6-dev xsltproc libpciaccess-dev xutils-dev libtool make automake pkg-config gcc g++ --no-install-recommends
(libgbm NO TENEMOS QUE INSTALARLO ni nada, se compila e instala con MESA automáticamente, si es que instalas MESA compilándolo por tu cuenta. Si no, pues sí, hace falta libgbm-dev si usas un MESA precocinado.)
(Si has compilado SDL2 con soporte para kmsdrm pero te da el error "not available video device", es porque compilaste sin tener instalado libgmb-dev junto con un MESA precocinado, y no te ha avisado... Instala ese paquete y recompila, anda.)

Clonamos:
git clone --depth 1 https://github.com/libsdl-org/SDL.git

Ahora ya configuramos:
./configure --enable-video-x11 --disable-video-wayland --disable-dbus --disable-diskaudio --disable-oss \
--disable-pulseaudio --disable-dummyaudio --disable-video-dummy --enable-video-opengles --enable-video-opengl \
--enable-libudev --disable-dbus --disable-ime --enable-video-kmsdrm

Fíjate que en el resúmen al acabar del configure, te tiene que indicar que el soporte KMSDRM está activado, para ello se requiere que las librerías necesarias estén en el sistema (libgbm y libdrm).
Ahora borra las librerías libSDL2* que vienen instaladas en la mayoría de las distros en /usr/lib/x86_64-linux-gnu/, e instala las que acabas de compilar, que acabarán en /usr/lib.

Si quieres debugear las SDL, añade antes de ./configure: CFLAGS="-O0 -ggdb"

******Notas SDLPop : el clon open source y libre de Prince of Persia *********

Para adaptar los controles a tu gusto, ve a SDL_JOYBUTTONDOWN  y a SDL_JOYBUTTONUP, y en ambos casos verás que los CASE de los botones están en secuencia: 0 1 2 3
Pues ponlos en 0 1 3 2, EN AMBOS, tanto en el SDL_JOYBUTTONDOWN como en el SDL_JOYBUTTONUP
Ahora, para que abajo en el pad funcione como debe, ve a SDL_JOYAXISMOTION y añade este bloque justo antes del break:

if (event.jaxis.axis == 1) { 

	if (event.jaxis.value > 8000)
		gamepad_states[1] = 1; // down 
	else 
        	gamepad_states[1] = 0; 
}

A parte de eso, añade los flags del renderer (también en seg009.c como todo lo de los controles que hemos dicho hasta ahora) y los del gcc en el Makefile, y a compilar.

******Cambiar la región de un juego de MegaDrive y Master System*****************

PARA IR A UNA DIRECCIÓN CONCRETA EN HEXEDIT: PULSA ENTER Y TE PIDE LA DIRECCIÓN, Y ALLÁ VAMOS.
Editamos el juego con el hexedit. Nos vamos a la dirección $1F0. Pulsamos TAB para ir al texto. Cambiamos la E por una U, o por una J, como queramos.
Salimos y salvamos con CTRL+X.
Si el juego así alterado nos da un pantallazo rojo o negro, es que nos hemos cargado el checksum, pero sería muy raro. Hay programas para repararlo, anyway.

Para juegos de Master System, buscamos $7FFF, que ya sé que está muy avanzada, pero es esa, y cambiamos el valor correspondiente a los primeros 4 bits de esa dirección , 
si es PAL vendrá un 4, pones un 3 donde el 4 SIN CAMBIAR al texto con TAB, sino directamente en los valores en HEX, y ya.
y ya tienes JAP.
Míralo aquí mejor si no lo pillas: http://www.smspower.org/Development/ROMHeader#ProductCode7ffc25Bytes

******Emulando la NES con FBNeo*********************************************

OJO: NO TE COMPLIQUES CON TODO LO DE ABAJO SI PUEDES EVITARLO. LAS ROMS DE FBNEO ESTÁN TODAS EN:
www.retroroms.info

RAINBOW ISLANDS necesita, a parte de la última ROM de retroroms, la BIOS cchip.zip.

El emu de NES de FBNeo es el más exacto, pero requiere un A72 (Pi4) como mínimo.

Las ROMS además hay que prepararlas antes.
Lo más fácil es irte a 
www.retroroms.info
y bajarlas de ahí. O preguntarle a dink por privado en https://neo-source.com/index.php?action=pm#msg14377

Pero por si tuvieras que prepararlas "a mano", aquí tienes cómo hacerlo.
Veamos como ejemplo cómo preparar el romset de NES:
-Cogemos la parte de NES del ROMSET de FBNeo, o el ROMSet no-intro de NES si no tenemos otra cosa
(con el no-intro te van a faltar muchas cosas, mejor usa el ROMSet de NES de FBNeo, tienes romsets de FBNeo en archive.org).
-Cogemos el DAT de aquí:
https://github.com/libretro/FBNeo/blob/master/dats/FinalBurn%20Neo%20(ClrMame%20Pro%20XML%2C%20NES%20Games%20only).dat
Cogemos el CLRMAME de aquí (bajamos el último ZIP para Windows, NO HAY versión Linux):
https://mamedev.emulab.it/clrmamepro/#downloads
Lanzamos el CLRMAME con WINE, en el profiler simplemente le damos a "Add DatFile", y le damos el DAT que acabamos de bajar.
Ahora al volver al profiler le damos a Load/Update y ya nos sale el menú de dibujitos del CLRMAME.
Ahí nos vamos a REBUILDER. En rebuilder, dejamos todo como está menos esto:
-En el menú principal marcamos "non-merged sets" y elegimos como orígen el directorio donde tenemos el romset no-intro,
y destino el que queramos.
-En Advanced nos aseguramos de que "Separated BIOS sets" está sin marcar.
Pues ya está, le damos a Rebuild.

Ahora, para cargar la rom que queramos tenemos que pasar el parámetro --subsystem, así:
retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=nes nes/mario.zip

O bien en el RetroArch, nos vamos a "load core", cargamos el core FBNeo, y luego vamos a "load content" y nos aparecerá
"subsystem", allí elegimos NES, y luego volvemos a "subsystem" y le damos a "start content" y elegimos otra vez NES.

Si quieres emular FDS, necesitas fdsbios.zip que contiene disksys.rom.
PERO no te compliques: usa www.retroroms.info, o en los torrents de ROMsets de FBNeo viene todo lo de FDS listo.

******MSX en el core FBNEO***************************************************************************************

Los juegos los podemos bajar de aquí, que ya están preparados para el core FBNeo: www.retroroms.info
Los metemos en un directorio junto con el msx.zip que lleva las BIOS del MSX.

Ahora, para cargar la rom que queramos tenemos que pasar el parámetro --subsystem, así:
retroarch -L ~/.config/retroarch/cores/fbneo_libretro.so --subsystem=msx msx/pengadv.zip

O bien en el RetroArch, nos vamos a "load core", cargamos el core FBNeo, y luego vamos a "load content" y nos aparecerá
"subsystem", allí elegimos MSX, y luego volvemos a "subsystem" y le damos a "start content" y elegimos otra vez MSX.

RECUERDA LO PRIMERO DESMAPEAR LAS TECLAS DE TECLADO A BOTONES DE JOYSTICK EN LOS SETTINGS PRINCIPALES DE RETROARCH!
De lo contrario, cualdo pulsas una tecla de cursor, por ejemplo, estás enviando tanto la pulsación de teclado como la de joystick...
Esto también pasa en el core dosbox-core, así que quítalas. No pierdes nada, te vas a poder seguir moviendo por el menú de RA igual,
con las teclas de siempre, no hace falta tenerlas mapeadas a botones de joystick.

RECUERDA que para poder salvar (o cargar!) los mapeos de teclado que se aplican sólo a lo que tengas en el directorio de
los juegos de MSX (SAVE CONTENT DIRECTORY REMAP FILE), tienes que pasar la ruta de la ROM o bien completa o bien con ./ al menos, en plan:
msx1 ./msx/penguin.zip
Si haces: msx1 msx/penguin.zip, se salvará un .RMP con nombre de archivo corrupto.

******LA ABADÍA DEL CRIMEN, nativo en LINUX**********************************************************************

Copiamos su repo:
git clone --depth 1 https://github.com/Samuel85/Abbey.git

Creamos el directorio de compilación y compilamos:
mkdir b4
cd b4
cmake ..
make -j4

Creamos el directorio donde va a ir el juego, por ejemplo ~/abadia
Y ahí copiamos los directorios "roms", "fonts" y "res" que vienen con los sources en su directorio "build".
Copiamos también el ejecutable "abbey", y ya debería ir. No necesitas nada más externo.

Interdoom, un sourceport peculiar en ruso
=========================================

Bajamos la última estable de:

https://github.com/JNechaevsky/inter-doom.git/releases

Compilamos con CMAKE:
mkdir b4
cd b4

cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -fsigned-char" \
-DCMAKE_BUILD_TYPE=Release -DBUILD_PORTABLE=ON ..

make -j4

Copiamos el directorio "src/base" tal cual (tiene wads dentro para el engine) a ~/heretic
cp -R src/base ~/heretic/

Copiamos los ejecutables inter-* (que están en src) a ~/doom
cp src/inter-* ~/heretic/

Ejecutamos el juego por primera vez para que nos genere russian-heretic.ini.
Editamos russian-heretic.ini y ponemos:
english_language	1

Para tener música GUS, tenemos que tener SDL2-mixer compilado con soporte de Timidity, y en inter-heretic.ini
ponemos la ruta de los patches que vienen en el directorio "base":

gus_patch_path = "/root/heretic/base/gus_patches"

Para tener música digital, usamos estos WADs ya preparados:
https://zandronum.com/forum/viewtopic.php?t=97
Se los pasamos con el parámetro "-file", por ejemplo:
inter-heretic -iwad heretic.wad -file heretic_music.wad

También podríamos meter en un WAD tal cual sin directorios los FLAC o los OGG que queramos,
PERO MUY IMPORTANTE, SIN EXTENSIÓN, en plan E1M3 sin más.
Le puedes quitar la extensión OGG a todos los archivos de un directorio con:
find -type f -name '*.ogg' | while read f; do mv "$f" "${f%.ogg}"; done
Ahora los metes en un WAD (con SLADE en Linux vale para crear WADs)
Y le pasamos ese WAD con -file así:
./russian-heretic -file heretic-music.wad

******Compilar driver VULKAN en la raspberry pi 3 con aarch64*********

Instalamos dependencias previas:

sudo apt-get install --no-install-recommends libmtdev-dev libevdev-dev

VAMOS PRIMERO A POR LAS VULKAN HEADERS (no hace falta compilar nada para instalarlas):

git clone --depth 1 https://github.com/KhronosGroup/Vulkan-Headers.git
mkdir b3
cd b3
cmake ..
sudo make install
export VULKAN_HEADERS_INSTALL_DIR=/usr/local

VAMOS AHORA A POR EL VULKAN-LOADER:

git clone --depth 1 https://github.com/KhronosGroup/Vulkan-Loader.git
mkdir b3
cd b3
cmake -DBUILD_WSI_WAYLAND_SUPPORT=OFF -DBUILD_WSI_XLIB_SUPPORT=OFF -DBUILD_WSI_XCB_SUPPORT=OFF ..
make -j4
sudo make install

AHORA VAMOS A POR EL DRIVER VULKAN EN SÍ:

Clonamos el repo
git clone --depth 1 https://github.com/Yours3lf/rpi-vk-driver.git

cd rpi-vk-driver

Editamos CMakeLists.txt y añadimos el flag -fpermissive, para lo cual añadimos estas dos líneas debajo de la línea de cmake_minumun_required...:
SET(CMAKE_CXX_FLAGS  "${CMAKE_CXX_FLAGS} -fpermissive")

Debajo añadimos también la línea para poner la arquitectura a armv8-a:
SET(RPI_ARCH "armv8-a")

Editamos test/CMakeLists.txt, y eliminamos la línea:
add_subdirectory(inputTest)
(La eliminamos porque este test necesita libinput-dev, que tiene un montón de dependencias absurdas y de todos modos es una librería
para X11 y Wayland, así que a nosotros nos sobra la librería.. y el test este).

Configuramos y compilamos con:
mkdir b3
cd b3
cmake -DRPI_ARCH=armv8-a ..
make
NOS DARÁ ERRORES CON VkImageView. Cada vez que nos de un error de esos, editamos le fichero correspondiente y cambiamos depthImageView por depthImage, y seguimos compilando como si no hubiera pasado nada XD

Ahora instalamos:
sudo make install

******Compilando OpenBOR*********************************************************************

Dependencias previas: sudo apt-get install libvpx-dev

Clonamos los sources de:
git clone --depth 1 https://github.com/DCurrent/openbor.git

Entramos en openbor/engine
Editamos Makefile y:
-Quitamos el -Werror para que no trate los warnings como errores.
-Comentamos la línea de STRIP debajo de "ifdef BUILD_LINUX"
-Quitamos el -g de la segunda línea de CFLAGS que hay al inicio de la sección Compiler Flags, y ahí mismo
 añadimos los CFLAGS de la Pi4 si vamos a ocmpilar para ella: -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer
-Para que cuando compilemos veamos los flags, nos vamos a la sección "Rules to manage Files and Libraries for SDL"
 y debajo del "@echo Compiling" de los .c, metemos: @echo $(CC) $(CFLAGS) -c $<

Antes de compilarlo, ejecutamos version.sh para que nos cree version.h

En la Raspberry Pi:
make BUILD_LINUX_LE_arm=1 GCC_TARGET=64 -j4

En el PC:
make BUILD_LINUX_LE_x86_64=1 GCC_TARGET=64 -j4

Para meter los juegos:
La primera vez que ejecutas OpenBOR, te crea entre otros un directorio llamado Paks. Mete los .pak ahí, y listo.

El mítico juego de HE-MAN lo tienes en su página oficial: https://gamejolt.com/games/he-man/19434
EN LAS OPCIONES DEL HE-MAN:
NO TE OLVIDES de dejar SOFTWARE RENDERER a SIMPLE 2X y el HARDWARE RENDERER a BILINEAR, activar la pantalla completa y el vsync.

Para lanzarlo sin pasar por el lanzador:
./OpenBOR Paks/HE-MAN.PAK

NO HAY opciones "generales", cada juego gestiona las suyas desde su menú. Son todos parecidos, anyway.

Puedes lanzar los juegos desempaquetados, pero no hay ventaja en ello. Para hacerlo:
Extrae el juego con borpak, una utilidad que viene en las tools de OpenBOR y que te tienes que compilar. Simplemente es hacer "borpak juego.pak" y te lo deja descomprimido en el directorio en el que estés. Sólo te interesa el directorio "data", TODOS los juegos tienen uno.
Pilla el directorio "data" del juego, y lo copias en el mismo directorio donde tengas el ejecutable del OpenBOR.
Crea un archivo de 0 bytes llamado bor.pak, y lo metes en Packs.
Total, que tienes que tener:
OpenBOR
Paks/bor.pak (0 bytes)
data (del juego que sea)
Y ya puedes hacer "./OpenBOR Paks/bor.pak" y te lanzará el juego desempaquetado.

******Another World en la Raspberry Pi******************************************************

Para compilar rawgl para la Raspberry, como rawgl usa desktopgl y no tenemos de eso, hacemos:

-En el Makefile: quitar -DUSE_GL de los CXXFLAGS , -lGL de los SDL_LIBS y graphics_gl.cpp de SRCS
Los CXXFLAGS son: -O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer
Y añade la línea de optimiación agresiva debajo de la original de CFLAGS:
CXXFLAGS += -flto -fomit-frame-pointer
(NO se puede mezclar -fwhole-program con -flto: una o la otra. Y como tenemos más de una unidad de compilación, -fwhole-program no va aquí).

-En mixer.cpp, ajusta el tamanio del buffer de 4096 a 1024
-En systemstub_sdl.cp, descomenta el SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, 1) y ponlo como SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear")

Lanzamos con:
./rawgl --language=us --render=software --fullscreen-ar --datapath=data_dos
(usar --render=original provoca errores como tiras en las piernas de los enemigos en lugar de ser sólidas).

******FLASHBACK en la Rasberry Pi*********

Bajamos los sources de:
http://cyxdown.free.fr/reminiscence/

Instalamos
apt-get install libmodplug-dev --no-install-recommends

Editamos el Makefile y quitamos las librerías de OGG y VORBIS, tocando las líneas:
 #TREMOR_LIBS  := -lvorbisidec -logg <--- Esta la comentamos.
CXXFLAGS += -Wall -MMD $(SDL_CFLAGS) -DUSE_MODPLUG -DUSE_ZLIB -O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Editamos sdl_systemstub.cpp y cambiamos:
desired.samples = 2048;
por
desired.samples = 512;
Y también aniadomos SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()
Así mismo, cambia SDL_INIT_JOYSTICK por SDL_INIT_GAMECONTROLLER en SDL_Init() si quieres joystick.

Creamos el directorio data y allí metemos los datos de la versión MS-DOS.
Dentro de data creamos music y ahí metemos los MODs de:
http://wiibrew.org/w/images/2/2b/Flashbackmods.zip
(NO, no sirven los ficheros de música de AMIGA directamente).

Lanzamos con:
./rs --datapath=./data --fullscreen

********Supaplex en la Pi con OpenSupaplex********************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/sergiou87/open-supaplex.git

Editamos src/sdl2/video.c y:
-Dejamos SDL_WINDOW_FULLSCREEN como SDL_WINDOW_FULLSCREEN_DESKTOP, y quitamos el #ifdef donde está contenido,
 de manera que se aplique ese flag a TODAS las plataformas.
-Cambiamos todas las demás ocurrencias de SDL_WINDOW_FULLSCREEN por SDL_WINDOW_FULLSCREEN_DESKTOP. 
-Añadimos antes de la llamada a SDL_CreateRenderer(): SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Entramos en el directorio linux, editamos Makefile y añadimos a los CFLAGS:

-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Compilamos con make -j4

Copiamos el contenido del directorio resources, tal cual, a ~/supaplex, junto con el ejecutable.


********Instalando ROCKBOX en un Sony NWZ 383 (Walkman MP3)***************************************************

Los archivos que necesitamos están en este hilo:
http://forums.rockbox.org/index.php/topic,43630.0.html

Y las instrucciones confusas aquí
http://www.rockbox.org/wiki/SonyNWZE370Port

PERO para que no tengas que volver a perder tiempo, la solución es esta: 
El bootloader es el mismo para todos los NZW 37x y los 38x. El ROCKBOX en sí, igual: el mismo para todos los modelos.
-Bájate el bootloader, que es el archivo que se llama sonynwze370_rb_firmware.sb. Lo metes en la raíz del dispositivo RENOMBRÁNDOLO a firmware.sb
-Bájate el Rockbox en sí, que es el archivo que se llama rockbox-sonynwze370.zip, y lo descomprimes en la raiz del dispositivo. Te creará el directorio .rockbox
-Resetea el dispositivo, si hace falta a base de meter algo en el agujero de reset que tiene detrás (a mi no me hizo falta pero tuve que conectarlo por USB para que se "despertara"
porque no se encendía tras meter el bootloader y el ROCKBOX en la raíz), y se iniciará en ROCKBOX, o deberia.

******Copiar y pegar usando GNU/Screen**********************************************************************************************************************************

Hacemos CTRL+A y [ , con lo que nos ponemos en modo copia. Ahora nos ponemos donde queramos empezar a copiar, le damos al espacio, seleccionamos el texto a copiar,
le damos al espacio otra vez cuando acabemos y al intro para acabar. Ya tenemos el texto copiado a un buffer. Lo pegamos con CTRL+A y luego ] . 

******Cosas a borrar después de actualizar el firmware en una Raspberry Pi...************************************************************************************************

/lib/modules.bak
/boot.bak

******GRAFX2 en la Raspberry Pi*******************************************************************************************************************************************

Si tenemos SDL2 instalado y funcionando, podemos tener este increíble programa de dibujo en 2D que se usa para sprites y gráficos raster!
Tenemos que tener también SDL2_image con soporte para JPG, PNG y TIFF, así que comprueba que tienes esos formatos soportados al configurar SDL2_image.
Tendrás que instalar para ello libtiff-dev.

Clonamos su repo:
git clone --depth 1 https://gitlab.com/GrafX2/grafX2.git

Editamos src/sdlscreen.c y cambiamos:
SDL_WINDOW_FULLSCREEN
por
SDL_WINDOW_FULLSCREEN_DESKTOP
Y antes de SDL_CreateWindow aniadimos:
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Compilamos con:
make API=sdl2 NOTTF=1 NOLUA=1 -j4

Si queremos que busque los init, skin y demás en el mismo directorio donde tengamos el ejecutable, editamos src/setup.c y tocamos las funciones:
Set_data_directory() : Dejamos sólo la primera línea, "strcpy(data_dir,program_dir);" Comentamos lo demás.
Set_config_directory() : Deejamos sólo una línea que diga: "strcpy(config_dir,program_dir);" Comentamos todo lo demás.

...Y ahora copiamos. al mismo directorio que el ejecutable:
gfx2def.ini
skings
...tienes ambas cosas en share
..Y ahora, editamos gfx2def.ini y cambiamos  el Skin_file, para evitar el error "Error in skin file: Was looking right from 254,139 for a 'mouse cursor', and reached the edge of the image":
Skin_file = skin_modern.png

Lanzamos con:
./grafx2-sdl2 -mode 640x360

******Compilar VICE en la Raspberry Pi*********
Necesitaremos tener instalados los paquetes flex y bison durante la configuración.
Configuramos con:

./configure --disable-sdlui --enable-sdlui2 -v --enable-arch=arm --disable-debug --disable-debug-code --disable-ipv6 --disable-ethernet --disable-rs232 --disable-realdevice --disable-shared-ffmpeg \
--disable-static-ffmpeg --disable-external-ffmpeg --without-oss --without-sdlsound --disable-midi --without-png --without-pulse 

(El -v es porque queremos que compile de modo verbose.)

Nos copiamos el directorio data, que viene con los fuentes, a donde tengamos instalado el ejecutable, x64

Luego le podemos indicar los parámetros de las roms que necesita así:

./x64 -kernal data/C64/kernal -sounddev alsa -basic data/C64/basic -chargen data/C64/chargen -dos1541 data/DRIVES/dos1541

O simplemente pasándole el directorio donde están las ROMs de ese sistema:

./x64 -directory data/C64 -sounddev alsa

Se entra en el menú con F12

******Grabar WIFISLAX moderno en un pendrive de arranque************************************************************************

Extraemos los dos directorios de la ISO, wifislax y boot, a nuestro disco duro.
Formateamos el pen a FAT32. Esto no nos va a dejar ejecutar cosas por temas de permisos de los que carece FAT32, así que ya verás lo que hay que hacer.
Copiamos ambos directorios al pen en FAT32 (el script de instalación, bootinst.sh, va a buscar el LILO en el pendrive, no en la copia de nuestro disco duro).
Copiamos boot/bootinst.sh al disco duro. Está pensado para ejecutarse desde el pen, pero como el pen está en FAT32 no podemos, así que lo editamos y dejamos las líneas
de declaración de ciertas variables así:

TARGET="/dev/sdb1"
MBR=""
MYMNT="/media/manuel/WLX"

Comentamos entero el bloque "# Find out which partition or disk are we using": entero.
Ejecutamos bootinst.sh desde nuestro disco duro, y listo. Si se queja de que no encuentra archivos para instalar el bootloader, lo mandas a la copia local del directorio boot
de la ISO y lo ejecutas desde allí.

*******Aplicar parches ips en Linux***************************************************************************************

Lo hacemos con el UIPS, un parcheador hecho en C de Neil Corlett (sí, el traductor del Seiken Densetsu 2, la gente es la hostia!) de hace mil años.
Clonamos este repo: https://github.com/chungy/cmdpack.git
Compilamos y a correr.

*******Cambiar las fuentes de tamaño en Debian/Lubuntu cuando dpkg-reconfigure console-setup falla************************
El problema es que /lib/udev/console-setup-tty está jodido.
Si hacemos strace /lib/udev/console-setup-tty fbcon, vemos que está buscando un fichero de fuente en /etc/console-setup que no existe, y además lo busca en PSF y nosotros
los tenemos en .psf.gz. Así que ajustamos cosas en /etc/default/console-setup para que busque una fuente que tengamos en /etc/console-setup y se la ponemos ahí.
Intercambia la altura y anchura, descomprime la fuente con gzip.. así hasta que la encuentre.
Fuente: http://unix.stackexchange.com/questions/198791/how-do-i-permanently-change-the-console-tty-font-type-so-it-holds-after-reboot

*******Escritorio Lubuntu sin tearing***************************************************************************************************************************************

Sacado de https://wiki.archlinux.org/index.php/Intel_graphics#Tear-free_video

Creamos /usr/share/X11/xorg.conf.d/20-intel.conf con el contenido:

Section "Device"
   Identifier  "Intel Graphics"
   Driver      "intel"
   Option      "AccelMethod"  "sna"
   Option      "TearFree"    "true"
EndSection

Si no te funcinona glxgears, cambia "sna" por "uxa".

En AMDGPU, sería crear /usr/share/X11/xorg.conf.d/20-amdgpu.conf con el contenido:

Section "Device"
   Identifier  "AMD Graphics"
   Driver      "amdgpu"
   Option      "TearFree"  "true"
EndSection

Reiniciamos el servidor gráfico. Magia!

*******Comprimir un ZIP partiéndolo en varias partes*********************************************************************

Con esto creamos varios volúmenes de 1990 MB cada uno:

zip -r -s 1990m pi4.zip pi4.img

*******Comprimir un PDF*********

gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile=xenon2-compressed.pdf Downloads/Xenon.2-Manual.pdf

******Arrancar e instalar una instalación de Linux en un Toshiba C50-B (o en cualquier cagarro de PC moderno con UEFI)*********

Entramos en el menú UEFI manteniendo presionado F2 al encender. Ponemos como primera unidad de arranque el USB.
Cambiamos el modo de arranque a CSM.
Instalamos y arrancamos desde el disco duro. Si hemos instalado en modo CSM, debería arrancar.
Ya que estás, desactiva SECUREBOOT.
Miseria y muerte a Microsoft y a todos los malnacidos que trabajan en ella.

*******Guardar LOG de una ventana en el IRSSI********

/lastlog -file <archivo>.log

*******SDL1 en la Raspberry Pi**********

SDL1 está roto en la Rpi hasta el punto de que con versiones recientes del hardware, a veces tenemos pantallazo negro.
Para evitarlo, bajamos los dos tar.gz de aquí:

http://malus.exotica.org.uk/~buzz/pi/sdl/sdl1/deb-src/

El más pequeño contiene unos parches que aplicamos con

patch -p1 < nombre_parche.diff

IMPRESCINDIBLE APLICAR EL PARCHE RPI.DIFF!!!! O TENDREMOS PANTALLAZOS NEGROS AL LANZAR PROGRAMAS ALEATORIAMENTE!!!

Configuuramos con mi scrip MAC_ConfigureSDL1.sh que contiene:

CFLAGS="-Ofast -mfpu=vfp -march=armv6j -mfloat-abi=hard" ./configure --disable-video-opengl --disable-video-dispmanx --enable-video-fbcon --disable-video-kms --disable-video-directfb --enable-cdrom --disable-oss --disable-alsatest --disable-pulseaudio --disable-pulseaudio-shared --disable-arts --disable-nas --disable-esd --disable-nas-shared --disable-diskaudio --disable-dummyaudio --disable-mintaudio --disable-video-x11 --prefix="/usr" --disable-input-tslib

make y sudo make install.

El hilo en que se hacía referencia a esto es el siguiente:

https://github.com/raspberrypi/firmware/issues/354


*******DOSBOX STAGING en la Pi***************************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/dosbox-staging/dosbox-staging.git

Instalamos unas dependencias previas:
sudo apt-get install libopusfile-dev --no-install-recommends

mkdir b4
cd b4

Configuramos con:
CFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson .. -Duse_opengl=false -Duse_sdl2_net=false

Compilamos con:
ninja -j4

Copia al directorio ~/dos tanto el ejecutable dosbox como el subdirectorio subprojects tal cual.
Cuando lo ejecutes te genera un .conf en ~/.config/dosbox. Cópialo a ~/dos, y se lo puedes pasar a dosbox con:
./dosbox -conf dosbox.conf

*******DOSBOX en la Pi**************************************************************************************************************

Clonamos el repo principal, que sigue estando en SF:

svn checkout https://svn.code.sf.net/p/dosbox/code-0/dosbox/trunk dosbox-code-0

Bajamos el último parche de este hilo y lo aplicamos:

https://www.vogons.org/viewtopic.php?f=41&t=34770&start=120

patch -p0 < parche.patch

Editamos el configure, y cambiamos "-g -O2" por los flags:
-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer
porque si no algunos Makefiles van a tener los flags antiguos.

Editamos configure y ponemos a "no" todos los have... relacionados con opengl y x11.

Configuraríamos para SDL2. 

CXXFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ./configure

Cambiamos "AR = ar" por "AR = gcc-ar" y "RANLIB = ranlib" por "RANLIB = gcc-ranlib" en todos los Makefile (hay varios, en distintos subdirectorios) y forzamos los CFLAGS
que nos interesan en ellos, ya que no llegan desde el configure a algunos Makefiles, con:

find ./ -name Makefile -exec sed -i 's/AR = ar/AR = gcc-ar/g' {} \;

find ./ -name Makefile -exec sed -i 's/RANLIB = ranlib/RANLIB = gcc-ranlib/g' {} \;

find ./ -name Makefile -exec sed -i 's/-g -O2/-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer/g' {} \;

(Siempre que ejecutes configure, te tocará sustutuir AR y RANLIB y reajustar los CFLAGS con el find como acabas de ver, porque el configure lo pone mal otra vez en los makefiles).

Luego en el conf nos interesará tener la opción output=texture o texturenb. Pasa que texturenb a veces falla, usa texture que se ve mejor.
En renderer pon renderer=auto y fullscreen=true, o no se verá nada. SDL2 luego ya usa el renderer "opengles2" por debajo... Pero dosbox no admite este valor.
El caso es que no dejes puesto renderer=opengl porque ese no se ve.
Pon el scaler a none también.

NOTA: A continuación indico cómo activar el cynarec en ARM. No hace falta hacer todo eso, porque ya lo detecta solo, e incluso funciona dynarec para ARMv8.

Hemos encontrado las las instrucciones para dynarec ARM y para UNALIGNED MEMORY ACCESS en estas páginas:

https://www.raspberrypi.org/forums/viewtopic.php?f=78&t=95421
http://boards.openpandora.org/topic/7544-dosbox-dynrec-update/

El asunto se reduce a dejar config.h con estas cosas así para Pi1:

#define C_DYNREC 1
#define C_TARGETCPU ARMV4LE
#define C_UNALIGNED_MEMORY 1

Así para Pi2 y Pi3:

#define C_DYNREC 1
#define C_TARGETCPU ARMV7LE
#define C_UNALIGNED_MEMORY 1

Yo esto lo pongo más o menos en la línea 99, debajo de 
/* Define to 1 to use a unaligned memory access */
/* #undef C_UNALIGNED_MEMORY */
...habiendo comentado antes el #define C_TARGETCPU UNKNOWN que hay justo encima. No parece necesario porque lo redefinimos nosotros, pero por si acaso.

Meto el bloque entero y así funciona.

NO TE OLVIDES de usar core=dynamic en el .conf: deberías tener ~35-37% de uso de CPU en TOP.

PUEDES QUITAR el splash screen comentando la parte donde se crea y se usa splash_surf en src/gui/sdlmain.cpp

Ahora sólo queda parchear el refresco de pantalla...Mira a continuación cómo añadir un control de refresco!

AÑADIR CONTROL DE REFRESCO DE PANTALLA DESDE FICHERO DE CONFIGURACIÓN
=======================================================================

La info actualizada la he sacado de esta versión de dosbox:
https://github.com/joncampbell123/dosbox-x
mirando en su vga_draw.cpp.

Empezamos con src/gui/sdlmain.cpp
Busca la línea donde recupera el valor de "display" del fichero de configuración. Es así esa línea que buscas:

sdl.displayNumber=section->Get_int("display");

Vale, pues justo encima,o debajo, pero por ahí, nosotros vamos a recuperar el valor de "refresh", de este modo:
      vga.refreshRate=atof(section->Get_string("refresh"));
      LOG_MSG("Physical refresh rate %f \n", vga.refreshRate);

Ahora tenemos que añadir ese nuevo valor a los valores del fichero. Busca donde se añade el valor "fullscreen", por ejemplo, que es una sección que tiene esta pinta:
        Pbool = sdl_sec->Add_bool("fullscreen",Property::Changeable::Always,false);
        Pbool->Set_help("Start dosbox directly in fullscreen. (Press ALT-Enter to go back)");

Pues debajo o así añadimos nosotros refresh, de una forma parecida:
       // Add refreshrate
        Pstring = sdl_sec->Add_string("refresh",Property::Changeable::Always,"60.0000");
        Pstring->Set_help("Screen refresh rate.");

Ahora, nos vamos al fichero include/vga.h, que lo ven tanto vga_draw.cpp como sdl_main.cpp, y en la estructura VGA_Type, al final, añadimos:
double refreshRate;

Ahora ya lo tenemos: sólo queda irse a src/hardware/vga_draw.cpp y cambiar esto:
fps=(double)clock/(vtotal*htotal);
..por esto otro:
       // Force the VGA refresh rate by setting fps and bending the clock to our will
        fps=vga.refreshRate;
        //clock=((double)(vtotal*htotal))*fps;

Por último, a nuestro .conf le añadimos algo como:
refresh=60.016804;
Eso debería darnos un refresco de 60.016804 HZ, que es la apropiada con audio a 44100Hz.

CAMBIA BOTONES O TECLAS
========================

Sacamos el mapper con CTRL+F1. Hacemos los cambios que queramos, y luego el fichero .map lo especificamos en el campo mapperfile del .conf que vayamos a usar.

JUEGOS DE JAVA DE MÓVIL CON FREEJ2ME
====================================

LO PRIMERO es entender que necesitamos un JAR que nos permita a su vez cargar los JAR de los juegos con la máquina JAVA de nuestra máquina, y además necesitamos
un interface SDL2 que va a pintar la pantalla de JAVA usando SDL2.

Instalamos dependencias previas:
sudo apt-get install ant

Nos bajamos los últimos sources:
git clone --depth 1 https://github.com/hex007/freej2me.git

Entramos en freej2me y simplemente escribimos:
ant
Se nos generará build/freej2me-sdl.jar.
Creamos el directorio ~/java, y copiamos el freej2me-sdl.jar que acabamos de generar a ~/java
y metemos ahí los juegos que nos bajemos en .jar

Ahora generamos el interface de gráficos SDL, llamado sdl_interface. Para ello, entramos en src/sdl2, y hacemos:
make -j4
sudo make install
Esto simplemente nos mandará el interface de gráficos sdl_interface a /usr/local/bin

Ejecutamos el juego que queramos con:
java -jar freej2me-sdl.jar DoomRPG.jar 240 320 -i linear
Piensa que los juegos son verticales, por eso doy una anchura de 240 y una altura mayor, de 320.


FS-UAE (FSUAE), EMULADOR DE AMIGA BASADO EN SOURCES ACTUALIZADOS DE WINUAE
==========================================================================

INSTRUCCIONES ESPECÍFICAS PARA PI4 QUE NO DEBES PERDER DE VISTA:
https://github.com/FrodeSolheim/fs-uae/blob/master/docs/raspberry-pi-4.md

Instalamos dependencias previas:
sudo apt-get install gettext --no-install-recommends

Clonamos su repo:
git clone --depth 1 https://github.com/FrodeSolheim/fs-uae.git

Ejecutamos el script bootstrap incluido con los sources, y ya podemos ejecutar ./configure

Configuramos con:
CFLAGS="-O3 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-O3 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
./configure --without-x11 --with-alsa --without-midi --without-libmpeg2 --without-openal --disable-x86 --disable-qemu-cpu --disable-drivesound --disable-netplay --disable-slirp

Editamos src/fsemu-background.c y comentamos la línea:
#define FSEMU_WITH_BACKGROUND 1

Creamos el directorio ~/amiga, y ahí copiamos el ejecutable fs-uae, fs-uae.dat y los directorios "data" y "fsemu" que viene con los sources.

Tenemos una configuración mínuma de referencia que viene con los docs, en docs/examples/example.conf
Podemos copiarla como ~/amiga/configs/amiga500.conf y se la pasamos al emulador como:

./fs-uae configs/amiga500.conf

Configuración de Amiga 500 que tengo:

[config]
amiga_model = A500
kickstart_file = ../roms/kick13.rom
floppy_drive_0 =  ../disks/enchanted.adf
fullscreen = 1 
fullscreen_mode = fullscreen

Podemos por ejemplo correr fs-uae con una configuración de un 1200 con:
./fs-uae configs/1200.fs-uae --fullscreen=1

OJO! Queda mucho por hacer en la versión 4 del emulador y muchas opciones de vídeo son ignoradas por ahora.
Por ejemplo, para tener 50Hz, el monitor debe soportar 1080P a 50Hz que es lo que el emulador intenta establecer en
fsemu/src/fsemu-sdlwindow.c, en la función fsemu_sdlwindow_find_mode(). Puedes hacer que ponga un modo de 720p a 50Hz
mientras tanto, si lo necesitas.

Puedes ver otras opciones de vídeo que le puedes pasar como parámetro al ejecutable en:
https://fs-uae.net/video-options

CORE DOSBOX PURE
================

Clonamos su repo:

git clone --depth 1 https://github.com/libretro/dosbox-pure.git

Compilamos con make -j4 sin más.

Para que no nos molesten las hotkeys de RetroArch al teclear palabras, tenemos que poner una tecla para el HOTKEY ENABLE en:
Settings -> Input -> Hotkeys -> Hotkey Enable
Al tener configurada una tecla para HOTKEY ENABLE, las hotkeys NO están activas a no ser que pulses esa tecla, y así no molestan.
Y recuerda que puedes quitar todas las hotkeys una a una poniéndote encima de ellas en Settins -> Input -> Hotkeys y presionando la tecla DELETE.

Los juegos que se usan (en ZIP) son los de la colección EXODOS, que está aquí:
https://exodos.the-eye.us/

CORE DOSBOX RETROARCH: ACTIVAR DYNREC
=======================================

Hay que pasarle los flags de dynrec, unaligned memory y tal en el Makefile.libretro. Las platform definitions para la Pi2 están así:

# Raspberry Pi 2
else ifeq ($(platform), rpi2)
   TARGET := $(TARGET_NAME)_libretro.so
   LDFLAGS += -shared -Wl,--version-script=libretro/link.T
   fpic = -fPIC

   ENDIANNESS_DEFINES := -DLSB_FIRST
   COMMONFLAGS += -DARM
   COMMONFLAGS += -mfloat-abi=hard
   COMMONFLAGS += -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard -fomit-frame-pointer -fstrict-aliasing
   COMMONFLAGS += -DDISABLE_EXCEPTIONS
   COMMONFLAGS += -DC_DYNREC -DC_TARGETCPU="ARMV7LE" -DC_UNALIGNED_MEMORY
   IS_X86 := 0
   NEED_BPP := 16


Luego nos vamos a

libretro/dosbox.cpp

Buscamos el bloque:

const char* cores[] = { "auto",
#if (C_DYNAMIC_X86) || (C_DYNREC)
		"dynamic",
#endif
		"normal", "simple",0 };
Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"auto");

Y lo dejamos así:

const char* cores[] = { 
                "dynamic"};
Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"dynamic");

Compilamos con:

make -f Makefile.libretro -j8 platform=rpi2

*******OpenXComm, el UFO para la Pi***********************************************

Clonamos su repo:
git clone --depth 1 https://github.com/OpenXcom/OpenXcom.git
(...no está listo para compilar contra SDL2 aún).

*******jfduke3d, el port güeno del duke3d para Pi*********************************

Es el port original en el que colabora Ken Silverman!
Clonamos su repo de:
git clone --depth 1 https://github.com/jonof/jfduke3d.git
git submodule update --init

Editamos jfaudiolib/src/driver_sdl.c, y dejamos spec.samples a 512, comentando el while que hay debajo.
Editamos jfbuild/src/sdlayer2.c, y cambiamos, justo antes de SDL_CreateRenderer(), en la llamada a SDL_SetHint(), "nearest" por "linear".
Editamos jfaudiolib/Makefile, y eliminamos el "-g" ese que hay ahí perdido.

Compilamos con:
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
make -j4 WITHOUT_GTK=1 RELEASE=1 USE_POLYMOST=1 USE_OPENGL=USE_GLES2

Mete el duke3d.grp en el mismo directorio que el ejecutable.
Para tener música con .ogg: Mete un zip con la música en el mismo directorio donde tengas el duke3d.grp.
Y lanzaríamos el juego con:
./duke3d -g<nombre_archivo_zip_música>
RECUERDA: entre el -g y el nombre de archivo NO hay ningún espacio. Va todo seguido. 
Por ahora, usamos este: https://sc55.duke4.net/

Si quisieras música en MIDI, podrías meter un .sf2 en el mismo directorio donde tengas el duke3d.grp.

LOS CONTROLES CON 8BitDo SN30 Pro
--LOS EJES--
LEFT X - STRAFING - 50
LEFT Y - MOVING - 50
RIGHT X - TURNING - 12
RIGHT Y - LOOKINGUPANDOWN - 12
RIGHT TRIGGER - (+)FIRE
--LOS BOTONES--
A - JUMP
B - OPEN
X - INVENTORY
Y - JETPACK
LEFTSTICK - CROUCH
LEFTSHOULDER - PREVIOUS WEAPON
RIGHTSHOULDER - NEXT WEAPON
BACK - MAP
START - SHOW MENU

*******StarControl 2 (Ur-Quan Masters o UQM) en la Pi**********************************

Lo primero, vamos con una dependencia previa que tiene: libmikmod. La versión que viene incluida suena a rata en la Pi,
instalar libmikmod-dev nos arrastra dependencias de pulseaudio, X11 y la hostia, etc. Así que sólo nos queda instalar
nuestra propia build de libmikmod.
Para ello, clonamos su repo, configuramos, compilamos e instalamos así:

git clone --depth 1 https://github.com/sezero/mikmod.git
cd libmikmod
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_PULSE=0 -DENABLE_OSS=0 -DENABLE_DOC=0 \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
sudo make install

Y AHORA VAMOS A POR EL UQM EN SÍ:

Bajamos los últimos sources estables de:
https://sourceforge.net/projects/sc2/files/UQM/

Descomprimimos los sources, y ejecutamos:
./build.sh uqm config
Activamos y desactivamos lo que queramos, sobre todo estas cosas:
-Compilar una RELEASE en vez de una versión DEBUG.
-Usar libmikmod del sistema, NO el libmikmod incluido que como ya hemos dicho suena mal en la Pi.

Ahora editamos build.vars, y ahí añadimos las CFLAGS y CXXFLAGS de la Pi4:
-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Ahora editamos src/libs/graphics/sdl/sdl2_pure.c, y en la llamada de SDL_CreateRenderer(), metemos los flags:
SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC

Ahora editamos src/libs/sound/mixer/sdl/audiodrv_sdl.c, y cambiamos todas las ocurrencias de:
desired.samples = 4096;
por:
desired.samples = 1024;

Compilamos con:
./build.sh uqm

Ahora creamos:
~/sc2
Y copiamos ahí el ejecutable "uqm" que acabamos de obtener.
Ahora copiamos el directorio "content" que viene con los sources a ~/sc2, tal cual el directorio con todo lo que tiene dentro.
Ahora creamos:
~/sc2/content/packages
Descargamos los datos del mismo sitio que los sources (con uqm-content.uqm es suficiente) y los metemos en:
~/sc2/content/packages

Y ya está.
Para que no nos mande mensajes a la consola, lo podemos ejecutar con:
./uqm --logfile=/dev/null
Se sale del juego con F10 o F12.

*******vkQuake en la Pi***********************************************************

Bajamos la última estable de:
https://github.com/Novum/vkQuake/releases

cd Quake

Editamos Makefile y quitamos -lX11, y ponemos MP3LIB=mad a MP3LIB=mpg123 (para no tener que instalar libmad!)

make -j4

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" make -j4

*******Quakespasm en la Pi*******************************************************

Ahora que SDL2 soporta OpenGL de escritorio sobre KMSDRM sin depender de las X11, es hora de volver a Quakespasm.

Clonamos su repo:
git clone --depth 1 https://github.com/sezero/quakespasm.git

Entramos en el directorio Quake, editamos Makefile para cambiar -lGL por -lOpenGL, y compilamos con:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" make -j4 USE_SDL2=1 USE_CODEC_MP3=0 USE_CODEC_WAVE=0

OJO: Guarda su configuración en el subdirectorio id1 de donde tengas el ejecutable!
Para tener 60FPS constantes, puedes editar id1/config.cfg y poner:
r_oldwater "1"
gl_texturemode "GL_LINEAR"
Y poner como resolución 720x400, que mantiene el ratio original, ocupando así la pantalla completa a 16/9 sin deformarse. 

Los pak0.pak y pak1.pak van en ./id1
La música en OGG y con nombres de archivo como track01.ogg.. track11.ogg, va en ./id1/music

*******Core TYRQUAKE en RetroArch************

Copia el core a ~/.config/retroarch/cores
Los datos del juego (los .PAK) van en un subir llamado id1, así en minúsculas. La música, en ogg, va en id1/music.

Se lanza con:
retroarch -L ~/.config/retroarch/cores/tyrquake_libretro.so id1

Pon en "Options" el "Frame Rate" a 60.

Nada más empezar, los controles no te responderán. Para arreglarlo, ve a "controls->port 1 controls"
y "Device Type" ponlo a "Gamepad Classic", y dale a "save core remap file".
O puedes tener controles tipo HALO: para ello, pon "Device Type" a "Gamepad Modern" y luego en "Options" activar el "Invert Y Axis".

Y para cambiar cosas del juego y que se conserven los cambios, mételos en id1/autoexec.cfg.
Por ejemplo, con esto queda muy a mi gusto el tamaño de pantalla, escalado de texturas, animaciones suaves, volúmen...

viewsize 120 
r_lerpmodels 1.00
r_lerpmove 1.00
dither_filter 1.00
gamma 0.90
bgmvolume "0.500000"
volume "0.200000"
bind F1 ""

Y desactiva lo de "load dummy core on shutdown", dentro de settings->core, si no quieres que al darle a quit en el menú del Quake
te mande al menú de RA.

*******TYRQUAKE standalone en la Raspberry Pi****************************************************************************************************

clonamos su repo:
git clone --depth 1 git://disenchant.net/tyrquake

Editamos el Makefile y cambiamos:
GL_LIBS     += GL
por:
GL_LIBS     += OpenGL

Compilamos con:
make USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4

POR DEFECTO compila tanto el motor software como el modotor GL, pero podemos compilar sólo uno de ellos:
-Si sólo quisiéramos el motor por software, haríamos:
make bin/tyr-quake USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4
-Si sólo quisiéramos el motor GL haríamos:
make bin/tyr-glquake USE_SDL=Y OPTIMIZED_CFLAGS=Y DEBUG=N -j4

*******EN RASPBIAN NO PUEDO DEBUGEAR PROGRAMAS EN C++ QUE HAN SIDO COMPILADOS CON DISTCC*********************************************************
Da todo el rato "no symbol <loquesea> in current context".
Hay que actualizar gdb...

Desisntalamos nuestro viejo gdb, el que viene con Raspbian. No tiene dependencias graves, sólo debería sel ese paquete y ya:

sudo apt-get purge gdb

Instalamos texinfo y libncurses5-dev:

sudo apt-get install texinfo libncurses5-dev

Bajamos los últimos sources de http://ftp.gnu.org/gnu/gdb/. La versión 7.9.1 va perfectamente.
Hacemos

./configure --prefix="/usr"
make -j8
sudo make install -j8

Y listo. Con el nuevo gdb ya podemos debugear cosas compiladas con el distcc, ya que encuentra los debug simbols sin problemas y podemos ir línea a línea y todo eso.

*******Profiling de programas usando OPROFILE*********

Puede que necesitemos activado el soporte de Oprofile en el kernel: PARA PROGRAMAS NORMALES NO PARECE HACER FALTA ESTO.
General Options, casi abajo del todo, Profiling y dentro de eso Oprofile.

Hay que bajar los sources y compilarlos. Pide ciertas librerías:
libiberty está en libiberty-dev. 
bfd está en binutils-dev.
Las demás librerías que va pidiendo se ve bien su nombre de paquete.

Lo normal es hacer el profiling según lanzamos el programa:

operf <ejecutable>

Para hacer el profiling de un programa en ejecución, 

operf --pid=<PID_DEL_PROGRAMA>

Luego, cuando acabemos de usar el programa, usaríamos opereport para leer el informe que hemos generado (http://oprofile.sourceforge.net/examples/):

opreport --demangle=smart --symbols `which scummvm`

Si te salen cosas como 
138941   69.8828  libc-2.19.so             /lib/arm-linux-gnueabihf/libc-2.19.so
eso quiere decir que el 69% de la CPU se está usando en una función de libc, pero como no tienes los debug symbols de libc instalados, no te la muestra.
Así que instala libc6-dbg y te saldrán todas las llamadas.

*******Añadir username, hostname  y ruta actual al prompt del bash************************************************
Añade esto a .bash_profile:

PS1="\u@\H\w$ "

******Quitar versión de kernel y lastlogin************************************************************************

Editamos /etc/pam.d/login
y comentamos
#session optional pam_lastlog.so

*******El comando IP**********************************************************************************************

Fuente: http://www.tecmint.com/ip-command-examples/

Añadir una IP fija:
ip addr add 192.168.5.10/24 dev eth0

Para confirmar:
ip addr show

Ahora añadimos el gateway:
ip route add default via 192.168.5.7

Probamos que podemos salir a internet:
ping 8.8.8.8

Lo único que nos faltaría es poner un servidor DNS en /etc/resolv.conf, para poder hacer ping a google y demás.
nameserver 8.8.8.8

También es posible desconectar el cable, etc

*******Mantener más o menos en hora sistemas que no tienen reloj interno (Rpi, Cubie2...)*********************************************
en Debian, instala el paquete "fake-hwclock", pon el sistema en hora y reinicia. Ya guarda la hora del último aparago y más o menos nos vale para evitar clock skews.

*******Ver los modos de vídeo disponibles usando el interface KMS/DRM*****************************************************************

modetest |grep -50 modes |more

*******Cambiar el modo con xrandr*****************************************************************************************************

Listar modos de vídeo: xrandr -q
Cambiar el modo de vídeo: 
xrandr --output LVDS1 --mode 640x480

*******Acceso a piratebay cuando la bloqueen desde europa********************************************************************************************

No hace falta ni TOR

Haced un ping o un nslookup a thepiratebay.se, tendreis la IP, los filtros de las operadoras suelen ser por nombres y no por IPs

Sustituid la IP que os salga por la URL en el navegador y ya ;) muahahahaha... 

*******Imágenes de CD: cambios de formato, etc**********

Para pasar de una combinación CUE+WAV+ISO a CUE+BIN, usamos el CDMage en Wine. Es un programa MUY antiguo, pero funciona. 
Simplemente abrimos el CUE del combo CUE+WAV+ISO, y luego le damos a SAVE AS... y el programa lo guarda como CUE/BIN!!

Para hacer lo contrario, ripear de CUE/BIN a CUE+WAV+ISOS, usamos otro programa de Windows: el BINCHUNK.EXE.
Viene en el parche del Castlevania Rondo of Blood al inglés.

*******Las tildes de Libreoffice no funcionan tras cambiar entre libreoffice y otro programa********

Instala el paquete libreoffice-gtk, y arreglado.
Recuerda: libreoffice-gtk. Es un paquete de integración.

*******Ver la configuración del kernel en ejecución****************

Para que nos aparezca /proc/config.gz, hacemos:

modprobe configs

Ahora ya podemos buscar con ZGREP directamente:

zgrep PREEMPT /proc/config.gz

*******Deshabilitar el three-finger salute (ctrl-alt-sup)**********

En algunos casos puede ser importante por seguridad, o porque arrancas con un script mínimo custom, sin sistema init.
En ese caso el kernel no sabe hacer nada a parte de "botonazo" al recibir la señal: normalmente el tratamiento
de de la señal se especifica en /etc/inittab pero sin un proceso init ese fichero no lo lee ni el gato, por lo que hacer
ctrl-alt-sup implica un reinicio inmediato sin sincronizar los discos.

Para ello, podemos ver el estado de las variables de configuración del kernel con: sysctl -a
Podemos ver el estado de la variable que nos interesa: sysctl kernel.ctrl-alt-del
Y ahora, podemos deshabilitar el ctrl-alt-sup así: sysctl -w kernel.ctrl-alt-del=0

TAMBIÉN PODRÍAMOS editar /etc/sysctl.conf y añadir allí kernel.ctrl-alt-del=0, o incluso hacer:
echo 0 > /proc/sys/kernel/ctrl-alt-del

OJO: Al deshabilitarlo, en un sistema sin init es probable que tengamos kernel panic al matar el proceso con PID1 (es decir,
al acabar nuestro script de inicio). Supongo que porque el kernel usa el mismo vector para el ctrl-alt-sup que para reiniciar
mediante el comando reboot. Ni idea.

*******Preparar el portátil como router para salir a internet desde la Raspberry Pi u otra placa conectada a él por ethernet************

Al router (el portátil, por ejemplo, que es el que se conecta a internet) le ponemos una IP fija en el mismo rango que el cliente.
En Lubuntu es tan fácil como crear una conexión ethernet nueva en el gestor de redes. 
CUIDADO!!! CUIDADO!!! NO LE PONGAS un gateway o puerta de enlace, porque LA CONEXIÓN WIFI DEJARÁ DE FUNCIONAR AL PONER EL CABLE SI LO HACES.

<BLOQUE DEBIAN> 

En DEBIAN con LXQT, que usa connman (con su GUI llamada Connman UI), hacemos lo mismo pero a mano, así:
Averiguamos el nombre que le da connman a nuestra conexió ethernet:
connmanctl services
...vemos este, que es el cableado: ethernet_3822e2bae00a_cable 

AHORA, creamos la conexión con IP estática así:
connmanctl config ethernet_3822e2bae00a_cable --ipv4 manual 192.168.1.27 255.255.255.0
...Esta conexión quedará guardada automáticamente en /var/lib/connman/ethernet_3822e2bae00a_cable/settings

<FIN BLOQUE DEBIAN>

Ahora editamos /etc/sysctl.conf y descomentamos la línea
#net.ipv4.ip_forward=1
Añadimos el binding a las IPtables:
sudo iptables -t nat -A POSTROUTING -o wlo1 -j MASQUERADE
Donde digo wlo1, me refiero al interface con el que el servidor se conecta a internet.
Antes de la 14.04 de Lubuntu, la wifi era eth1, luego fue un tiempo wlan0... así que fíjate bien.
Si queremos que estas cosas empiezen a funcionar sin reiniciar, hacemos
echo 1 > /proc/sys/net/ipv4/ip_forward
Ahora salvamos las IPtables:
sudo iptables-save | sudo tee /etc/iptables.sav
Y nos aseguremos de que se carguen al reiniciar. Para ello, editamos el crontab así:
sudo crontab -e
Y le añadimos la línea:
@reboot /usr/sbin/iptables-restore < /etc/iptables.sav
Recuerda crear una conexión en el servidor que sea del mismo rango que la IP fija del cliente,
y en el cliente poner como gateway la IP del servidor (también en RISC OS!!!),
añadir el servidor dns en /etc/resolv.conf (sólo en LINUX, claro) si hace falta, etc...
Lo típico de /etc/network/interfaces, que tienes más abajo en varios sitios.

*******No tengo rc.local! Dónde añado cosas al inicio??*********************************************************************************************

En las versiones actuales de Debian/Ubuntu, el servicio rc-local, que leía comandos de /etc/rc.local, no viene ya, así que tenemos dos opciones:

OPCIÓN 1: Añadir cosas al crontab. Es la opción más simple.

Editamos el crontab
sudo crontab -e
Y ahí al final le añadimos la línea del comando que queramos, pero con la ruta completa donde está el comando. Además, si queremos que
lo que sea se ejecute al inicio, le ponemos delante @reboot. Así:
@reboot <COMANDO CON SU RUTA COMPLETA>

OPCIÓN 2: Crearnos un servicio rc-local

sudo vim /etc/systemd/system/rc-local.service
..con el contenido:
[Unit]
Description=/etc/rc.local Compatibility
ConditionPathExists=/etc/rc.local

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
StandardOutput=tty
RemainAfterExit=yes
SysVStartPriority=99

[Install]
WantedBy=multi-user.target

Ahora creamos /etc/rc.local con este contenido:
#!/bin/sh -e
#
# rc.local

exit 0

Ahora lo hacemos ejecutable:
sudo chmod +x /etc/rc.local

Ahora metemos en él lo que necesitemos, antes del exit 0, lógicamente. Habilitamos el servicio, lo lanzamos, y comprobamos su status:
sudo systemctl enable rc-local

sudo systemctl start rc-local.service
sudo systemctl status rc-local.service

... y ya debería ejecutarse lo que hayamos puesto en /etc/rc.local

*******Averiguar IP externa************************************************************************************************************************

curl ipecho.net/plain ; echo

*******Conocer la IP de un equipo de casa en todo momento desde fuera, mediante un email cada vez que cambia*****************************************

Para linuxeros en general: Recibir un correo con la IP de tu equipo de casa (sólo Linux):

INSTALAR PAQUETES
sudo apt-get install curl mutt ssmtp

CONFIGURAR SERVICIO DETECTA IP
sudo nano /root/notify-ip
######################################
#!/bin/bash
email=USERNAME@gmail.com
if [ ! -e /tmp/ip ]; then
curl -s ifconfig.me > /tmp/ip
fi
curl -s ifconfig.me > /tmp/ip2
newip=$(diff /tmp/ip /tmp/ip2 | wc -l)
if [ $newip -gt 0 ]; then
mv -f /tmp/ip2 /tmp/ip
cat /tmp/ip | mail -s "CAMBIO DE IP DINAMICA" $email
else
rm /tmp/ip2
fi
######################################
sudo chmod +x /root/notify-ip

CONFIGURAR SERVIDOR DE CORREO
sudo nano /etc/ssmtp/ssmtp.conf
root=USERNAME@gmail.com
mailhub=smtp.gmail.com:587
rewriteDomain=
hostname=USERNAME@gmail.com
UseSTARTTLS=YES
AuthUser=USERNAME
AuthPass=PASSWORD
FromLineOverride=YES

CONFIGURAR PLANIFICADOR DE TAREAS (cada 30 mins)
sudo crontab -e
30 * * * * /root/notify-ip | date >> /tmp/notify-ip.log

sudo service cron restart 

*******Captura de pantalla en Linux y apertura automática con el PINTA*******************************************************************************

Creamos un script, captura, con permisos de ejecución y el siguiente contenido:

gnome-screenshot --file=captura.png
pinta captura.png

Lo enviamos a /usr/bin

Ahora editamos ~/.config/openbox/lubuntu-rc.xml (NO editamos /etc/xdg/openbox... porque ESO LO IGNORA), y buscamos Print.
Vemos que viene la combinación A-Print (Alt+Print screen) para capturar la pantalla. La dejamos sólo como Print, y entre <Command> y </Command>
ponemos simplemente captura. Listo.

*******Whatsapp en Linux**************************************************************************************************************************

Más fácil que mear en pared.
Nos bajamos el plugin para pidgin de aquí:  http://davidgf.net/nightly/whatsapp-purple/
O de github si lo queremos compilar (https://github.com/davidgfnet/whatsapp-purple), pero vamos, que desde la página de binarios va bien.
PARA COMPILARLO necesitamos tener instalados los paquetes libpurple-dev y libfreeimage-dev, o nos faltarán cabeceras.

Una vez que tenemos el binario, bajado o compilado por nosotros, lo mandamos a /usr/lib/purple-2, que es donde todos los programas basados en libpurple, incluído pidgin,
buscan los plugins.

Pero claro, necesitamos un user y pass. El user será el número de teléfono con el 34 delante. El pass lo tenemos que hacer registrándonos.
Para ello, usamos yowsup-cli del paquete yowsup: https://github.com/tgalal/yowsup
Clonamos el repo, instalamos python-dateutil, y damos permisos de ejecución al script yowsup-cli en python que está en src.
INstalamos esto: sudo apt-get install python-dateutil
Ahora hacemos:

./yowsup-cli registration --requestcode sms --phone 34620626230 --cc 34

Y nos llegará un mensaje al móvil con un código para registrarnos. Así que hacemos:

./yowsup-cli registration --register 396-299 --phone 34620626230 --cc 34

Sustituimos 396-299 por el código, obviamente.
Al acabar este último comando, nos dará un password. Ese password lo podemos meter en nuestro fichero config, y/o lo podemos usar ya
directamente en el plugin de pidgin como password de la cuenta, de tal manera que mi cuenta es:

login: 34620626230
pw: ymcAunpgwsfsdDFHK4FSHPHJqxM=

Ahora ya podemos agregar contactos de whatsapp con normalidad!

Si tienes problemas de conectividad, edita ~/.purple/accounts.xml y busca el servidor, versión de android, puerto...


*********Evitar desconexión de red WIFI cuando la batería está baja*****************

Editamos este fichero:

sudo vim /etc/NetworkManager/conf.d/default-wifi-powersave-on.conf

y ponemos
wifi.powersave = 2
(Viene puesto a 3, que es "default", y lo ponemos a 2 que es "disable").

Reiniciamos el sistema o hacemos:

systemctl restart NetworkManager

..Y listo.

*************HACER FUNCIONAR PINCHO WIFI con MT7601U en Linux********************

El kernel trae ya los módulos necesarios, pero hay que bajarse el firmware:

wget wget -c 'http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/plain/mt7601u.bin'

...Y meterlo en su sitio:

cp mt7601u.bin /lib/firmware/

Si por alguna razón no tienes wlan0, mira dmesg.

Este driver sí soporta el modo nl80211, así que la línea de wpa_supplicant queda así:

wpa_supplicant -iwlan0 -D nl80211 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

*************HACER FUNCIONAR PINCHO WIFI con RTL8188EU en Linux******************

Instalamos dependencias previas:
apt-get install build-essential linux-headers-amd64 git

Clonamos el repo:
git clone --depth 1 https://github.com/lwfinger/rtl8188eu.git

Instalamos el nuevo módulo:
make
make install
cp rtl8188eu/rtl8188eufw.bin /lib/firmware/rtlwifi/

depmod -a

update-initramfs -u

modprobe 8188eu

Ten en cuenta que el chip rtl8188eu NO SOPORTA el driver nl80211, así que en el script WIFIUP,
vez de poner -D nl80211, tiene que poner -D wext, que es el driver viejo.
Total, que la llamada a wpa_supplicant queda así:

wpa_supplicant -iwlan0 -D wext -c/etc/wpa_supplicant/wpa_supplicant.conf -B

*********NO funciona la conexión con una tarjeta de broadcom (módulo b43)***********

Si miras 
dmesg | grep err
verás queSE QUEJA DE QUE LE FALTAN LOS FICHEROS DEL FIRMWARE. Tendrías que instalar el b43-fwcutter... pero claro, no tienes internet. (Si tienes internet, simplemente
instala firmware-b43-installer
Vale, la solución es descargar a mano desde otro ordenador con conexión:
http://mirrors.kernel.org/ubuntu/pool/main/b/b43-fwcutter/b43-fwcutter_015-9_amd64.deb
http://www.lwfinger.com/b43-firmware/broadcom-wl-5.100.138.tar.bz2

Ahora descomprime, recorta el hardware y déjalo instalado:

sudo dpkg -i b43-fwcutter_015-9_amd64.deb
tar xfvj broadcom-wl-5.100.138.tar.bz2
sudo b43-fwcutter -w /lib/firmware broadcom-wl-5.100.138/linux/wl_apsta.o

Instrucciones sacadas de:
https://askubuntu.com/questions/730799/installing-firmware-b43-installer-offline

*********Conexión WIFI lenta con BCM4313*********************************************
Para arreglarlo, líbrate de los drivers b43 que son una mierdaca.

sudo apt-get install bcmwl-kernel-source
sudo modprobe -r b43 ssb wl
sudo modprobe wl

reboot and ejoy! :)

Si no tienes wifi en absoluto, instala el paquete firmware-b43-installer y reinicia, a ver si hay suerte.

********Establecer el niceness de un programa siendo usuario******************************************************************************************

Editamos /etc/security/limits.conf y añadimos la fila:
pi 	-	nice	-20

Ahora podemos lanzar el programa con nice -n -10 <nombre_programa>

********DOSBOX en ARM**************************************************************************************************************

Nos bajamos el archivo svn de aquí: http://www.dosbox.com/wiki/BuildingDOSBox
Si queremos el ARM dynarec, tras ejecutar el ./configure tenemos que editar el config.h y añadir:
#define C_DYNREC 1
#define C_TARGETCPU ARMV7LE
#define C_UNALIGNED_MEMORY 1
Cuidado, que estos valores ya estarán undef en otras partes de fichero o con valores distintos.
La info de cómo habilitar el dynanrec ARM viene de aquí: http://www.vogons.org/viewtopic.php?f=31&t=37651&p=333227#p333318

Para compilar SDL1.2.15:

Añadimos la llamada a: 

ioctl(console_fd, FBIO_WAITFORVSYNC, 0);

en src/video/fbcon/SDL_fbvideo.c, función FB_WaitVBL().

Configuramos con:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ./configure --disable-video-opengl --enable-video-fbcon --disable-video-kms --disable-video-directfb --disable-oss --disable-alsatest --disable-pulseaudio --disable-pulseaudio-shared --disable-arts --disable-nas --disable-esd --disable-nas-shared --disable-diskaudio --disable-dummyaudio --disable-mintaudio --disable-video-x11

Si se queja el DOSBOX de que falta el ratón, usa la variable de entorno SDL_NOMOUSE=1
Si se queja de que las SDL no tienen soporte para CDROM, pues te toca recompilar las SDL.

********DESHABILITAR EL CURSOR QUE PARPADEA MIENTRAS ARRANCA EL KERNEL*********************************************************

Añadimos a cmdline.txt:
vt.global_cursor_default=0

********Hacer que el cursor de la consola deje de parpadear********************************************************************

echo -e '\033[?17;0;0c' > /dev/tty1

********Buscar un fichero a partir de parte de su nombre***************************************************************************************
find ./ -iname gl*
find ./ -name gl*

Lo de iname es para ignorar las mayúsculas o minúsculas.

******************Actualizar a de DEBIAN WHEEZY a DEBIAN JESSIE****************************************************************************

Podemos usar el generador de sources.list que está en http://debgen.simplylinux.ch, o directamente dejar el /etc/apt/sources.list así:

deb http://ftp.es.debian.org/debian testing main contrib non-free
deb-src http://ftp.es.debian.org/debian testing main contrib non-free

deb http://ftp.debian.org/debian/ jessie-updates main contrib non-free
deb-src http://ftp.debian.org/debian/ jessie-updates main contrib non-free

deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free

Ahora hacemos sudo apt-get update, apt-get --download-only dist-upgrade, apt-get dist-upgrade. Y cruza los dedos ^_^"

********Crear nuestro propio rootfs de Debian ARM********************************************************************************************

Se usa para ello debootstrap. Tenemos una guía aquí: http://linux-sunxi.org/Bootable_SD_card#Using_debootstrap_-_Debian.2FUbuntu_based_distributions
Y nos hace falta tener instalado qemu-user-static en el sistema que usemos para prepararlo todo.

********Biblioteca de San José****************************************************************************************************************

La base de datos está en un PC con IP fija (ahora mismo, 192.168.1.128) y se comparte mediante SAMBA. El fichero de configuración de SAMBA en 
el servidor está en /etc/samba/smb.conf
La entrada para servir el biblio, que está al final del smb.conf, es esta:

[biblio]
    comment = Biblio Database
    path = /home/biblioteca/.wine/drive_c/Biblio
    browsable = yes
    guest ok = yes
    read only = no

En los clientes, el directorio compartido se monta mediante un script en el directorio .wine/drive_c/Biblio/bibio.sh, que contiene un directorio "fakebase"
donde se montará el directorio completo de Biblio del servidor (Biblio por tanto NO se instala en los clientes sino que se ejecuta la misma copia
del servidor, locamente).
Dicho script, biblio.sh, tiene el siguiente contenido:

#!/bin/bash
set -o noclobber
sudo mount -t cifs -o username=biblioteca,password=giner //192.168.1.128/biblio fakebase/
cd ~/.wine/drive_c/Biblio/
wine ./Biblio.exe

El acceso directo del escritorio tiene este contenido:

[Desktop Entry]
Name=Biblio
Exec=sh /home/pikar/.wine/drive_c/Biblio/biblio.sh
Type=Application
Comment=Biblio
Path=/home/pikar/.wine/drive_c/Biblio
Icon=accessories-dictionary
Terminal=false
StartupNotify=false 

El usuario/contraseña del servidor es biblioteca/giner, y se puede entrar por ssh.

*********Túnel SSH***************************************************************************************************************************

ssh manuel@108.15.38.135 -L 5900:127.0.0.1:5900 -N

**********Hago un blacklist a un módulo pero sigue cargando************************************************************************************

Tienes que poner "blacklist <nombre_módulo>" en /etc/modprobe.d/blacklist.conf

Y luego, hacer un:

sudo update-initramfs -u


**********Establecer un modo de video físico en el arranque en sistemas con KMS****************************************************************

Habría que pasarle una línea de este estilo al kernel:

video="HDMI-A-1:1360x768@60"

En la Raspberry Pi, eso se añadiría a cmdline.txt (antes se hacía con parámetros hdmi_* en config.txt, pero esos parámetros
son ignorados en modo KMS).

**********Cuestiones de modo de vídeo en plataformas con KMS (IFC6413, etc)********************************************************************

Miramos cual es el conector activo, mirando en
/sys/class/drm/card0-*
cuál tiene "connected" en el status. 

Editamos /etc/default/grub, añadimos lo que nos interese de estas cosas a la linea de los parámetros del kernel, por ejemplos:

video="HDMI-A-1:800x600"  

video=DVI-I-1:1024x768@60

y luego hacemos un update-grub.

Información completa en:
http://nouveau.freedesktop.org/wiki/KernelModeSetting/

Comprobar resolción y movidas:
/sys/devices/platform/omapdrm.0/drm/card0

Para quitar el salvapantallas a negro:
consoleblank=0 (en el boot.scr, claro)

**********Deshabilitar el polling de KMS, que causa parpadeos y movidas en ciertos sistemas***************************************************

En :
/etc/modprobe.d/modprobe.conf:
Añadimos:
options drm_kms_helper poll=0

**********Notas instalación DEBIAN************************************************************************************************************

--Nos puede pedir firmware para hardware de red cuyo firm es non-free. Nos bajamos el archivo "firmware-ralink_0.28+squeeze1_all.deb" o el que sea que
necesitemos, pero NO nos bajamos otra ISO para esto, se hace desde un pequeño DEB, lo descomprimimos con:

ar vx mypackage.deb
tar xvzpf data.tar.gz

y mandamos los .bin al directorio raíz de un pendrive, tal cual, los .bin tirados ahí.
Y ya lo debería de detectar la instalación cuando nos pide un "removable media" con el firmware que le falta.

--Le ponemos una IP fija editando /etc/networks/interfaces y dejándo exactamente así:

auto lo eth0

iface lo inet loopback
#iface eth0 inet dhcp

iface eth0 inet static
address 192.168.5.9
netmask 255.255.255.0
gateway 192.168.5.7

Ya deberíamos poder hacer ping al equipo servidor (el portátil).
Sin embargo, nos faltaría ponerle algunos servidores dns en resolv.conf:

nameserver 208.67.222.222 
nameserver 8.8.8.8

--Deshabilitamos el MTA (Mail Transport Agent):

insserv -r exim4

---ANTES de poder instalar ningún paquete, tenemos que poner a punto el /etc/sources.list. Si no, nos pedirá el CD ROM de netinstall!
Tenemos que dejar el sources.list más o menos así:

deb http://http.debian.net/debian wheezy main
deb-src http://http.debian.net/debian wheezy main

deb http://http.debian.net/debian wheezy-updates main
deb-src http://http.debian.net/debian wheezy-updates main

deb http://security.debian.org/ wheezy/updates main
deb-src http://security.debian.org/ wheezy/updates main

y a continuación hacer un apt-get update y si queremos un apt-get upgrade. Tras eso, ya ponemos empezar a instalar paquetes.
Instalamos sudo, añadimos el usuario a la lista de sudoers. Para ello, como root hacemos:

visudo -f /etc/sudoers

y bajo la línea
root    ALL=(ALL) ALL

añadimos 
manuel   ALL=(ALL) ALL

Y abajo del todo del fichero, añadimos:

manuel ALL = NOPASSWD : ALL

Salvamos y listo.

Quitamos el IPV6:

echo 'blacklist ipv6' >> /etc/modprobe.d/blacklist

Instalamos los buil-essential:

sudo apt-get install build-essential


Ahora ya sigue la guía rápida de configuración de raspbian, porque es todo igual. 

**********Sustituir todas las ocurrencias de una cadena por otra en un directorio*******************************************************************

find ./ -type f -exec sed -i 's/apple/orange/g' {} \;

Y si simplemente queremos borrar una línea que contenga cierta cadena, sed '/pattern to match/d'

Para aplicarlo sobre un fichero:

sed -i 's/apple/orange/' <nombre_archivo>

**********Formatear FAT32 con tamaño de cluster a 32K******************************************************************************************

sudo mkfs.msdos -s 64 /dev/sdb1

ya que el tamaño de bloque es de 512bytes y -s expresa el tamaño de un sector (cluster) en bloques.

**********Seleccionar columnas en VIM*********************************************************************************************************

Esto es la hostia. Usa CTRL+V para entrar en VISUAL BLOCK MODE y seleccionar columnas. Ya las puedes borrar o hacer lo que quieras con ellas.

**********Search and replace (buscar y sustituir) en VIM******************************************************************************************

Se hace con el comando:
:%s/cadena_original/nueva_cadena/g

Y si la cadena que buscas o por la que sustituyes lleva un punto, como es un caracter especial que significa "cualquier caracter", tienes que "escaparlo", o sea,
poner un backslash antes. Por ejemplo, si quieres sustituir la cadena 1.0f por 0.5f, harías:

:%s/1\.0f/0\.5f/g

Para confirmar cada ocurrencia, usamos gc en lugar de g:
:%s/cadena_original/nueva_cadena/gc

**********Desactivar números de línea en vim****************************************************************************************************

:set nu!

**********Secuencia de debugeo rápido mediante logs*******************************************************************************************
FILE *fp;
fp = fopen("SDL_log.txt","w");
fprintf (fp,"\nSetColors() Función completada con éxito!!\n");
fclose (fp);

**********Crear un parche para que la gente pueda aplicar nuestros cambios sobre sources originales************************************************

Lo primero es conseguir el directorio con los sources originales.

Ahora, comprobamos qué ficheros están solo en los sources modificados, y qué ficheros, estando en ambos, han cambiado. Para ello hacemos:

diff -rq originales modificados

Ahora, sabiendo eso, es muy fácil saber qué ficheros borrar, es decir, los que no nos interesa que se incluyan en el parche,
tales como los generados por los buildsystems, ya que habremos estado haciendo pruebas y compilando mientras desarrollábamos.
Una vez eliminado lo que sobra, ya sí, sacamos el parche:

diff -rupN originales modificados > parche.patch

Como ves, es muy sencillo!

El parche que hemos generado, se debería poder aplicar simplemente copiándolo en el raíz de los sources originales y haciendo un
patch -p1 < parche.patch

APÉNDICE: Si sólo queremos crear un parche para un archivo (que es algo menos común):

diff -u original.c modificado.c > parche.patch

**********Parchear el kernel y el scummvm*******************************************************************************************************

Ponemos el parche en el directorio raiz de los sources, y hacemos

patch -p1 < parche.diff

Y para revertir los cambios, hacemos:

patch -R -p1 < parche.diff

**********Usar FIND correctamente**************************************************************************************************************
find . -name 'openmsx'

***********GPSP en la Raspberry Pi**************************************************************************************************************

El único fallo que tiene este emulador es que no calcula bien el ratio si usas por ejemplo una resolución de 640x480.
Así que editamos gles_video.c y dejamos la última parte de la función video_init() tal que así, a partir de la llamada a gles2_create():

        gles2_create();

        float r = ((float)_width / (float)_height);
        int h = screen_height;
        int w = screen_height * r;
        if (w > screen_width)
                w = screen_width;

        //h y w son las dimensiones de la ventana en que veremos el juego
        //screen_width y screen_height son las del display físico
        glViewport((screen_width-w)/2, (screen_height-h)/2, w, h);
        SetOrtho(proj, -0.5f, +0.5f, +0.5f, -0.5f, -1.0f, 1.0f, 1.0f ,1.0f );
        video_set_filter(filter);

Luego ponemos los CFLAGS típicos en el Makefile, compilamos y listo.

***********ERRROR: Programa no encuentra librería en tiempo de ejecución, pero sí la encuentra en tiempo de linkado (no hay undefined symbols)******

LO PRIMERO es hacer un ldd al ejecutable y confirmar que dicha librería aparece como NOT FOUND.
Esto es porque, aunque le pases con -L<ruta> la librería que quieres que encuentre en linkado, para que la encuentre en tiempo de ejecución necesitarías
pasarle "-Wl,-rpath,<ruta>".
Aunque lo normal es que no tengas que hacer esto tampoco, sino que la librería esté en una ubicación donde el sistema busque por defecto.
Para asegurarnos de esto, hacemos "ldconfig --verbose", y se actualizarán los directorios donde se buscan las librerias que usan los programas.
Así que si has instalado una librería pero no la encuentra un programa en tiempo de ejecuciçon, puedes pasarle el -rpath o hacer un ldconfig y listo.

***********ACCEDER A ESCRITORIO REMOTO POR VNC USANDO TIGHTVNC**************************************************************************

Se usa tightvnc porque es el cliente más ligero.
Se ha seguido este tutorial: https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-20-04-es

				---EN EL SERVIDOR---

Instalamos tightvnc server:
sudo apt-get install tightvncserver

Lo ejecutamos por primera vez. Nos pedirá un user/pass y un user para mirar solamente. Del user para mirar pasamos.
vncserver

Podemos levantar varios servers a la vez en el mismo ordenador, ejecutando vncserver varias veces.
Y luego podemos matarlos con:
vncserver -kill :1
vncserver -kill :2
vncserver -kill :3
..etc

Bueno, pues ahora ya podríamos conectarnos a las X remotamente, pero serían las X sin nada y no podríamos hacer nada de nada.
Así que tenemos que decirle al servidor vnc que ejecute unos comandos que lancen el escritorio en sí cuando nosotros lanzamos el servidor.
Así que matamos el servidor:
vncserver -kill :1
Hacemos una copia de seguridad de la secuencia de comandos que ejecuta el servidor al inicio:
mv ~/.vnc/xstartup ~/.vnc/xstartup.bak
Y creamos un nuevo fichero de secuencia de comandos del servidor vnc:
vim ~/.vnc/xstartup
Con el contenido (específico de lxqt, otros escritorios requerirán otras cosas):

!/bin/sh
# Uncomment the following two lines for normal desktop:
unset SESSION_MANAGER
#exec /etc/X11/xinit/xinitrc
exec openbox-session &
exec startlxqt &

Y ahora lanzamos el servidor otra vez:
vncserver

HEMOS DE SABER que el servidor vnc escucha en el puerto 5901, si lanzas otro servidor escuchará en 5902, el siguiente en 5903...
Puedes confirmarlo con netstat -pl, y ahí ves en qué puertos hay servidores vnc escuchando en la máquina.

					---EN EL CLIENTE---

Instalamos el vncviewer:

sudo apt-get install xtightvncviewer

Y ya podemos conectar al servidor con:

vncviewer <IP LOCAL>:PUERTO

Por ejemplo, si el servidor está en la 0.30 de rango local y tiene un servidor vnc escuchando en el 5901, conectamos con:

vncviewer 192.168.0.30:5901

					---CONECTAR A TRAVÉS DE UN TÚNEL SSH---
					
Una vez que tenemos el servidor VNC corriendo en el ordenador servidor, podemos mandar el tráfico de ese servidor a través de un túnel SSH:

ssh -L 59000:localhost:5901 -C -N -l <USUARIO> <IP DEL SERVIDOR>

El puerto 59000 es arbitrario: puedes poner el que te de la gana (que no tenga un servicio usándolo, claro).

En teoría, esto debeía permitir que el servidor salga a internet por un puerto abierto, para poder acceder remotamente a la máquina.
Pero eso lo dejo para más adelante. 

***********Montar un DSK de Mac antiguo, o un ADF de Amiga******************************************************************************

Para el DSK de MAC antiguo:

sudo mount -o loop disc_image.dsk directorio_montaje

Y para el ADF de Amiga:

sudo mount -t affs -o loop disc_image.adf directorio_montaje

Y para covertir un fichero de texto de MAC antiguo a Linux:

tr '\r' '\n' < macfile.txt > unixfile.txt

Y el proceso contrario:

tr '\n' '\r' < unixfile.txt > macfile.txt

***********Editar el AUTOEXEC.BAT de MSX en Linux**************************************************************************************

Se puede editar como cualquier otro fichero, pero debes guardarlo en formato DOS antes de salir, así:
:set ff=dos
:wq

***********Montar un archivo .toast de MAC***********************************************************************************************

mount -o loop -t hfsplus imagename.toast [mount point]

Y si da error prueba con hfs en lugar de hfsplus.

También sirve para montar img de diskettes de mac.

***********Quitar un servicio que no sabemos quién lo lanza********************************************************************************

Has mirado en /etc/init.d y has intentado que no se lance el script de inicio de un servicio: lo has intentado con
sudo update-rc.d -f <servicio> remove
Pero ahí sigue si haces un TOP.
Pues puedes hacer dos cosas: o desinstalas el paquete al que pertenece el servicio, o desactivas el servicio que a su vez lo está lanzando.
Y esto lo puedes hacer con un grep a todo lo de /etc/init.d, con el nombre del servicio.

***********Guía rápida de configuración de RASPBIAN desde imágen por defecto (JESSIE)************************************************************

ANTES DE LEER ESTO: Son casi todo pistas, no es para seguirlo paso a paso. CON QUE TE VAYAS A LA "SECCiÓN RESÚMEN" y mires la lista de servicios que
son necesarios en "systemd-analyze blame" y lo que tienes que gestionar desde rc.local por tu cuenta, es suficiente (excepto los apuntes de DBUS, que hay que quitarlo como servicio pero no desinstalarlo del sistema porque OMXplayer lo usa).

-Ponemos la fuente de la consola: dpkg-reconfigure console-setup
-Ponemos los LOCALES con: dpkg-reconfigure locales. Elegimos que se generen en_US.UTF8 y es_ES.UTF, y dejamos puesto en_US.UTF8.
ESTO nos quita errores de teclado a través de SSH, ya que necesitamos los LOCALES de la máquina cliente también.
-Ponemos el idioma del teclado con raspi-config, y expandimos el filesystem, overclocking y demás movidas. El layout del teclado no se cambia hasta reboot.
-Ponemos una IP estática. Para ello:
	-Eliminamos del sistema estas cosas para que no se sobreescriba resolv.conf en cada arranque:
		sudo apt-get purge dhcpcd5 openresolv
	-Eliminamos las mierdas de BROADCOM:
	    sudo apt-get purge libraspberrypi*
	-Eliminamos MESA y demás porque vamos a instalar la nuestra:
		sudo apt-get purge libdrm* libgbm* libgles*
	-Dejamos /etc/resolv.conf como:
		nameserver 8.8.8.8
	-Deshabilitamos los servicios de red que no vamos a usar y que sobreescribirían /etc/resolv.conf:
		sudo systemctl disable networking
		sudo systemctl disable ifup
	...todo lo que veamos relacionado con la red.
	-Ponemos en rc.local el governor a performance:
		echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
        -Desactivamos el swappiness:
                 echo 0 > /proc/sys/vm/swappiness
	-SI QUEREMOS levantar la red ethernet al inicio, ponemos a capón en /etc/rc.local la configuración de la red:
		ifconfig eth0 up
		ip addr add 192.168.5.8/24 dev eth0
		ip route add default via 192.168.5.7
	EN CAMBIO, si lo vamos a hacer cuando lo necesitemos (que es lo que hago ahora), lo mejor es arrancar sin el chip de red activado, así que tendremos esto en lugar
	de los comandos ifconfig, ip, etc...
		echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind
	-Reiniciamos

-Evitamos que se nos ponga la consola en negro poniendo esto en /boot/cmdline.txt:
consoleblank=0
-Ya que estamos, también añadimos loglevel=3 para que el kernel sólo nos avise de cosas importantes de verdad.
-Desactivamos el modo turbo para la tarjeta de red, que como cuelga del USB da problemas, con smsc95xx.turbo_mode=N
-Desactivamos el powerlink de USB con dwc_otg.lpm_enable=0, pero vamos, que creo que viene desactivado por defecto.
-En el futuro, a partir del kernel 4.12, se podrá especificar el polling rate de los joysticks, para quitar latencia, con usbhid.jspoll=<polling rate>. Míratelo para entonces y añádelo.
 usbhid.jspoll=1 es un buen valor, resultando en 1000Hz de polling rate... lo que ya está muy bien.
 Se puede comprobar una vez arrancado el sistema con evhz, un programa que se baja de aquí: git clone --depth 1 https://gitlab.com/iankelling/evhz
RECUERDA que tienes que poder PRIMERO quiet, y luego loglevel: EN ESE PRECISO ÓRDEN, o el valor de loglevel será IGNORADO. Tengo cmdline.txt así:
dwc_otg.lpm_enable=0 smsc95xx.turbo_mode=N console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=noop rootwait consoleblank=0 quiet loglevel=3 fastboot logo.nologo noswap

-Empezamos a eliminar mierda, que se hace en varias fases porque al eliminar libgtk* se instalan más mierdas:
sudo apt-get purge avahi-daemon triggerhappy dbus plymouth ntp dphys-swapfile rsyslog openresolv dhcpcd5 libreoffice* webkit* libgtk* libreoffice*
sudo apt-get purge greenfoot bluej 
sudo apt-get purge oracle-java7-jdk pinentry-curses x11-common x11-* nfs-common
sudo apt-get purge cron anacron
(ponemos anacron también para que elimine cron y NO trate de instalar anacron en su lugar).

-Si tras reiniciar no podemos entrar por ssh es porque se han perdido las keys. Lo confirmamos con systemctl status ssh y vemos que no puede leer 
un archivo de claves. Para solucionarlo, las regeneramos. Hacemos:
sudo /usr/bin/ssh-keygen -A

-Se nos van a lanzar una pila de ttys. Para que eso no ocurra, tenemos que deshabilitar el servicio getty-static.service.
	sudo systemctl mask getty-static
-Lanzamos otra consola en tty2, habilitando el servicio getty@tty2:
	sudo systemctl enable getty@tty2

-Ponemos autologin en tty1 y tty2:
	-Creamos los ficheros: 
	/etc/systemd/system/getty@tty1.service.d/autologin.conf
	/etc/systemd/system/getty@tty2.service.d/autologin.conf
	-Metemos ambos ficheros esto:
		[Service]
		ExecStart=
		ExecStart=-/sbin/agetty --autologin pi --noclear --skip-login %I 38400 linux
	-Salvamos, recargamos la configuración de los daemons:
		systemctl daemon-reload
	-y reiniciamos

-Repasamos los servicios activos. Podemos ver tooodas las units y su estado con:
	systemctl list-unit-files

-Deshabilitamos el servicio que intenta salvar la hora de un reloj físico (que no tenemos) y que causa un FAILED al hacer shutdown:
	sudo systemctl disable hwclock-save 

-Desactivamos IPV6. Esto hay que hacerlo como root, así que primero establecemos una clave de root, que aún no la tenemos:
sudo passwd
su
echo 'blacklist ipv6' >> /etc/modprobe.d/blacklist
sed -i '/::/s%^%#%g' /etc/hosts

-Cambiamos el servidor ssh de openssh a dropbear, para ahorrar memoria:
sudo apt-get install dropbear
/etc/init.d/ssh stop
Para que arranque al inicio
sed -i 's/NO_START=1/NO_START=0/g' /etc/default/dropbear
Mandamos el openssh al carajo y reiniciamos ya con dropbear:
sudo apt-get purge openssh-server

-Para quitar el error: "Failed to connect stdout to the journal socket"
Edita /etc/systemd/system.conf y pon LogTarget a "null" o a "console"

-Como el omxplayer depende de la MIERDA de dbus, nos va a instalar dbus al instalar el omxplayer. Nosotros nos vengamos evitando
que dbus se lance al inicio, y evitamos que systemd-logind.service nos de errores al no encontrar dbus, porque tampoco lo usamos:
sudo systemctl mask dbus
sudo systemctl mask systemd-logind
sudo systemctl mask dbus.socket

-Deshabilitamos más servicios que no nos hacen falta. Esto lo hemos hecho analizando con "systemd-analyze blame":
sudo systemctl mask systemd-logingd
sudo systemctl mask hdparm
sudo systemctl mask sys-kernel-debug.mount
sudo systemctl disable console-setup
...y metemos a capón en rc.local:
setfont Lat15-TerminusBold28x14
sudo systemctl mask systemd-journal-flush
sudo systemctl mask kmod-static-nodes
sudo systemctl mask systemd-random-seed
sudo systemctl mask dev-mqueue.mount
sudo systemctl mask systemd-user-sessions
sudo systemctl mask systemd-tmpfiles-setup
sudo systemctl mask systemd-tmpfiles-setup-dev
sudo systemctl mask systemd-update-utmp
sudo systemctl mask systemd-update-utmp-runlevel
sudo systemctl mask systemd-journald.service
sudo systemctl mask systemd-journald.socket
sudo systemctl mask systemd-journald-dev-log.socket
...y como consecuencia, tenemos que añadir dropbear a rc.local:
/etc/init.d/dropbear start
...y deshabilitar su lanzamiento por parte de systemd:
sudo systemctl disable dropbear

sudo systemctl mask systemd-fsck-root
sudo systemctl mask systemd-fsck@dev-mmcblk0p1
sudo systemctl mask swap.target
sudo systemctl mask urandom.service
sudo systemctl mask cryptsetup.target
sudo systemctl mask cryptsetup-pre.target

-Comentamos la línea de i2c en /etc/modules-load.d/modules.conf
-Evitamos que se cargue el módulo de IPV6 añadiendo esto al principio de /etc/modprobe.d/ipv6.conf :
install ipv6 /bin/true
(Si te suena raro, es un fake install: como es un módulo cargado por el kernel, tenemos que hacerle creer que se carga, pero no).
Y ahora para acabar con IPV6 del todo hacemos : 
sudo sed -i '/::/s%^%#%g' /etc/hosts
-Hacemos lo mismo con otro módulo que no usamos, metiendo en /etc/modprobe.d/bcm2835_gpiomem.conf :
install bcm2835_gpiomem /bin/true
-Los módulos que necesitamos a parte de los del kernel los cargamos nosotros a mano. Sólo nos hace falta el del chip de audio. Para ello:
sudo systemctl mask systemd-modules-load
Y añadimos a rc.local:
modprobe snd_bcm2835

-Si queremos dejar que systemd gestione la carga de módulos (es lo último que suelo venir haciendo) pero queremos quitar el módulo uio y el uio_noséqué, creamos el fichero:
/etc/modprobe.d/uio_pdrv_genirq.conf
Con el contenido
blacklist uio_pdrv_genirq
Y hacemos
depmod -ae
update-initramfs -u
Reiniciamos y ya no debería estar.

También creamos /etc/modprobe.d/bcm2835_wdt.conf con el contenido:
blacklist bcm2835_wdt
Y hacemos
depmod -ae
update-initramfs -u
Reiniciamos y ya no debería estar.

-Borramos /etc/motd
-Para quitar el lastlogin, editamos sudo vim /etc/pam.d/login y comentamos la línea:
session optional pam_lastlog.so
En este mismo fichero, puedes quitar otros mensajes del login, como la versión del kernel y tal.
Para ello comenta las dos líneas siguientes a esta de lastlog.
-Para quitar el delay de login editamos /etc/pam.d/common-auth y añadimos a la línea de pam_unix el "nodelay",
 dejando la línea de pam_unix.so así:
auth        required      pam_unix.so nodelay
-Para quitar la frase donde dice la versión de DEBIAN y tal, borra /etc/issue o pon allí lo que quieras que salga.

-Cambiamos el servidor ssh de openssh a dropbear, para ahorrar memoria:
sudo apt-get install dropbear
/etc/init.d/ssh stop
Para que arranque al inicio
sed -i 's/NO_START=1/NO_START=0/g' /etc/default/dropbear
Mandamos el openssh al carajo y reiniciamos ya con dropbear:
apt-get purge openssh-server

-En config.txt ponemos boot_delay=0, verificamos los valores de overcloking (1Ghz para la Pi 1) y ponemos el modo de vídeo a group 2, mode 39.
  Podríamos añadir:
# Disable undervoltage and overheat warnings
avoid_warnings=2
...porque el warning de undervoltage salta a veces si la powersupply es mala, pero NO lo añadimos, usamos una oficial que da 2.5A, y no habrá esos errores.

-En config.txt desactivamos el watchdog:
dtparam=watchdog=off

-Si te aparecen errores de EVIOCSKEYCODE, son del dmesg pero no deberían estarse viendo en la consola.. y no son importantes.
Simplemente verifica que tienes cmdline.txt esto, y EN ESTE ÓRDEN PRECISO:  quiet loglevel=3
Y ya no se te debería colar eso en la consola.

									SECCIÓN RESÚMEN

AL FINAL sólo tenemos que tener estos 11 servicios listados en systemd-analyze blame:
pi@raspberrypi:~ $ sudo systemd-analyze blame
          1.365s dev-mmcblk0p02.device
           544ms systemd-udev-trigger.service
           466ms systemd-remount-fs.service
           450ms keyboard-setup.service
           309ms boot.mount
           196ms systemd-fsck@dev-disk-by\x2dpartuuid-521a4163\x2d0a.service
           190ms alsa-restore.service
           137ms systemd-udevd.service
           119ms fake-hwclock.service
            79ms dropbear.service
            26ms console-setup.service
            17ms rc-local.service

SI UN SERVICIO NO ESTÁ EN ESTA LISTA, ES QUE NO ME HACE FALTA.

ES POSIBLE LIBRARSE DE keyboard-setup.service!!!
PARA ELLO:
1) Arranca con el servicio activo y el teclado correctamente configurado en castellano.
2) Haz dumpkeys > es.map y manda es.map a /etc
3) Añade loadkeys /etc/es.map en /etc/rc.local
4) Ya puedes hacer tranquilamente:
	sudo systemctl mask keyboard-setup.service

Y nuestro /etc/rc.local tendrá esto:

echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
echo 0 > /proc/sys/vm/swappiness
setfont Lat15-TerminusBold28x14
ifconfig eth0 up
ip addr add 192.168.5.8/24 dev eth0
ip route add default via 192.168.5.7
/etc/init.d/dropbear start

Todo lo demás se lo dejamos gestionar a systemd.

TENEMOS QUE QUITAR LOS RLIMITS, o los emuladores se empezarán a quejar al llegar al 80% de uso de la CPU!
Para ello, editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:

@audio   -  rtprio     99
@audio   -  memlock    unlimited
@audio   -  nice    -20
pi   -  rtprio     99
pi   -  memlock    unlimited
pi   -  nice       -20


De este modo, no hay límites para el usuario Pi ni para nadie del grupo audio, como jackd.

Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.

************Acutualizar el kernel de la Raspberry Pi sin tener las herramientas de broadcom***************************************

Porque claro, eliminaste las mierdas binarias cerradas de broadcom con sudo apt-get purge libraspberrypi*
Así que esto debería de todos modos actualizar el kernel.

sudo apt-get update
sudo apt-get full-upgrade

************Actualizar la eeprom de la raspberry Pi 4 sin tener las herramientas de broadcom**************************************

Las instalas, actualizas y desinstalas.
sudo apt-get install rpi-eeprom
(Se instalan las libraspberrypi como dependencias).
sudo rpi-eeprom-update
(Volvemos a borrar las libraspberrypi....)
sudo apt-get purge libraspberrypi*

************VALORES DE OVERCLOCKING PARA RASPBERRY PI 3***************************************************************************

arm_freq=1350
over_voltage=4
sdram_freq=500
sdram_schmoo=0x02000020
sdram_over_voltage=2

Valores más conservadores para la CPU serían:
arm_freq=1300
over_voltage=2

O incluso:
arm_freq=1300
over_voltage=1

Si usas 1350, DESACTIVA AL MENOS UNO DE LOS CORES (en cmdline.txt, maxcores=3), o el sistema se volverá inestable en carga máxima,
como por ejemplo compilando con todos los cores (make -j6, etc)
No tiene sentido overclockear el video core ya que aunque leas por ahí que la caché de nivel 2 es compartida con el video core,
eso era en la Pi1 solamente.

Y para overclockear la SD (OJO! Requiere que la tarjeta sea UHS):
dtparam=sd_overclock=100

Puedes medir la temperatura con:
vcgencmd measure_temp

Por defecto, al llegar a los 79-80º, se downclockeará, así que si con overclocking alcanza los 75, olvídate.

***********Scrips para levantar la red ETHERNET y la red WIFI manualmente****************************************************************

Ya no "se lleva" levantar la red ethernet desde rc.local, se hace cuando se va a usar:
En rc.local tendrás:

echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind

...para que el sistema arranque con la ethernet desasctivada.

===bin/eth0-on===

sudo sh -c 'echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/bind'
sudo ifconfig eth0 up
sudo ip addr add 192.168.5.8/24 dev eth0
sudo ip route add default via 192.168.5.7
sudo /etc/init.d/dropbear start

===bin/eth0-off===

sudo /etc/init.d/dropbear stop
sudo ifconfig eth0 down
sudo sh -c 'echo 1-1.1:1.0 > /sys/bus/usb/drivers/smsc95xx/unbind'

===bin/wifi-on===

sudo ifconfig eth0 down
sudo modprobe brcmfmac
sudo ifconfig wlan0 up

sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

sudo ip addr add 192.168.1.12/24 dev wlan0
sudo ip route add default via 192.168.1.1
sudo /etc/init.d/dropbear start

(Los detalles sobre el fichero wpa_supplican.conf están en otra sección de este mismo documento donde explico cómo
gestionar la wifi a mano)

===bin/wifi-on, pero con DHCP en vez de IP estática===

sudo ifconfig eth0 down
sudo modprobe brcmfmac
sudo ifconfig wlan0 up

sudo wpa_supplicant -d -Dnl80211 -iwlan0 -c/etc/wpa_supplicant/wpa_supplicant.conf -B

sudo dhclient wlan0

sudo /etc/init.d/dropbear start

===bin/wifi-off===

sudo killall wpa_supplicant
sudo ifconfig wlan0 down
sudo rmmod brcmfmac
sudo /etc/init.d/dropbear stop

***********Hacer un volcado de un disco abarcando sólo el espacio usado por las particiones***********************************************

Miramos con FDISK dónde acaba la última partición, y el tamaño de unidad:

sudo fdisk -l /dev/sdb

Disk /dev/sdb: 58 GiB, 62277025792 bytes, 121634816 sectors
Disk model: Card  Reader    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x4f2a38d0

Device     Boot  Start     End Sectors  Size Id Type
/dev/sdb1         8192  532479  524288  256M  c W95 FAT32 (LBA)
/dev/sdb2       532480 8519679 7987200  3,8G 83 Linux

AHÍ VEMOS que UNITS es: 512 bytes
AHÍ VEMOS que LA ÚLTIMA PARTICIÓN ACABA EN 8519679
PUES BIEN: A DD LE PASAMOS EL TAMAÑO DE UNIDAD (512) Y EL NÚMERO DE UNIDADES (LE SUMAMOS 1 A 8519679, Y NOS QUEDA 8519680) Y TEMEMOS:

sudo dd if=/dev/sdb of=dump.img bs=512 count=8519680 status=progress

Y ya tenemos nuestro volcado, que ocupa lo que ocupan las partiociones, sin volcar el espacio extra al final del disco.

***********Extraer una partición de un IMG que contiene la imágen de un disco completo****************************************************

Fácil. Con fdisk vemos dónde empieza y cuánto mide la partición que queremos (en sectores nos lo da directamente, que es lo que nos interesa):
sudo fdisk -l Downloads/MSX3_sd.img

Device               			                   Start    End            Sectors       Size      Id Type
Downloads/MSX3_sd.img          					   2048     1982463        1980416       967M      e W95 FAT16 (LBA)

Vemos que sólo tiene una partición, que empieza en el sector 2048 y ocupa 1982563 sectores. Con eso ya ponemos hacer:
dd if=Downloads/MSX3_sd.img of=fat16_partition.img skip=2048 count=1980416

Puedes montar el resultado para ver si te deja y está todo bien:
sudo mount -o loop fat16_partition.img /mn/hdd

Ahora, podrías volcar esa partición a otro disco, empezando en el sector 2048 como en el disco original, con:
sudo dd if=fat16_partition.img of=/dev/sdb seek=2048
PERO ESO NO TENDRÍA SENTIDO, PORQUE NO SE VERÍA LA PARTICIÓN: TEN EN CUENTA QUE TIENES QUE CREAR LA PARTICIÓN ANTES, PARA QUE SE GUARDE EN LA
TABLA DE PARTICIONES, YA QUE AL VOLCAR LA PARTICIÓN SOLAMENTE NO QUEDA GUARDADA EN LA TABLA Y ES INVISIBLE!

Efectivamente, seek sirve para posicionarse en un sector del disco de salida, igual que skip nos sirvió para lo mismo en el disco de entrada.
Se podría haber hecho todo en el mismo comando combinando seek y skip, ambos a 2048 en el ejemplo:

dd if=Downloads/MSX3_sd.img of=/dev/sdb skip=2048 seek=2048 count=1980416

***********Montar una partición individual de una imágen completa de disco***************************************************************

RECUERDA: CUANDO SAQUES UNA IMÁGEN DE UNA SD COMPLETA, TODAS SUS PARTICIONES DEBEN ESTAR DESMONTADAS ANTES DE HACER LA IMÁGEN,
O LUEGO NO PODRÁS MONTAR LAS PARTICIONES DE LA IMÁGEN RESULTANTE.

Con parted vemos dónde empieza cada partición. Tenemos que verlo en bytes:

manuel@vader:~$ parted rpi_bck.img
(parted) unit                                                             
Unit?  [compact]? B                                                       
(parted) print                                                            
Model:  (file)
Disk /home/manuel/rpi_bck.img: 7948206080B
Sector size (logical/physical): 512B/512B
Partition Table: msdos

Number  Start      End          Size         Type     File system  Flags
 1      4194304B   67108863B    62914560B    primary  fat16        lba
 2      67108864B  7948206079B  7881097216B  primary  ext4

Ya tenemos la información que necesitamos, que es el offset de la segunda partición, que es la que queremos montar. Ahora simplemente hacemos:

sudo mount -o loop,rw,offset=67108864 rpi_bck.img /mnt/hdd

Y listo!!

Para raspbian más reciente:

sudo mount -o loop,rw,offset=70254592 raspbian_AUG2016.img /mnt/hdd

***********Montar una partición AMIGA dentro de una imágen RDB, o sea, un disco completo con cabecera RDB y una o varias particiones*****

Este es el tipo de HDF que se usa, por ejemplo, en el Minimig y demás implementaciones en FPGA. Es lo mismo casi que montar cualquier otra
partición que está dentro de una imágen completa de disco.
Recurrimos a parted para pillar el offset (primer valor) y el size (último valor):

manuel@vader:~$ parted /media/manuel/MINIMIG_V1/hdf_sys31.hdf 
WARNING: You are not superuser.  Watch out for permissions.
GNU Parted 3.2
Using /media/manuel/MINIMIG_V1/hdf_sys31.hdf
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) unit
Unit?  [compact]? B                                                       
(parted) print                                                            
Pralloc = 0, Reserved = 2, blocksize = 1, root block at 737478
Model:  (file)
Disk /media/manuel/MINIMIG_V1/hdf_sys31.hdf: 754974720B
Sector size (logical/physical): 512B/512B
Partition Table: amiga
Disk Flags: 

Number  Start            End                        Size                       File system        Name           Flags
1       258048B          754919423B                 754661376B                 affs1              DH0            boot

Ahora simplemente montamos con ambos parámetros y ¡funciona!

sudo mount -t affs -o loop,rw,offset=258048,sizelimit=754661376 /media/manuel/E94A-DA9D/amiga/hdf_sys31.hdf /mnt/hdd

Y para montar la imágen del disco laserdisc.hdf donde tienes los juegos de EAROK:
sudo mount -o loop,rw,offset=258048,sizelimit=1073479680 -t affs /media/manuel/E94A-DA9D/amiga/laserdisc.hdf /mnt/hdd

***********Montar una partición HFS dentro de una imágen completa de las que usa el core FPGA MACPLus************************************

La imágen que uso es la de 100MB de aquí: http://www.savagetaylor.com/downloads/
(Aunque ponga que es de IOMEGA Zip funciona perfectamente)

Como el Mini VMAC no funciona con imágenes en las que la partición HFS empieza con un offset, la extraemos primero tirando de la info de parted:

dd if=OS_608_100MB.vhd of=OS_608_100MB_HFS.vhd skip=49152 count=94306304 iflag=skip_bytes,count_bytes

Hacemos lo que sea y la volvemos a meter:

dd if=OS_608_100MB_HFS.vhd of=OS_608_100MB.vhd seek=49152 count=94306304 iflag=count_bytes oflag=seek_bytes

***********Encoger una partición de una imágen de disco***********************************************************************************

No es simplemente acceder con parted: se tiene que operar sobre un loop para esa imágen.

Pedimos el loop (siempre que loop0 esté libre, sino tenemos que pedir uno libre antes con sudo losetup -f o usar otro de los de /dev. Mira con df 
cuáles no aparecen y por tanto están libres):

sudo losetup /dev/loop0 myimage.img
sudo partprobe /dev/loop0

Ahora mira que tengas /dev/loop0p1, /dev/loop0p2, etc...

Y ya puedes hacer: 

sudo gparted /dev/loop0

...y te dejará encoger particiones EXT4 y demás.

***********Recortar una imágen de disco (tarjeta) para que no ocupe lo mismo que tiene como capacidad el dispositivo de donde se leyó*******

Lo primero es hacerle un fdisk -l a la imágen:

manuel@vader:~$ fdisk -l raspbian_RetroArch.img 

Disk raspbian_RetroArch.img: 7948 MB, 7948206080 bytes
255 heads, 63 sectors/track, 966 cylinders, total 15523840 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0002c262

Device                                                   Boot                          Start         End              Blocks          Id            System
raspbian_RetroArch.img1                                             8192         122879       57344            c              W95 FAT32 (LBA)
raspbian_RetroArch.img2                                            122880     4218879     2048000     83            Linux

De aquí sacamos lo siguiente: que cada sector es de 512 bytes, y que la segunda partición acaba en el sector o bloque número 4218879.
Así que realmente sólo estamos 4218879 + 1 sectores (ya que el sector 0 obviamente existe).
Hacemos:

manuel@vader:~$ sudo truncate --size=$[(4218879+1)*512] raspbian_RetroArch.img

Y listo!

***********Extraer la pista de datos (ISO) y las pistas de audio de una imágen de CD en formato CloneCD (CCD+IMG+SUB)*********************

-Convierte el ccd a un CUE:
ccd2cue -i foo.img -o foo.cue foo.ccd

-Extrae las pistas de datos y audio con bchunck:
bchunk -w tomb.img tomb.cue track
(ojo que en el tomb raider las pistas de audio empiezan por track_, no por track, así que tendrías que poner track_ para que se llamasen como deben)

-La ISO de la primera pista la puedes montar y extraer sus archivos sin problemas

-Y ahora, puedes convertir todos los WAV del directorio a OGG y a MP3 con esto:
for f in *.wav; do ffmpeg -i "$f" -c:a libmp3lame -q:a 2 "${f/%wav/mp3}" -c:a libvorbis -q:a 4 "${f/%wav/ogg}"; done

-O sólo a OGG:
for f in *.wav; do ffmpeg -i "$f" -c:a libvorbis -q:a 4 "${f/%wav/ogg}"; done

***********CONVERTIR TODOS LOS FICHEROS DE UN DIRECTORIO DE WAV A FLAC*****************************************************************

Instalamos el paquete SOX:

sudo apt-get install sox

Convertimos:

for i in *.wav; do sox "$i" "${i%.*}.flac"; done

***********OpenLara, versión opensource del Tomb Raider********************************************************************************

PUEDES BAJARTE LOS DATOS DEL JUEGO SIMPLEMENTE DE:
http://xproger.info/projects/OpenLara/files/
...Y los pones donde tengas el ejecutable, y ya.
O te puedes complicar la vida con los siguientes consejos:

-Para extraer los archivos del juego, usa ISOBUSTER y extraelos en modo RAW!! (Esto es muy importante o los vídeos sonarán mal)
-Copia los directorios PSXDATA, DELDATA y FMV al directorio donde tengas el ejecutable.
-Las pistas de audio van en audio/1/_track*.ogg

***********ERROR: DISTCC no distribuye la compilación y no sé por qué, con otros proyectos sí lo hace****************************************

Posiblemente el Makefile está poniendo como compilador el cc.
Lo que compila con cc siempre puede compilar con gcc.
Así que la solución es MUY sencilla: nos vamos al directorio donde tenemos los tools del servidor para cross compiling, o sea, los binarios
(~/raspberrypi/tools.../bin) y hacemos "ln -s gcc cc".
Arreglado!

***********Compilación distribuida con distcc********************************************************************************************

ESTA PRIMERA OPCIÓN NO ES RECOMENDADA PARA LA PI!! Es más sencillo usar el cross compilador oficial y además tanto uno como otro tienen problemas
porque no soporta multiarch y no buscan los scripts .so para LD, librerías y haders donde deben, pero al menos al usar el oficial no tengo que pegarme con
la construcción del crosscompiler, y además ahora el crosscompiler oficial ya no produce binarios más lentos ni nada de eso.

PARTE 1-OPCIÓN A: CONSTRUYENDO NUESTRO PROPIO CROSS-COMPILER (NO recomendada en Octubre de 2015 porque podemos usar el cross-compilador oficial)
===============================================================
Empezamos en el servidor. 
Lo primero es tener la herramienta que nos permite a su ver crear el compilador cruzado. Para ello, clonamos el repo de github:
git clone --depth 1 https://github.com/crosstool-ng/crosstool-ng.git

Instalamos algunas cosas antes: gperf, flex, bison, libtool, libtool-bin, gawk, texinfo, libncurses5-dev, help2man...

Hacemos: bootstrap, configure, make, sudo make install
Ya deberíamos tener el comando ct-ng.
Ahora nos creamos ~/cross-rasp y entramos en él. 

Creamos nuestro propio .config desde cero con "ct-ng menuconfig", para ello, seguimos estas instrucciones:
http://elinux.org/RPi_Linaro_GCC_Compilation#Build_GCC_Linaro
Las adaptamos, eso sí, a la versión de EGLIBC y de las BINUTILS que tengamos. Tampoco elijas un compilador muy nuevo... un linaro 4.7 para la Pi1 está bien.
-Para la versión de BINUTILS, hacemos ld -v
-Para la versión de EGLIBC, hacemos ldd --version
-Pon el Number of Parallel jobs a 6 si estás en el PC de 4 cores.
-Si tienes los ficheros crt*.o (y otras librerías, como el script para LD libc.so) del sysroot de la raspberry pi en /opt/rpi_root/usr/lib/arm-linux-gnueabihf, 
 pues probablemente al pasarle --sysroot=/opt/rpi_root al compilador acabe buscando estas cosas en /opt/rpi_root/usr/lib y no las encontrará. Así que añade a los
 "gcc extra config" (en la sección "C compiler") esto: --enable-multiarch --target=arm-linux-gnueabihf. 
  Esto de --enable-multiarch --target=arm-linux-gnueabihf significa que <sysroot>/usr/lib/arm-linux-gnueabihf se añade a la lista de búsqueda.
-CUIDADO con no tener instalado svn antes de entrar en menuconfig, o tendrás un aviso de peligro en lo de la librería EGLIB.
-CUIDADO con EGLIBC, que está mal y trata de detectar versiones viejas del MAKE (la 3.69 o la 3.89, y yo tengo la 4.0), así que dará un error durante la construcción...
  Es una putada muy seria que se pare la construcción, pero hay solución. Editamos build.log y nos vamos al final. Vemos que nos ha dado un error con la versión de MAKE.
  Vale: pues editamos .build/src/eglibc-2_13/configure, buscamos donde detecta la versión de MAKE (buscando ac_prog_version sucesivas veces hasta que veamos que se está detectando
  la versión de MAKE y no de otra cosa), cambiamos para que detecte la nuestra (make --version en el PC) y listo. 
-SI TIENES ERRORES DE COMPILACIÓN de estos que parece que se ha corrompido la memoria por el calentón, es hora de borrar todo en ~/cross-rasp, menos .config, y volver a empezar.
Acuérdate de ajustar lo de la versión de make en  .build/src/eglibc-2_13/configure, que no existirá hasta que empiece a instalar las herramientas.

Hacemos "ct-ng build" y si este proceso se para es porque hemos elegido algo mal en el menuconfig.
Ahora, como en el config que hemos usado se especifica un directorio de destino, ya tenemos el cross compiler ARM en 
~/x-tools/arm-unknown-linux-gnueabi-gcc.

NOTA: Este proceso es muy dado a errores durante la construcción del compilador, librerías, etc.. Así que tira de leer el build.log, irte al final y pegar
el error en google, que a la gente también le pasan estas miserias.

NOTA: Para cambiar algo en la configuración, debes borrar totalmente el directorio cross-rasp y empezar de cero, o dará problemas
absurdos durante el proceso de building.

PARTE 1: OPCIÓN B (Recomendad en Octube de 2015)
================

Clonamos el repo de https://github.com/raspberrypi/tools.git y nos queda el cross-compiler en tools. Lo demás es igual sólo que la ruta de los ejecutables del compilador es:
/home/manuel/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin
Y la tupla (para crosscompilar en local, lo que se llama host_alias en el scummvm que se cross-compila en local) es arm-linux-gnueabihf.

PARTE 2: CONFIGURANDO EL SERVIDOR Y EL CLIENTE CUANDO YA TENEMOS CROSS-COMPILER (Válido también para Rpi)
===============================================================================================

Tenemos el cross-compiler ya.
Si estamos en el caso en que estamos usando el cross-compiler oficial, habremos clonado el repo y tendremos el compilador para la Pi en:
~/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin

PERO nos faltan los links simbólicos de nombres cortos a gcc, g++ y otras herramientas, ya que sólo tenemos
los archivos con nombres completos (o sea que tenemos "arm-unknown-linux-gnueabi-gcc"  o "arm-linux-gnueabihf-gcc" pero no tenemos "gcc" a secas).
Así que creamos el siguiente script, le damos 755 y lo ejecutamos estando dentro del directorio ~/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin:

#!/bin/bash
for file in `ls`; do
        ln -s $file ${file#arm-linux-gnueabihf-}
done

Y ahora, ya deberíamos tener gcc, g++, etc. Compruébalo.

Ahora instalamos distcc en el cliente y en el servidor. Simplemente, sudo apt-get install distcc en ambos.

En el servidor, editamos /etc/default/distcc y ponemos:

STARTDISTCC="true"
ALLOWEDNETS="192.168.5.0/24 192.168.5.8"  <-----Esto es la IP de la red del cliente y del propio cliente, separadas por espacio.
LISTENER="192.168.5.7"
(quitamos LISTENER="127.0.0.1").

Ahora, también en el servidor, editamos /etc/init.d/distcc y en PATH añadimos delante el path donde tenemos los ejecutables de nuestro cross-compiler.
La línea en cuestión quedaría así si hemos construido nuestro cross compiler:

PATH=/home/manuel/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

Lanzamos el servidor. Para ello, en un systema con systemd hacemos:

systemctl daemon-reload
systemctl start distcc
systemctl status distcc

Tienes que ver que te sale la línea en verde:
Active: active (running) since ...

Si no va, cambia lo que sea en los ficheros de configuración y a continuación haz:
systemctl stop distcc
systemctl daemon-reload
systemctl start distcc

En cambio, si estamos en un sistema viejo con sysvinit, 
Lanzamos el servidor con sudo /etc/init.d/distcc start --verbose

Ahora, en el cliente, editamos /etc/distcc/hosts, comentamos la línea de "+zeroconfig" y ponemos sin más la IP del servidor:
192.168.5.7

Ahora también en el cliente tenemos que exportar el path del compilador, que ya no queremos que sea el gcc local sino un link sombólico gestionado
por distcc. Así que dejamos así el path en ~/.profile:

# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
     PATH="/usr/lib/distcc:$HOME/bin:$PATH"
fi

Ahora en el cliente quitamos el distcc del inicio:

sudo systemctl disable distcc

...y creamos el directorio ~/.bin, que de todos modos nos va a venir bien.

Ahora comprobamos que todo está bien: 
-En el servidor, podemos confirmar que distcc escucha en el puerto 3632 de la IP 192.168.5.7, que es la der server. Para ello, haremos
sudo netstat -apn |grep 3632
Esto es lo que se llama el "binding" del servidor.
-También podemos comprobar si el puerto 3632 de server está abierto, de dos maneras: desde el cliente, con telnet 192.168.5.7 3632. Si la pantalla
sale en negro o con ASCII raros todo va bien, ya que telnet lee datos crudos por ese puerto.
O bien desde el propio servidor, o desde el cliente, con "nmap -p 3632 192.168.5.7". Nos tiene que salir que el puerto 3632 TCP está abierto. 

***********Las voces en OSMAND+ (osmand) en Android**********************************************************************************

Este tema siempre da algo de guerra.
Debes instalar un motor de TTS en el sistema, que las versiones libres de Android no suelen traerlo. Instala el AHOTTs de la Aurora Store (Clon libre de la PlayStore).
Elígelo como motor TTS en la configuración del teléfono, en accesibilidad. 
Ya te debería ir en OSMAND.

***********Actualizar gcc 4.6 a gcc 4.7 en raspbian****************************************************************************************

Tras hacer un apt-get update y un apt-get upgrade, y sin eliminar NADA, o sea, dejando gcc-4.6 ya que tiene muchas dependencias, hacemos
¡¡¡¡¡¡CUIDADO E INSTALA AMBOS!!!!!!
sudo apt-get install gcc-4.7
sudo apt-get install g++-4.7

Creamos el script /usr/bin/gcc-set-default-version con el contenido:

#!/bin/bash 
usage() {
        echo 
        echo Sets the default version of gcc, g++, etc
        echo Usage:
        echo 
        echo "    gcc-set-default-version <VERSION>"
        echo 
        exit
}
cd /usr/bin
if [ -z $1 ] ; then 
        usage;
fi 
set_default() {
        if [ -e "$1-$2" ] ; then 
                echo $1-$2 is now the default
                ln -sf $1-$2 $1
        else 
                echo $1-$2 is not installed
        fi
}
for i in gcc cpp g++ gcov gccbug ; do 
        set_default $i $1
done

Le damos permisos de ejecución (755 sirve), y hacemos:

sudo gcc-set-default-version 4.7

Y ya debería estar. Nos dirá que no tenemos instalado gccbug-4.7, pero eso no es importante.

Instalamos VIM y le ponemos el ~/.vimrc que tienes en la sección de apuntes del VIM...
Y ahora, para que VIM recuerde la última posición en que estábamos cuando abrimos un fichero dado por última vez, editamos /etc/vim/vimrc
y descomentamos esto, que viene comentado por defecto:

" Uncomment the following to have Vim jump to the last position when
" reopening a file
if has("autocmd")
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

SI ESTO NO FUNCIONA, comprueba los permisos de ~/.viminfo. Debe pertenecer al usuario actual, si no es así, probablemente no vuelva a la última
posición cuando reabrimos un fichero.

***********Comparar ficheros con VIM***************************************************************************************************

Puedes abrir dos ficheros en modo comparación con 

vim -d fichero1 fichero2

Las líneas de guiones en uno son líneas que el otro tiene pero ese no, y de ese modo líneas iguales aparecen a la misma altura!.

***********La utilidad LOCATE**********************************************************************************************************
Efectivamente, sirve para buscar archivos en todo el disco, tirando de base de datos en lugar de buscar físicamente.
Así que lo instalamos con:

apt-get install locate

y antes de usarlo hacemos

sudo updatedb

Y ya se supone que podemos usarlo.

***********TIC-80, una consola imaginaria para Pi****************************************************************************************************

Clonamos su repo y actualizamos los submódulos para poder compilar:
git clone --depth 1 https://github.com/nesbox/TIC-80.git
git submodule update --init --recursive

Creamos el dir de compilación, entramos, configuramos y compilamos:
mkdir b3
cd b3
cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_LIBRETRO=ON -DBUILD_SDL=OFF -DDISABLE_NETWORKING=TRUE \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
make -j4

***********RIGEL, el engine de Duke Nukem II************************************************************

Clonamos tu repo:
git clone --depth 1 https://github.com/lethal-guitar/RigelEngine.git
git submodule update --init --recursive

mkdir b4
cd b4

Compilamos con GLES con:
cmake -DUSE_GL_ES=ON -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..

***********Compilar RAZE, el engine de Duke Nukem, Blood, Exhumed, etc para Linux****************************************************************

Debe funcionar sobre VULKAN. Olvídate de trucos para OpenGL, ya que engañar con la versión de OpenGL hace que se corrompa la SD.
No hace falta pasar ningún FLAG para compilar el soporte de Vulkan, se detecta solo.

-Instalamos una dependencia previa:
sudo apt-get install libvpx-dev

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
Instala libmpg123-dev y libvorbis-dev.
Descarla los últimos sources estables de:
https://github.com/coelckers/ZMusic/releases

Creamos el directorio de compilación, entramos y configuramos, compilamos e instalamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"
make -j4
sudo make install

-Vamos a por RAZE en sí.
Clonamos su repo:
git clone --depth 1 https://github.com/coelckers/Raze.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"
make -j4

Ahora, creamos ~/raze y metemos allí el ejecutable resultante ("raze"), raze.pk3, el directorio soundfonts, y el duke3d.rgp

Para ejecutarlo con el renderer VULKAN, lo lanzamos con: +vid_preferbackend 1
Puedes desactivar TODO el antialiasing, poner FPS a UNLIMITED, etc

***********EDUKE32: Duke Nukem 3D en la Raspberry Pi*********************************************************************************************

Va sobre SDL2 + SDL2 Mixer. Se supone que tenemos ambas instaladas y listas!

Preferentemente, usa este fork, que inclue soporte para BLOOD y EXHUMED también:
git clone --depth 1 https://github.com/nukeykt/NBlood.git

Si quieres usar el eduke32 original, clona su repo de aquí:
git clone --depth 1 https://voidpoint.io/terminx/eduke32.git

Editamos source/build/src/sdlayer.cpp y hacemos todos los cambios que se detallan a continuación:

-Añadimos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
antes de SDL_CreateWindow()

-Cambia todas las ocurrencias de SDL_WINDOW_FULLSCREEN por SDL_WINDOW_FULLSCREEN_DESKTOP

Compilamos con:
(Como ves, tenemos que desactivar tristemente las LTO, linking time optimization... si las queremos hay que cross-compilar de verdad, nada de distcc!!)
Funciona con aceleración GLES, por cierto, usando POLYMOST, y bastante bien además.

make -j4 RELEASE=1 WITHOUT_GTK=1 USE_OPENGL=0 USE_LIBVPX=0 HAVE_FLAC=0 LTO=0 \
OPTOPT="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

Para linkar sin LTO con el fin de hacer pruebas, pásale también LTO=0, ya que tarda AÑOS en compilar con LTO en la Rasp.

Si te da problemas porque, a pesar de que estamos deshabilitando libflac, la busca en tiempo de linkado, borra la referencia de libflac de la plataforma LINUX
en el Makefile, y fuera.

Si quieres música, bájate un pack de música de http://hrp.duke4.net/download.php, y lo descomprimes en donde tengas el duke3d.grp, es decir, los .ogg o lo que sea ahí tirados con el duke3d.grp. Te recomiendo este: http://www.duke4.org/files/nightfright/music/duke3d_music-sc55.zip
Si el pack está en FLAC o en OGG necesitas que el eduke32 se haya linkado contra la librería correspondiente.

							=========================================

Para CROSS COMPILAR EDUKE32: (para poder tener LTO, Linking Time Optimizations):

export PATH=$PATH:/home/manuel/tools/arm-bcm2708/arm-bcm2708hardfp-linux-gnueabi/bin

En Makefile.common, la idea es que en vez de llamar a sdl2-config (que incluso si consiguiésemos que llamase a /opt/rpi_root/usr/bin/sdl2-config estaría dando --cflags y --libs 
con rutas incorrectas) le pasemos nosotros lo que daría sdl2-config pero alterado para el entorno de cross-compilación (o sea que llamar a sdl2-config, o SDLCONFIG como lo llama
internamente el script queda prohibido). Para ello hacemos varias cosas:

-Comenta ciertas lineas:
SDLROOT:=$(strip $(shell $(SDLCONFIG) --prefix))
LIBS+= -pthread

-Deja las líneas de SDLCONFIG_COMMONFLAGS y SDLCONFIG_LIBS, que es donde se llamaba originalmente a SDLCONFIG (sdl2-config) tal que así
(esto está basado en mis notas de errores de crosscompilación en "programacion.txt"):

SDLCONFIG_COMMONFLAGS:=$(subst -Dmain=SDL_main,,-I/opt/rpi_root/usr/include/SDL2 -I/opt/rpi_root/opt/vc/include -I/opt/rpi_root/opt/vc/include/interface/vcos/pthreads -I/opt/rpi_root/opt/vc/include/interface/vmcs_host/linux -D_REENTRANT)
SDLCONFIG_LIBS:=--sysroot=/opt/rpi_root -B/opt/rpi_root/usr/lib/arm-linux-gnueabihf -Xlinker -rpath-link=/opt/rpi_root/usr/lib/arm-linux-gnueabihf -Xlinker -rpath-link=/opt/rpi_root/lib/arm-linux-gnueabihf -L/opt/rpi_root/usr/lib/arm-linux-gnueabihf -L/opt/rpi_root/usr/lib -Wl,-rpath,/opt/rpi_root/usr/lib -L/opt/rpi_root/usr/lib/arm-linux-gnueabihf -L/opt/rpi_root/lib/arm-linux-gnueabihf -L/opt/rpi_root/usr/lib -L/opt/rpi_root/opt/vc/lib -lbcm_host -lvcos -lvchiq_arm

Y ahora ya compila, con nivel de opimización -O2 y flags para la Pi1 quedaría:

make -j8 USE_LIBVPX=0 USE_LIBPNG=0 WITHOUT_GTK=1 USE_OPENGL=0 CROSS=bcm2708hardfp- OPTLEVEL=3 OPTOPT="-marm -mfpu=vfp -mfloat-abi=hard"

Para usar por ejemplo una banda sonora custom, le puedes pasar /x <ruta al archivo .def>

************Schismtracker en la Raspberry Pi con SDL2 y escalado de lujo*******************************************************************

Ni que decir tiene que antes de nada tenemos que tener las SDL2 listas.
Clonamos el repo que tiene el branch de SDL2:

git clone --depth 1 -b sdl2 https://github.com/davvid/schismtracker.git

Instala autoconf:

sudo apt-get install autoconf

Editamos configure.ac y borramos la línea de AM_PATH_SDL

Ejecutamos: 
autoreconf -vif
./configure --without-x

Editamos schism/video.c, y movemos la llamada a 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
al principio de la función en la que está, que se llama void video_init().

Comentamos la línea
SDL_WM_SetIcon(icon, NULL);
en ese mismo fichero, schism/video.c

Editamos Makefile y dejamos la línea de CFLAGS así: (el Makefile es un poco lioso porque es de generación automática, busca -g y te lleva al sitio)

CFLAGS = -O2 -marm -mfpu=vfp -mfloat-abi=hard -march=armv6j

Quitamos el -O2 y el -g de OBJFLAGS.

Añadimos -lm a LDFLAGS.

Compilamos y listo!

************ECWOLF, el mejor port del Wolfenstein 3D, en la Pi*****************************************************************************

Pillamos la última versión de su repo:
https://bitbucket.org/ecwolf/ecwolf/downloads/

Puedes añadir en src/sdlvideo.cpp el típico
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
justo antes de SDL_CreateWindow(), para el escalado emborronado que te gusta.

Para compilar contra SDL2, SDL2_net y SDL2_mixer, y ya pasándole los flags de la Pi a cmake:

cmake -DCMAKE_BUILD_TYPE=Release -DGPL=ON -DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
(PARA compilar en modo verbose, haz make VERBOSE=1)

Ahora, para activar el vsync es en los menús. Y para que vaya suave, le pasas al ejecutable el parámetro --noadaptive
Puedes establecer un buffer de audio menor con --audiobuffer 512

Sólo hace falta tener el ejecutable en el mismo directorio que los datos del wolfenstein (versión de ACTIVISION, NO la original de Apogee, OJO!!!), y funcionará sin más.

Pon la resolución a 320x200 en el menú, fullscreen, vsync ON.

NO soporta el Rise Of The Triad, sólo el Wolfenstein y el Spear of Destiny.

Para mejorar la música y los gŕaficos, yo uso el pack ECWolf_hdmus_BrainStewX para la música (tienes que tener SDL2_Mixer compilado con soporte de OGG, para lo que habrás tenido que instalar libogg-dev antes de configurar, compilar e instalar SDL2_Mixer, lo normal es que ya lo tengas porque es lo que usas para las músicas custom del SCUMMVM):
https://forum.zdoom.org/viewtopic.php?f=19&t=48633

Y el pack hi-res sencillo de aquí para los gráficos de armas y enemigos, sonidos fx, etc:
https://www.moddb.com/games/wolfenstein-3d/addons/ecwolf-rmst

Al final, mi script wolf3d contiene esta línea para lanzar el ECWOLF a mi gusto:
./ecwolf --noadaptive --audiobuffer 512 --file hdpack.pk3 hdmus.pk3

NOTA: SI USAS EL CORE DE RETROARCH, pon los datos y el EXE de la versión de ACTIVISION, NO la original de Apogee, y a Retroarch, además del core, le pasas el WOLF3D.EXE.
Y se compila con:

CFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" cmake -DLIBRETRO=1 ..

***********XASH3D para Raspberry Pi (GLES) **********************************************************************************************

XASH3D SOPORTA AHORA TANTO OPENGL COMO GLES1 Y GLES2, SIN WRAPPERS NI NADA.
OJO; SI ESTAS INSTRUCCIONES TE DAN ERRORES, QUE SEPAS QUE PROCEDEN DE AQUÍ:
https://github.com/FWGS/xash3d/wiki/Building-and-running#cmake-recommended-for-non-windows

Instalamos una pequeña dependencia que hace falta:
sudo apt-get install --no-install-recommends libfontconfig1-dev

Clonamos el repo principal:
git clone https://github.com/FWGS/xash3d-fwgs
git submodule init && git submodule update --init

Ahora creamos el directorio de compilación, configuramos con CMAKE, y compilamos:
mkdir build
cd build
cmake .. -DXASH_SDL=ON -DXASH_VGUI=OFF -DXASH_64BIT=1
make -j4

Ahora, creamos ~/halai, y vamos copiando los archivos que necesitamos:
cp engine/libxash.so game_launch/xash3d mainui/libxashmenu64.so ~/halai
Ahora nos vamos a ~/halai, y creamos nuestro script de lanzamiento, yo lo he llamado también "halai" porque es gracioso, con el siguiente contenido:
LD_LIBRARY_PATH=. ./xash3d -dev 5
Ahora copiamos el directorio "valve" de una instalación de Half Life a ~/halai/valve
(Tienen un CD completo en archive.org, en formato CUE/BIN que puedes convertir a .ISO+.WAV con:
bchunk -w HALF_LIFE.BIN HALF_LIFE.BIN half

Ahora vamos a por las librerías del juego: clonamos esto:
git clone --depth 1 https://github.com/FWGS/hlsdk-xash3d

Creamos el directorio de compilación y compilamos para 64bits:
cd hlsdk-xash3d
mkdir build
cd build
cmake -D64BIT=ON ..
make -j4

Esto nos va a generar dos archivos: hl64.so y client64.so
Mandamos estos a ~/halai/valve/dlls/hl64.so y ~/halai/valve/cl_dlls/client64.so
Editamos ~/halai/valve/gameinfo.txt, y dejamos la línea de gamedll_linux así:
gamedll_linux           "dlls/hl64.so"
(Le estamos diciendo que nuestra librería de juego es de 64bits y se llama hl64.so).
Ahora nos metemos en ~/halai/valve y nos bajamos el archivo "delta.lst" de los servidores de VALVE. Ya casi estamos!:
cd ~/halai/valve
wget https://raw.githubusercontent.com/ValveSoftware/halflife/master/network/delta.lst

Pues ya tenemos instaladas las librerías del juego. Ya debeíamos poder darle a NEW GAME.
Nos vamos a ~/halai y ejecutamos nuestro script de lanzamiento, ./halai

Y si quieres counterstrike 1.6, la librería de juego que tendrías que compilar e instalar en ~/halai/valve/dlls/ es esta:
https://github.com/FWGS/cs16-client/releases

SI QUIERES TENER MÚSICA DURANTE EL JUEGO, cuando ripees el CD con bchunk (porque vas a necesitar hacerlo para sacar el diretorio "valve" de la ISO) hazlo así:
bchunk -w HALF_LIFE.BIN HALF_LIFE.BIN half
Y ahora, los WAV que has obtenido los conviertes a mp3 con:
for i in *.wav; do ffmpeg -i "$i" -ab 320k "${i%.*}.mp3"; done
Los subes a ~/halai/valve/media, y editas cdaudio.txt para que las pistas se llamen como los mp3 que acabas de generar (half01.mp3, half02.mp3, etc).

Y si quieres counterstrike 1.6, la librería de juego que tendrías que compilar e instalar en ~/halai/valve/dlls/ es esta:
https://github.com/FWGS/cs16-client/releases

************SABER QUÉ CFLAGS USAR*******************************************************************************************************

Para saber qué hace GCC cuando le decimos que use "-march=native" en nuestra plataforma, hacemos:
gcc -### -E - -march=native 2>&1 | sed -r '/cc1/!d;s/(")|(^.* - )|( -mno-[^\ ]+)//g' 

Y para saber qué hace GCC cuando decirmos que use "-mtune=native" en nuestra plataforma, hacemos:
gcc -### -E - -mtune=native 2>&1 | sed -r '/cc1/!d;s/(")|(^.* - )|( -mno-[^\ ]+)//g'

Así que un set de flags neutral para Pi3 y Pi4, 32 o 64bit, con un GCC moderno en el que NATIVE funciona ya bien, sería:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

************Parchear con XDelta en Linux************************************************************************************************

SI ES UN PARCHE XDELTA (como el del Xenogears al castellano):
xdelta patch parche_CD1_con_videos.xdt Xenogears\ \(USA\)\ \(Disc\ 1\).bin Xeno1.bin


SI ES UN PARCHE XDELTA3:

En este caso, tienes que usar el comando xdelta3, NO el xdelta.
xdelta3 -d -s original parche resultado

************Wolf4SDL (Wolfenstein 3D) en la Raspberry Pi*********************************************************************************

Compilaro y hacerlo funcionar me llevó un rato. Editamos "version.h" y nos vamos a los "defines used for different versions", donde dejamos descomentados
estos solamente:
#define GOODTIMES
#define CARMACIZED 

Luego nos bajamos la versión de Activision de emuparadise o donde nos de la gana, y pasamos a minúsculas todos los ficherso WL6 y el EXE.
Los metemos en el mismo directorio que el ejecutable de wolf4sdl (wolf3d), y ya debería ir (Excepto por temas de las SDL, ya que por defecto
el juego intenta reutilizar el modo de vídeo actual y eso está mal: editamos el código y lo ponemos a 320x200 en 16bpp).

Si aún así no tira, edita Makefile y cambia el DATADIR a ./, de tal manera que desde ahora simplemente metes los ficheros de datos del juego en el mismo
directorio que el ejecutable que acabas de compilar y los encuentra.

Otra cosa: los scripts de configuración del juego usan sdl-config --libs (o lo que es lo mismo, pkg-config --libs sdl) para ver dónde están tanto las
librerías libSDL1.2 como las SDL_mixer. Así que si tienes las SDL1.2.x en /usr/local/lib/armhf-gnueabi, no va a encontrar las SDL_mixer, ya que estas
están en /usr/local/lib y sdl-config o pkg-config sólo devuelven las rutas de las libSDL1.2.x y se asume que ahí van a estar las SDL_mixer también.
Así que mírate los apuntes sobre SDL1.2.x que hay más arriba, para instalar SDL y SDL_Mixer ambas en /usr/local/lib, y luego ejecuta ldconfig --verbose, etc.

************MÉTODO STANDARD PARA EJECUTAR PRGRAMAS AL INICIO O LANZAR SERVICIOS: DEPENDENCY BASED BOOTING SEQUENCE*************

Estos son los apuntes para sistemas que cumplen con DDBS de la FFS, como Debian, Raspbian y demás distribuciones "legales".

Si simplemente queremos que algo se ejecute como root al inicio, justo antes de que se lancen las ttys de usuario, pues con ponerlo
en /etc/rc.local antes del "exit 0", nos vale. 
Pero si queremos lanzar un SERVICIO que se quedará corriendo de fondo en lugar d un programa que retore y sigamos con una secuencia de comandos 
(cosa que no se  puede hacer si el servicio no retorna al prompt, cosa que no tiene por qué hacer), así un control más fino sobre en qué cambio de runlevel 
queremos que se ejecute, lo que es interesante a la hora de lanzar servicios, necesitamos un script de inicio.

Los scrips de inicio están en /etc/init.d, y la utilidad que los coloca en la scuencia de arranque lo que hace es crear links simbólicos a esos scrips en los dirs
/etc/rcN.d, siendo N un runlevel en que ese servicio estará activo. Así, un servicio que estará activo en los runlevels "normales" de un sistema debian, tendrá 
links simbólicos a su script de incio en los directorios /etc/rc2.d, /etc/rc3.d, /etc/rc4.d y /etc/rc5.d. Pero esto es algo que gestiona la herramienta que se
encarga de ponerlos y quitarlos del inicio, que es "insserv", y que ANTIGUAMENTE era update-rc.d, que ya NO SE USA.

El formato de un script de inicio para insserv es este:

#!/bin/bash

### BEGIN INIT INFO
# Provides:          fsynthserv
# Required-Start:    fluidsynth
# Required-Stop:     fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: binds MIDI ports
# Description:       binds MIDI ports

### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    #Espero a que esté listo Fluidsynth. Aunque se lance antes su script, el sinte tarda en estar listo.
    sleep 4
    echo "Estableciendo conexión del sintetizador con el secuenciador de red"
    aconnect 128:0 129:0
    ;;
  stop)
    echo "Deshaciendo conexión del sintetizador con el secuenciador de red"
    aconnect -x
    ;;
  *)
    echo "Usage: /etc/init.d/fsynthserv {start|stop}"
    exit 1
    ;;
esac
exit 0

La única novedad reseñable pero imprescindible es la cabecera, INIT INFO, que determina cómo colocará insserv este script de inicio. 
Los campos más importantes a este propósito son:

# Provides:          fsynthserv

¿Qué nombre en el sistema tiene el servicio que activamos? Esto sirve luego para que otros scripts dependan de él y nos podamos referir a él.

# Required-Start:    fluidsynth

¿Qué servicios tienen que estar activos ANTES de lanzar este? Esto es LO MÁS IMPORTANTE, pues es lo que usa insserv para ponerlo después de 
otros servicios, para establecer el orden de arranque. 
MUCHO CUIDADO: si este servicio depende de un script que está en /etc/init.d, con poner el nombre del script TAL CUAL no vale. NO hay que poner
un $ delante del nombre. PERO SI SE TRATA de nombres abstractos de características del sistema, como $time, $local_fs, $network... pues sí se pone.
Por ejemplo, $time indicaría que se ha establecido la hora de sistema por el método que sea, $network implicaría los niveles inferiores de metworking
como la tarjeta ethernet, etc.
PERO TEN MUCHO CUIDADO y si simplemente quieres que se ejecute este script TRAS otro script que está en /etc/init.d, pon simplemente el nombre 
del otro script sin ninguna $. MUCHO cuidado con poner la $ cuando no hace falta, porque NO FUNCIONARÁ e insserv no establecerá el orden correcto.

# Required-Stop:     fluidsynth

Esto es menos importante: se trataría de los servicios que deben estar activos cuando se desactive este.

El resto de campos se entienden bien, ya sabes de qué van y no los voy a explicar porque no hace falta.

Ahora simplemente haríamos:

sudo insserv fsynthserv

para poner el servicio en el arranque (se supone que el servicio fluidsynth, o sea, el script del mismo nombre, ya está en el arranque puesto).
O bien 

sudo insserv -r fluidsynth

para quitarlo del arranque. Olvídate de los nombres de los symlinks, que si S99, que si K01... Nada, eso ya NO IMPORTA Y NO SE USA. Ahora todo va con
dependency based booting sequence.

LA MEJOR guía para esto la tienes en este mismo directorio como "Orden de arranque o inicio de scripts (DBBS)" y procede de la página
http://www.openredes.com/2011/05/13/orden-de-arranque-o-inicio-de-scripts-de-etcinit-d-en-debian-squeeze-6-0-solucion-a-update-rc-d-using-dependency-based-boot-sequencing/ 

************MÉTODO ANTIGUO para ejecutar programas  o scripts al inicio como root: LUBUNTU (NO DEBIAN)**************************************************************

¡¡¡CUIDADO!!! ESTO SÓLO SIRVE PARA DISTROS BASADAS EN UBUNTU, QUE NO CUMPLE EL "DEPENDENCY BASED BOOTING SEQUENCE" DE LA FSS.
ASÍ QUE EN RASPBIAN O DEBIAN NO SE USA ESTO. 

Si simplemente queremos que algo se ejecute como root al inicio, justo antes de que se lancen las ttys de usuario, pues con ponerlo
en /etc/rc.local antes del "exit 0", nos vale. 
Pero si queremos lanzar un SERVICIO que se quedará corriendo de fondo en lugar d un programa que retore y sigamos con una secuencia de comandos 
(cosa que no se  puede hacer si el servicio no retorna al prompt, cosa que no tiene por qué hacer), así un control más fino sobre en qué cambio de runlevel 
queremos que se ejecute, lo que es interesante a la hora de lanzar servicios, pues seguimos estos pasos:

-El formato de un script de inicio de servicio es este:

#! /bin/sh
# /etc/init.d/blah
#

# Cosas que se ejecutan siempre
touch /var/lock/blah

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    echo "Iniciando script blah "
    echo "Aquí se podrían hacer más cosas"
    ;;
  stop)
    echo "Deteniendo script blah "
    echo "Aquí se podrían hacer más cosas"
    ;;
  *)
    echo "Usage: /etc/init.d/blah {start|stop}"
    exit 1
    ;;
esac

exit 0

-Creamos nuestro script, lo metemos en /etc/init.d que es el "almacén" de scripts, y le damos permisos de ejecución. Un 755 está bien.
-Ahora tenemos dos opciones: o le decimos que lo meta en uno o varios runlevels automáticamente usando algo tipo:
"update-rc.d <nombre_script_en_/etc/init.d> defaults", o creamos nosotros los link simbólicos de cada runlevel siguiendo una nomencleatura:
por ejemplo, si queremos que se inicie el servicio al entrar en el runlevel 2 y que se pare al entrar en el runlevel 6, que es el de reiniciar el sistema, 
y en el 0, que es el de haltear el sistema, haremos estos links:
"ln -s /etc/init.d/blah /etc/rc2.d/S66blah"
"ln -s /etc/init.d/blah /etc/rc0.d/K66blah"
"ln -s /etc/init.d/blah /etc/rc6.d/K66blah"
La "S" es de "start" y la "K" es de "kill", lógicamente. Así, si se cambia a alguno de esos dos runlevels, se hará lo que se tenga que hacer según corresponda.
El número determina el órden en que se ejecuta el script (iniciando o deteniendo el servicio) dentro del runlevel en cuestión. A mayor número, menor
prioridad. Así, un link simbólico llamado S99 asegura que se ejecutará el script de inicio del servicio en último lugar respecto a los demás de ese runlevel.

ANEXO:
-Para saber en qué runlevel estamos, simplemente tenemos el comando "runlevel".
-Los runlevels importantes son: 0 para haltear el sistema, 1 es el modo single-user para reparaciones, 2 al 5 son los normales o modos multiusuario
(en raspbian empezamos al logarnos en modo texto en el runlevel 2) y el 6 es reiniciar el sistema.

*************Raspberry Pi y establecimiento de modos de vídeo tras el arranque: tvservice*********************

Para listar los modos de vídeo de una categoría:

tvservice --modes=CEA
tvservice --modes=CEA

Para cambiar de modo de vídeo:

Apagamos el monitor:

tvservice -o

Lo encendemos con un modo concreto:

/opt/vc/bin/tvservice --explicit="CEA 1 HDMI"

O si quisiéramos encenderlo sin más, 

tvservice -p

Y se nos ve la pantalla en negro. PERO si lanzas un programa, ya se ve :O

Estos scripts, además, permiten que no se quede la pantalla en nego y adaptan el tamaño del framebuffer, con lo que el cambio de
resolución es perfecto:

/opt/vc/bin/tvservice --explicit="CEA 1 HDMI"
sudo chvt 3
sudo chvt 1
sudo fbset -xres 320 -yres 240

/opt/vc/bin/tvservice --explicit="DMT 39 HDMI"
sudo chvt 3
sudo chvt 1
sudo fbset -xres 1360 -yres 768

*************INSTALAR FluidSynth libs desde sources (sin depender de x11-common)********************************************

Instalamos unas dependencias que tiene. Necesita glib porque el threading multiplataforma se hace gracias a glib. Es inevitable.

sudo apt-get install libglib2.0-dev --no-install-recommends

Bajamos la última versión estable de fluidsynth de aquí:
https://github.com/FluidSynth/fluidsynth/releases

Y configuramos desde un directorio de build que creamos nosotros:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
cmake .. -DCMAKE_INSTALL_PREFIX=/usr -DLIB_INSTALL_DIR=lib -DCMAKE_BUILD_TYPE=Release -Denable-dbus=0 -Denable-ipv6=0 -Denable-aufile=0 -Denable-network=0 -Denable-oss=0 -Denable-sdl2=0 ..

Y compilamos con make -j4, e instalamos con:
sudo make install

*************MIDI remoto con fluidsynth o timidity (MIDI over LAN)*************************************************************

SERVIDOR 
========

aseqnet  &

fluidsynth --audio-driver=alsa -s merlin_gold.sf2
o bien
timidity -iA -Os1 -B 2,3 &

manuel@vader:~$ aseqdump -l
 Port    Client name                      Port name
  0:0    System                           Timer
  0:1    System                           Announce
 14:0    Midi Through                     Midi Through Port-0
128:0    Net Client                       Network

manuel@vader:~$ aplaymidi -l
 Port    Client name                      Port name
 14:0    Midi Through                     Midi Through Port-0
128:0    Net Client                       Network
129:0    FLUID Synth (4309)               Synth input port (4309:0)

aconnect 128:0 129:0

CLIENTE
=======

aseqdump -l
aseqnet 192.168.5.8 &
aseqdump -l
aplay -p 128:0 nombre.mid

Para scummvm, podemos exportar SCUMMVM_PORT="128:0", o bien usar el parámetro de configuración alsa_port.

Para compilar fluidsynth podemos hacerlo desde los sources estables antiguos que hay en su página o desde svn:

-DESDE LOS SOURCES ESTABLES:

Editamos configure y quitamos los O2 y los -g que encontremos antes de ejecutar configure.
Ahora ya ejecutamos configure así:

CFLAGS="-O2 -march=armv6 -mfpu=vfp -mfloat-abi=hard" CXXFLAGS="-O2 -march=armv6 -mfpu=vfp -mfloat-abi=hard" ./configure  --prefix=/usr --disable-aufile-support --disable-oss-support --disable-dbus-support

Y POR ÚLTIMO compilamos.

-DESDE SVN:

Antes de nada necesitamos libtool.
sudo apt-get install libtool

Clonamos su repo:
git clone --depth 1 git://git.code.sf.net/p/fluidsynth/code-git

Editamos configure.ac y añadimos:
m4_pattern_allow([AC_LIB_PROG_LD_GNU])

Ejecutamos autogen.sh

Editamos configure y quitamos los O2 y los -g que encontremos antes de ejecutar configure.
Ahora ya ejecutamos configure así:

CFLAGS="-O2 -mfpu=vfp -mfloat-abi=hard -march=armv6j" CXXFLAGS="-O2 -mfpu=vfp -mfloat-abi=hard -march=armv6j" ./configure --prefix=/usr --disable-oss-support --disable-aufile-support  --disable-dbus-support

Y POR ÚLTIMO compilamos.

Para automatizar todo esto y hacernos un sinte que automáticamente haga estas cosas:
-Se lance el aseqnet y escuche en red en la IP 192.168.5.10 o la que nos de la gana.
-Fluisynth se lance al inicio como servicio
-Conectamos el aseqnet con fluidsynth para pasarle a fluidsynth los comandos MIDI que le llegan a aseqnet

Esto lo he resuelto con dos scripts de inicio de sistema, ya que fluidsynth es un servidor y no retorna al prompt, lo que tiene bastate sentido.
Estos dos escripts van en /etc/ini.d y son los siguientes:
/etc/init.d/fluidsynth:

#!/bin/bash

### BEGIN INIT INFO
# Provides:          fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Required-Start:
# Required-Stop:
# Short-Description: Sintetizador midi por software
# Description:       Un sintetizador MIDI por software
### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    echo "Iniciando fluidsynth"
    aseqnet &
    /usr/local/bin/fluidsynth -i -l -s /home/pi/merlin_gold.sf2 &
    ;;
  stop)
    echo "Deteniendo fluidsynth"
    killall fluidsynth
    ;;
  *)
    echo "Usage: /etc/init.d/fluidsynth {start|stop}"
    exit 1
    ;;
esac

exit 0



Y /etc/init.d/fsynthserv

#!/bin/bash
### BEGIN INIT INFO
# Provides:          fsynthserv
# Required-Start:    fluidsynth
# Required-Stop:     fluidsynth
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: binds MIDI ports
# Description:       binds MIDI ports
### END INIT INFO

# Cosas que se ejecutan si las pedimos específicamente pasando parámetros al script
case "$1" in
  start)
    #Espero a que esté listo Fluidsynth. Aunque se lance antes su script, el sinte tarda en estar listo.
    sleep 4
    echo "Estableciendo conexión del sintetizador con el secuenciador de red"
    aconnect 128:0 129:0
    ;;
  stop)
    echo "Deshaciendo conexión del sintetizador con el secuenciador de red"
    aconnect -x
    ;;
  *)
    echo "Usage: /etc/init.d/fsynthserv {start|stop}"
    exit 1
    ;;
esac
exit 0



Como puedes ver, fsynthserv depende para ejecutarse de fluidsynth, por lo que al hacer 
insserv fluidsynth
insserv fsynthserv
el comando insserv los pondrá en el orden correcto. 
He puesto "Required-Start:    fluidsynth" sin $ en el script de fsynthserv porque fluidsynth es un servicio que está en /etc/init.d y NO un servicio
virtual del sistema como $time o $network. MUCHO cuidado con poner la $ cuando no hace falta, porque NO FUNCIONARÁ.


*************Entendiendo ALSA*******************************************************************************************

Esto es una idea un poco general, ya que no entiendo del todo como va el asunto, pero sirve como una explicación superficial. Tampoco esperes 
entenderlo bien.

Centrándonos en la estructura de ~/.asoundrc (o /etc/asound.conf, siendo ambos ficheros leídos desde /usr/share/alsa/alsa.conf en la Rpi y ninguno de ellos
ignorado), podemos entender bastantes cosas de cómo funciona este sistema.

Todo está basado en plugins. Los plugins tienen definidos nombres o aliases en los ficheros de /usr/share/alsa o en la librería, y usando !<alias> podemos
redefinir el valor que corresponde a un alias.

Las aplicaciones suelen usar el plugin "default", con lo que bastaría redefinir su valor para que usaran una u otra cosa en realidad. SE SUPONE que si no
configuramos nada, el valor del plugin default debería ser "hw:0,0", o sea, la primera tarjeta, primer dispositivo.

Así, por ejemplo, imagínate que quieres que el plugin "default" sea un enchufe que mande el audio NO directamente al hardware sino a la entrada de
otro plugin que sería el dmixer, y que a su vez ya se encangará de enviar el audio donde esté definido que lo mande.
Pues haríamos esto:

pcm.!default {                          //Redefinimos el plugin default
	type plug                           //Decimos que es de tipo plug, o sea que mandará el sonido a otro sitio
	slave.pcm "dmix:0,0"   //Y concretamente lo mandará a un slave, cuyo valor será dmix:0,0, o sea dmix que mandará el sonido tras resamplearlo y mezclarlo
                                                       //a través de la primera tarjeta, primer dispositivo.
}

Y si quisiésemos redefinir el plugin "default" de tal manera que al usarlo una aplicación se estuviese enviando el sonido directamente al hardware,
concretamente a la primera tarjeta, primer dispositivo, haríamos:

pcm.!default {				//Redefinimos el plugin default
	type hw				//Decimos que no es un enchufe como antes, sino directamente acceso hardware  		
	card 0					//El hardware al que accede es primera tarjeta,
	device 0				//primer dispositivo.
}

También es posible que nosotros definamos nuestro propio plugin, y luego lo usemos. Por ejemplo, nos a inventar un plugin llamado "mymixer"
que en realidad enviará el sonido a través de dmix pero nos sirve de ejemplo. Como el tipo de plugin "dmix" ya está definido, será el tipo que tenga.
Redefiniremos default de tal modo que envíe el sonido a través de ese nuevo plugin.

pcm.!mymixer {
	type dmix
	slave {
		pcm "hw:1,0"
		period_size 512
		buffer_size 4096
		rate 48000
	}
}

pcm.!default {
	type plug
	slave.pcm mymixer
}

Si usamos dmixer y queremos cambiar la frecuencia de muestreo de salida para que coincida con la más común de entrada, editamos
/usr/share/alsa/alsa.conf y cambiamos "defaults.pcm.dmix.rate 48000" a 44100.

*************Grabar audio (grabar sonido) de ALSA, sin usar PULSEAUDIO PARA NADA*************************************************

En la mayoría de los sitios se dice que es imposible, porque el audio de ALSA es enviado a la salida y se pierde, al no pasar por ningún sitio en medio donde sea copiado.
Pero es posible lograrlo, usando simplemente arecord. Y es MUY MUY fácil.

Lo primero es entender que podemos ver los dispositivos de los que podemos grabar con arecord así:
arecord -l
Y vemos:
card 0: PCH [HDA Intel PCH], device 0: ALC269VC Analog [ALC269VC Analog]
card 1: Camera [USB 2.0 PC Camera], device 0: USB Audio [USB Audio]

Así de entrada no tenemos ningún dispositivo que nos sirva, así que lo primero insertamos este módulo:
sudo modprobe snd-aloop

Ahora volvemos a mirar con
arecord -l
Y vemos que tenemos:
card 0: PCH [HDA Intel PCH], device 0: ALC269VC Analog [ALC269VC Analog]
card 1: Camera [USB 2.0 PC Camera], device 0: USB Audio [USB Audio]
card 2: Loopback [Loopback], device 0: Loopback PCM [Loopback PCM]
card 2: Loopback [Loopback], device 1: Loopback PCM [Loopback PCM]

Los dispositivos loopback son los que nos interesan.
El que me funciona es el:
card 2: Loopback [Loopback], device 1: Loopback PCM [Loopback PCM]

Así que grabamos de la tarjeta 2 dispositivo 2 con:
arecord -f CD -r 44100 --device="hw:2,1" grabación.wav

Podría ser necesario usar otro dispositivo de loopback en otras tarjetas distintas, claro.

*************GEMRB : Engine para Baldur's Gate 1 & 2*******************************************************************************

Dependencias previas:

-sudo apt-get install libpython-dev --no-install-recommends

-HAY que tener instalado OpenAL, porque aunque tiene soporte para SDL2 sin OpenAL, faltan los sonidos ambientales si usas SDL2.
Cuando acabes de compilar e instalar OpenAL, haz:
sudo rm /etc/ld.so.cache
sudo ldconfig
...O el plugin de audio no podrá ser cargado.

Cambia en gemrb/plugins/SDLVideo/SDL20Video.cpp:
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
por
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Hay que leer el INSTALL para saber cómo se compila, pero esencialmente:

cmake .. -DCMAKE_BUILD_TYPE=Release -DSDL_BACKEND=SDL2 -DOPENGL_BACKEND=None -DDISABLE_WERROR=1 -DUSE_SDLMIXER=0 -DUSE_OPENAL=1 -DUSE_LIBVLC=0 -DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

make -j4

El renderer OpenGL es experimental, no se está desarrollando y NO APORTA NADA. No te molestes en usarlo por ahora.

Instalar con sudo make install, el uninstall funciona bien. NO INTENTES JUGAR INSTALÁNDOLO A MANO, ES UN LIOTE Y NO MERECE LA PENA, INSTALA EL ENGINE SIN MIEDO, QUE SE DESISTALA SIN PROBLEMAS.

Ahora te creas un directorio, por ejemplo ~/baldurs, y dentro creas bg2_data, que es donde meterás el baldurs 2 instalado tal cual.
Ahora te copias el cfg de ejemplo, que viene en build/gemrb, a ~/baldurs también, lo editas y le pasas la ruta del baldurs 2 instalado, relativa a ~/baldurs.
También tienes que descomentar las líneas del .cfg:
GUIScriptsPath=/usr/local/share/gemrb
PluginsPath=/usr/local/lib/gemrb/plugins
GemRBOverridePath=/usr/local/share/gemrb
GemRBUnhardcodedPath=/usr/local/share/gemrb
...O habrá muchas cosas que no encuentre y NO DEBES copiarlas a mano ni nada, las tiene que encontrar.

Le puedes pasar el cfg con -c, en plan gemrb -c game.cfg

Por ejemplo, dejaríamos el path de los datos del BG2 como:
GamePath=./bg2_data
Ahí puedes poner fullscreen a 1 también si quieres.

Las ediciones que necesitas de GOG son las COMPLETE (Baldurs Gate Original Saga que es el Baldurs 1, Baldurs Gate 2 Complete que es el 2), NO LAS ENHANCED. Las ENHANCED NO SIRVEN.

Si no se te oye mira a ver qué plugin está cargando. Si está cargando NullSound comprueba que tienes SDLAudio.so en la ruta de los plugins.

PARA CUSTOMIZAR LAS FUENTES (vamos a verlo con el Baldur's Gate 1 como ejemplo)
1- Copia un fichero de configuración de fuentes al directorio de overrides del juego, así:
cp /usr/local/share/gemrb/unhardcoded/bg1/fonts.2da /usr/local/share/gemrb/override/bg1/
2- Copia una fuente .TTF a /usr/local/share/gemrb/override/bg1/
2- Edita el fichero de configuración de fuentes:
vim /usr/local/share/gemrb/override/bg1/fonts.2da
...Y en la columna FONT_NAME pones el nombre SIN EXTENSIÓN del .TTF que quieras usar.
PARA más información sobre la customización de fuentes, mira en:
https://gemrb.org/Fonts.html
LA MEJOR FUENTE es SHERWOOD.TTF, que es la que usa el juego pero en TTF.

PARA USAR LA RESOLUCIÓN QUE QUERAMOS tenemos que aplicar el parche widescreen, que lo puedes bajar de aquí:
https://www.gibberlings3.net/mods/tools/widescreen/
Lo primero, nos bajamos el parcheador "weidu" desde aquí:
http://www.weidu.org/~thebigg
Extraes los ejecutables weidu, weinstall y tolower, y los mandas a /usr/local/bin
Ahora extraes el parche de widescreen, y el directorio "widescreen" con todo dentro lo metes tal cual en el directorio donde tengas instalado el juego que quieres parchear.
Ahora haces "weinstall widescreen" en el directorio del juego (recuerda que a parte de los datos del juego tendrás el directorio "widescreen" ahí metido, NO sus contenidos sino el directorio en sí con todo dentro) y vas respondiendo a las preguntas.
Para X Coordinate e Y Coordinate, usa 854x480. Para el tamaño máximo del juego, usa 1920x1080. Habilita lo de las múltiples resoluciones.

*************Compilar MAME con sólo un driver concreto**************************************************************************

  ##################################################################################################################
  #  OJO!!! MAME es ahora incompilable de lo grande que es. NI LO INTENTES, es BASURA y ni con 4GB de RAM compila. #
  ##################################################################################################################

Clonamos su repo:
git clone -b mame0239 --depth 1 https://github.com/mamedev/mame.git mame0239

Un hilo sobre el asunto con la solución para compilar sólo un driver:
http://forum.arcadecontrols.com/index.php?topic=162794.0

This is actually spelled out in the mame documentation:

https://docs.mamedev.org/initialsetup/compilingmame.html

Quote:

    You can do driver specific builds by using SOURCES=<driver> in your make statement. For instance, building Pac-Man by itself would be:
    "make SOURCES=src/mame/drivers/pacman.cpp REGENIE=1"
    including the necessary REGENIE for rebuilding the settings

*************Compilar openadventure*********************************************************************************************

Instalar cosas:
sudo apt-get install libedit-dev pyhton-yaml
editar el makefile para añadir los cflags. Compilar y listo.

*************Core Cannonball (OutRun engine) en la Rpi*****************************************************************************************

Necesitamos un directorio /roms donde metemos las roms del juego (es el romset del MAME y si te falta una eprom, es del SET B)
donde metemos también el directorio /res que viene con los sources.
Es decir, /res quedaría como /roms/res.
En /roms, creamos un archivo vacío llamado outrun.game, y lanzaríamos el core como:
retroarch -L ~/.config/retroarch/cores/cannonball-libretro.so roms/outrun.game

*************Compilar Cannonball (OutRun engine) versión SDL2 en Rpi***************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/djyt/cannonball.git

Necesitamos libboost, eso lo primero. Concretamente, te vale con libboost-dev
sudo apt-get -y install libboost-dev --no-install-recommends
AL ACABAR DE COMPILAR, PUEDES DESINSTALAR LIBBOOST:
sudo apt-get -y purge libboost-dev && sudo apt-get -y autoremove && sudo apt-get -y clean

mkdir build
cd build
cmake ../cmake -DTARGET=pi4-opengles.cmake -DCMAKE_BUILD_TYPE=Release

-Copiamos el ejecutable "cannonball" a ~/outrun
-Creamos el directorio ~/outrun/roms y metemos ahí las ROMs del OutRun de MAME descomprimidas.
(Si te falta una eprom, es del SET B)
-Copiamos el directorio "res" que viene con los sources a ~/outrun/res
-Movemos res/config.xml a ~/outrun (es decir, lo sacamos de ~/outrun/res y lo movemos a ~/outrun, para que el ejecutable lo encuentre).
-Editamos config.xml a nuestro gusto.
-Hacemos un "touch hiscores.xml" para que no se queje de que no existe.
-La música custom va en wav, en ~/outrun/res, y sólo tienes que activarla en el config.xml

Si al ejecutarlo te sale que no encuentra las SDL, mira con un ldd sobre el ejecutable, y si efectivamente no las encuentra, es que las has instalado
en una ruta que no está en los path que usa el sistema para buscar libs en tiempo de ejecución.
Así que ejecuta sudo lddconfig -v y echa un vistazo. Mírate la parte de los apuntes de SDL1.2.x

Si te da un segfault al salir, quita la llamada a renderer->disable() de Video::~Video() en src/main/video.cpp, ya que no pinta nada en un destructor... Y pon esa llamada a renderer->disable() en quit_func(), que está en src/main/main.cpp

Si no quieres que ande bajando el volúmen de los WAVs, usa los que tienes que ya tienen el volúmen bajado, y vete a Audio::load_wav en
src/main/sdl2/audio.cpp y deja entre el LockAudio y el UnlockAudio sólo esto:

SDL_LockAudio();

	wavfile.data = (int16_t*) data;
	wavfile.length = length / 2;
	wavfile.pos = 0;
	wavfile.loaded = 2;

	resume_audio();

SDL_UnlockAudio();

============CLONAR UN REPOSITORIO DE GITHUB USANDO EL NUEVO Y ASQUEROSO SISTEMA DE PERSONAL ACCESS TOKENS (PAT)===============

git clone --depth 1 https://<TOKEN_DE_MIERDA>@github.com/vanfanel/ppsspp.git

Así ya no necesitamos meter username, ni contraseña, ni nada, al hacer updates.

============ACTUALIZAR UN REPOSITORIO DE GITHUB USANDO EL NUEVO Y ASQUEROSO SISTEMA DE PERSONAL ACCESS TOKENS (PAT)===============

-Creamos un token nuevo. Para ello, nos vamos a la foto de perfil de github (arriba a la derecha),
settings -> developer settings -> personal access tokens
y generamos el token de los cojones. Es una cadena de caracteres de mierda. La copiamos y la guardamos.
NO LA USES COMO PASSWORD, TE DEJA HACERLO UNA VEZ Y LUEGO YA NO VALE Y TIENES QUE GENEARAR OTRA.

-Nos metemos en el reposiorio que queremos actualizar y hacemos:
git remote remove origin

-Ahora le metemos un origin nuevo que incluya nuestro token, así:
git remote add origin https://vanfanel:<TOKEN_DE_MIERDA>@github.com/vanfanel/LBE_DOCS.git

-Ahora ya podemos actualizar con git push las veces que quieras desde tu copia local ese repo.

************Actualizar repositorio github****************************************************************************************

Lo primero es poner la fecha: el formato es

sudo date mes|día|hora|minuto

Actualizamos en la copia local así:

git add .
git commit -m "made some changes"

Y ahora subimos los cambios:

git remote add origin git@github.com:yourusername/yourreponame.git
git push origin master

la primera línea sólo es necesaria si es la primera vez que voy a subir algo (??)
De todos modos, en ~/.gitconfig tengo:

[user]
          name  = vanfanel
          email = redwindwanderer@gmail.com

y sólo me pide el nombre de usuario (vanfanel) y el password (Manuel22) al hacer el push, y va sin problemas.

GIT REWIND
Si queremos modificar cosas de n proyecto de alguien, hacemos un fork a mi git de ese proyecto, clonamos mi fork en local,
y luego publicamos los cambios en mi fork y hacemos un Pull Request.
Si metemos la pata y queremos dejar mi fork como cuando lo creé, hacemos
git reset HEAD^ --hard
git push -f origin master

************Deshacer un commit que hemos hecho mal*****************************************************************************

Para deshacernos del último commit, suponiendo que no hemos hecho aún un push, sencillamente:
git reset --soft HEAD~ 

************Deshacer un push que hemos hecho mal********************************************************************************

Nos vamos al branch donde queremos corregir el push:
git checkout master

Lo ponemos en el último commit bueno:
git reset --hard cc4b63bebb6

Hacemos un push forzado:
git push -f origin master

Y listo. Ya hemos vuelto en local y en el server al último commit/push bueno.

************Actualizar MI FORK con los cambios del repo original del proyecto (upstream)*********************************************

Lo primero añadimos un remote que vamos a llamar upstream como podríamos llamarlo pepito, pero para entendernos:

git remote add upstream https://github.com/libsdl-org/SDL.git

Ahora descargamos todos los branches de upstream:

git fetch upstream

Nos aseguramos de estar en el branch master de nuestro fork. Seguramente ya estaremos ahí de todos modos..

git checkout main
(si falla, cambia main por master, pero se tiende a que todo sea main)

Hacemos que nuestro fork pase a tener todo lo de upstream: lo convertimos en una copia limpia de upstream, vamos.

git reset --hard upstream/main
(lo mismo: si falla, cambia main por master)

Hacemos un push forzado a mi repo para que efectivamente quede como el upstream:

git push -f origin main
(lo mismo: si falla, cambia main por master)

Hacemos los cambios que tengamos que hacer....

<edit files...>

Hacemos commit de los cambios

git add .
git commit -m "blah blah blah"

Hacemos un push forzado a nuestro fork:

git push -f origin main
(lo mismo: si falla, cambia main por master)


Y luego ya haríamos el pull request.

************RECUPERAR PARTIDAS EN EL GABRIEL KNIGHT DE SCUMMVM**********************************************************************************

A los datos del juego les falta el archivo
VERSION
Con el contenido
01.100.000

Sin este archivo, podrás salvar pero luego no te deja recuperar la partida porque dice que es de otra versión. Así que lo creamos a mano y listo.

************Otro caso práctico de git: actualizar mi master branch al master de upstream, luego ponerme en otro branch y merger mi branch master actualizado en el branch secundario*********

O sea, el objetivo es actualizar mi branch secundario de manera que quede con los cambios del branch master de upstream. Mi branch secundario es dispmanx.

-Añado el upstream. Lo llamo upstream como lo podría llamar pepito:

git remote add upstream https://github.com/scummvm/scummvm.git

Ahora descargamos todos los branches de upstream:

git fetch upstream

Nos aseguramos de estar en el branch master de nuestro fork. Seguramente ya estaremos ahí de todos modos..

git checkout master
o si dice que no encuentra el archivo:
git checkout origin/master

Ahora hacemos el merge del master de upstream con nuestro master:

git merge upstream/master

Ahora nos ponemos en el branch que realmente queremos actualizar:

git checkout dispmanx

...Y hacemos el merge de nuestro branch master sobre nuestro branch dispmanx:

git merge master

Ahora ya haríamos el push al branch dispmanx:

git push origin dispmanx

...Y quedaría probar a compilar y ver qué desaguisados se han montado debido al merge!

************Arreglar texto de commits en github************************************************************************************

Nos ponemos en el branch donde están los commits que queremos cambiar:

Hacemos lo que se llama un rebase interactivo, que nos sacará un editor para cambiar el texto de los commits.

git rebase -i origin/HEAD
(o bien git rebase -i origin/HEAD~3 si quisiéramos incluir los 3 commits anteriores por debajo de HEAD, o sea, commits que ya no son de mi fork sino que ya venían. Con HEAD sin más
debería valernos)

Cambiamos pick por reword en cada mensage que queramos cambiar, pero NO los cambiamos aún.

Cerramos el editor, y nos saltará una edición por cada commit que hayamos marcado con reword. Cambiamos, ahora si, el texto de cada uno.

Hacemos un push forzado:

git push --force origin/dispmanx

https://help.github.com/articles/changing-a-commit-message/

************Probar un pull request (PR) que no ha sido mergido en mainline aún******************************************************

git fetch origin pull/213/head:pr-213
git checkout pr-213

...donde 213 es el número de PR, obviamente.

************Renombrar ficheros del directorio actual de mayúsculas a minúsculas*****************************************************

for SRC in `find ./ -depth`
do
    DST=`dirname "${SRC}"`/`basename "${SRC}" | tr '[A-Z]' '[a-z]'`
    if [ "${SRC}" != "${DST}" ]
    then
        [ ! -e "${DST}" ] && mv -T "${SRC}" "${DST}" || echo "${SRC} was not renamed"
    fi
done

*************MiniVMAC en la Raspberry Pi******************************************************************************************

Para compilar la versión más o menos ideal que usa mi backend de Dispmanx, he usado las siguientes opciones:

-t larm -api sdl -var-fullscreen 0 -fullscreen 1 -speed 1

Para SDL2:

-t larm -api sd2 -var-fullscreen 0 -fullscreen 1 -speed 1

luego he editado src/MYOSGLUE.c y he cambiado el bpp de SetVideoMode() de 8 a 16.
Para la velocidad original del Macintosh plus, tendrías que poner "-speed z"

Compilar con los flags en el makefile así:
mk_COptions = -c -Wall -Wmissing-prototypes -Wno-uninitialized -Wundef -Wstrict-prototypes -O2 -marm -mfpu=vfp -mfloat -abi=hard -march=armv6j

Para hacerte un HFV con juegos y programas, bájate los system disks de la 6.0.8 de aquí:
http://www.gryphel.com/c/sw/system/sys60/index.html
Sigue este tutorial de aquí (tienes que extraer los .data antes de conseguir "System Startup" y "System Additions", usando stuffit para Linux):
http://www.emaculation.com/forum/viewtopic.php?t=6801&mobile=on
El Stuffit para Linux es una versión vieja precompilada para i386 pero nos vale:
http://web.archive.org/web/20060205025441/http://www.stuffit.com/downloads/files/stuffit520.611linux-i386.tar.gz

Luego BORRA por completo el disco del Dark Castle, que es como formatearlo. Para ello arranca el MiniVMac con ambos discos de instalación metidos,
para lo cual le pasas ambos como parámetro, y el disco duro:

./minivmac DC.hfv System\ Startup System\ Additions

Instalas el system 6.0.8 en el disco recién formateado, luego copias el Dark Castle y el Beyond DC, metes los juegos que quieras y listo.
Pero vamos, lo mejor es que no pierdas la imágen HFV...

************MiniVMAC en X86*****************************************************************************************************

Para generar el tar con los sources para Linux X64 paso estas opciones:
-t lx64 -api sdl

*************Cómo usar pkg-config y dpkg******************************************************************************************

Estas herramientas hacen cosas distintas, pero pueden llegar a ser complementarias.
pkg-config se usa mucho en los scripts de configuración, para obtener los flags y localizaciones de librerías necesarias para compilar un 
programa contra una librería determinada. Así, por ejemplo, para compilar un programa que va a usar glib2.0, tendremos que saber contra que librerías 
por nombre vamos a linkarlo y qué rutas para includes hay que pasarle (parámetros -l<nombre_librería> y -I<ruta_includes>, recuerda, está explicado más abajo.)  

Por ejemplo, si hacemos: 
manuel@vader:~$ pkg-config --libs glib-2.0
-lglib-2.0  
manuel@vader:~$ pkg-config --cflags glib-2.0
-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include  

pk-config usa los archivos .pc que instalan los paquetes de programas al ser instalados con dpkg (o indirectamente con apt-get, que a su vez usa dpkg). 
El nombre que tenemos que pasarle a pkg-config es sin prefijo lib, pero por si acaso, puedes mirar el nombre del .pc del paquete en cuestión.
Podemos ver mediante locate que tenemos .pc en: 
/usr/lib/pkgconfig/
/usr/share/pkgconfig/
/usr/lib/x86_64-linux-gnu/pkgconfig/
Se supone que la variable de entorno $PKG_CONFIG_PATH tiene estas rutas pero yo no lo veo, así que mirando estos directorios y tirando de locate
es como he sacado el nombre exacto que hay que pasarle a pkg-config.
Al no encontrar el configure el resultado de pkg-config, lo que se nos sugiere es exportar la información de "pkg-config --cflags glib-2.0" y de
"pkg-config --libs glib-2.0" a variables de entorno que el script leerá, $GLIB_CFLAGS y $GLIB_LIBS. Es fácil saber qué ponemos a cada variable:
GLIB_CFLAGS="-I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include"
GLIB_LIBS="-lglib-2.0"

Para saber qué paquetes tenemos instalados, por ejemplo cuando queramos hacer limpieza, hacemos "dpkg -l" que se puede combinar con grep
para buscar unas y otras cosas.

MUY IMPORTANTE: podemos localizar en qué paquete está un fichero, de manera que podemos eliminar el pquete en cuestión. Se hace con
"dpkg -S stdio.h" o con "dpkg -S /usr/include/stdio.h".

*************Cómo hacer que el directorio actual siempre esté en el PATH, para no tener que escribir ./archivo *******************

Edita /etc/profile y deja la línea
export PATH
como
export PATH=$PATH:.

*************Obtener información sobre los paquetes*******************************************************************************

Para conocer la versión, developer, maintainer. etc, de un paquete antes de instalarlo (o instalado), podemos hacer "apt-cache show <nombre_paquete>",
donde nombre_paquete puede ser una parte del mismo. Es muy útil si tenemos varias versiones del mismo paquete (con distinto maintainer, una libre
y la otra no, distintas versiones...) y queremos saber cuál instalar.
 
*************Extraer archivos .sit de mac en Linux***********************************************************************************

te bajas esta cosa : http://web.archive.org/web/20060205025441/http://www.stuffit.com/downloads/files/stuffit520.611linux-i386.tar.gz
y con unstuff lo haces.

*************Los parámetros y flags de GCC y del linker******************************************************************************
Cuando falle una compilación (porque no se encuentra un fichero de cabecera en un include o porque no se encuentra algo que debería estar
definido en un fichero que cabecera que no se ha incluído)

-l<nombre_librería> : Indica contra qué librería se va a linkar por el nombre de librería, sin el prefijo lib: por ejemplo, -lmath, -lSDL... Los nobres
los puedes sacar con un simple ls a /usr/lib o a donde esté la librería. Si no está en /usr/lib, acuérdate de darle la ruta de sus includes y de sus
binarios, parámetros que se explican a continuación.

-I<directorio> : Es una i latina mayúscula. añade el directorio a los paths de búsqueda de los includes para el compilador. A partir de ese momento, ya podemos usar rutas
relativas para hacer includes de los ficheros de cabecera de ese directorio, en plan #include <GLES/gl.h> en lugar de tener que hacer 
#include "/opt/vc/include/GLES/gl.h". Como lo normal es que los programas vengan con includes con rutas relativas, esto suele ser necesario.

-L<directorio> : añade el directorio a los de búsquera de librerías dinámicas del linker, o sea que es un parámetro para el linker. Por ejemplo, para
linkar cualquier programa que use las SDL2, lo que se hace es usar sdl2-config para obtener en qué directorios buscan las SDL2 las librerías que 
usan sus backends: en el caso de la Raspberry Pi, si compilas un programa que use las SDL2, las SDL2 a su vez usan librerías que están en /opt/vc/lib, 
por lo que de un modo u otro, al programa que intentas compilar hay que pasarle la ruta de esas librerías para que las encuentre en tiempo de
linkado. Así que si dicho programa no usa sdl2-config a la hora de configurar el linker, le tienes que pasar la ruta de las librerías nativas de la Rpi a mano.
Sin ser tan extremos, cualquier programa que use unas librerías dinámicas contra las que se vaya a linkar que no estén en /usr/lib, necesita este 
parámetro para encontrarlas. 

-D<nombre macro>: define (o sea, activa) una macro del preprocesador. Si por ejemplo hacemos en un programa:
#ifdef DEBUG
	fprintf (fp, "...");
#else
	....
#endif
y luego hacemos "gcc -DDEBUG", estaremos activando esa macro en compilación y se hará en fprintf.

-rpath=<path> (O lo que es lo mismo, -Wl,-rpath,<ruta>    , la explicación de esto es que -Wl nos permite pasar una serie de parámetros y sus valores, separados
por comas).
Esto sirve para pasar la ruta de manera que el ejecutable resultante busque una librería en esa ruta en tiempo de ejecución (que es DISTINTO al tiempo de
linkado: o sea que UN PROGRAMA PUEDE ENCONTRAR UNA LIBRERÍA EN TIEMPO DE EJECUCIÓN PERO NO ENCONTRARLA EN TIEMPO DE LINKADO,
O VICEVERSA!)
A veces nos encontraremos con ejecutables que podemos linkar bien contra librerías que luego no encuentrar en tiempo de ejecución.
LO PRIMERO es hacer un ldd al ejecutable y confirmar que dicha librería aparece como NOT FOUND.
Esto es porque, aunque le pases con -L<ruta> la librería que quieres que encuentre en linkado, para que la encuentre en tiempo de ejecución necesitarías
pasarle "-Wl,-rpath,<ruta>".
Aunque lo normal es que no tengas que hacer esto tampoco, sino que la librería esté en una ubicación donde el sistema busque por defecto.
Para asegurarnos de esto, hacemos "ldconfig --verbose", y se actualizarán los directorios donde se buscan las librerias que usan los programas.
Así que si has instalado una librería pero no la encuentra un programa en tiempo de ejecuciçon, puedes pasarle el -rpath o hacer un ldconfig y listo.


*************DISTCC se cuelga en el cliente (Rpi) en el punto en que va a reintentar una compilación localmente y no da el error***********

-En el servidor, inicia el servidor distcc como: 
sudo /etc/init.d/distcc start --verbose
-En el cliente, si es la Rpi, no te olvides de ponerle un swap con
sudo swapon /dev/sda1


*************Qué librerías usa un ejecutable****************************************************************************************

ldd <nombre_del_ejecutable>

*************Vanilla-Conquer: Command and Conquer en la Raspberry Pi**************************************************************

Notas previas:
-El C&C original se llama "tiberian dawn". Así que el ejecutable es vanillatd, mientras que vanillara es para el RED ALERT.
-El juego usa OpenAL, busca las instrucciones para instalarlo antes.

Clonamos el repo con:
git clone --depth 1 https://github.com/TheAssemblyArmada/Vanilla-Conquer.git

Editamos common/video_sdl2.cpp y en SDL_CreateRenderer() añadimos el flag SDL_RENDERER_PRESENTVSYNC.

Creamos un directorio de compilación y entramos:
mkdir b4
cd b4

Configuramos y compilamos con:
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
make -j4

Creamos el directorio ~/cc, y metemos ahí los datos del juego.

Copiamos el ejecutable (vanillatd para el C&C original, o vanillara para el RED ALERT) al directorio del juego, y listo!

La primera vez que ejecutemos vanillatd o vanillara, se nos creará .config/vanilla-conquer/[vanillatd|vanillara]/conquer.ini
Editamos ese conquer.ini y ponemos Scaler a nearest, etc.
Queda pendiente que se incorpore un commit que permite ajustar el aspect ratio a 4:3.

*************SONIC CD Y SONIC 1/2 NATIVOS en la Raspberry Pi***********************************************************************************

Instalamos unas dependencias previas...

sudo apt install libvorbis-dev libogg-dev libtheora-dev

--COMPILANDO EL SONIC CD--

Clonamos su repo:
git clone --recursive --depth 1 https://github.com/Rubberduckycooly/Sonic-CD-11-Decompilation.git

Editamos RSDKv3/RetroEngine.hpp, y comentamos todos los defines de:
#define RETRO_USING_MOUSE
#define RETRO_USING_TOUCH

Editamos RSDKv3/Drawing.cpp, y añadimos SDL_ShowCursor(false) justo antes de la llamada a SDL_CreateWindow().

Editamos RSDKv3/Audio.cpp y ahí cambiamos:
	#define AUDIO_SAMPLES   (0x800)
	por
	#define AUDIO_SAMPLES   (0x200)

Compilamos con:
CXXFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -DGLEW_NO_GLU" make -j4

El ejecutable queda en bin/RSDKv3

--COMPILANDO SONIC-1-2-2013--

Clonamos su repo:
git clone --recursive --depth 1 https://github.com/Rubberduckycooly/Sonic-1-2-2013-Decompilation.git

Clonamos stb, que es una dependencia que NO soporta pkg-config y por eso tenemos que dársela a mano:
cd dependencies/all
git clone --depth 1 https://github.com/nothings/stb.git stb-image

Editamos RSDKv4/Audio.cpp y ahí:
	-Cambiamos spec.samples a 512.
	
Editamos RSDKv4/RetroEngine.hpp y comentamos la línea:
	#define RETRO_USE_NETWORKING (!RETRO_USE_ORIGINAL_CODE && 1)
	
Compilamos con:
CXXFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -DGLEW_NO_GLU" make -j4

El ejecutable queda en bin/RSDKv4

Ahora, para ejecutarlo, necesitamos Data.rsdk (preferiblemente de la versión de PC).
En el caso de Sonic CD, la versión de PC tiene un pequeño error en la pantalla del título, que se soluciona poniendo
screenWidth a 400 en settings.ini. La versión de Steam es la de PC, así que también tiene este error.
Pensarás que la versión de Android entonces es mejor, pero NO: aunque no tenga este errorcillo, tiene controles en pantalla
y nag-screens, no deja salir pulsando ninguna tecla o botón, etc... Así que USA LA DE PC Y OLVÍDATE DE BUSCAR OTRAS VERSIONES. 
El directorio "videos" contendrá los vídeos en .ogv. Por ahora, los vídeos tienen que empezar por mayúscula la primera letra
para que el engine los detecte. Así, opening.ogv debe ser Opening.ogv, y good_ending.ogv debe ser Good_Ending.ogv, etc.
Tienes todo preparado en el disco duro de backup.

Edita settings.ini y pon VSync y Fullscreen a true, y "UseHQModes" a false.
Si los colores ROJO y AZUL se ven invertidos en los vídeos, desactiva "EnhancedScaling" en settings.ini

*************HYDRA CASTLE LABYRINTH EN LA PI**************************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/ptitSeb/hydracastlelabyrinth.git

Editamos src/sdl2/graphics.c y:
-En la llamada a SDL_CreateRenderer(), añadimos SDL_RENDERER_PRESENTVSYNC
-Antes de eso, añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-En PHL_EndDrawing(), quitamos la sección de "implement some crude frameskipping...", y el while con el SDL_Delay() al final.

Editamos src/sdl2/audio.c y:
-Cambiamos el 4096 en Mix_OpenAudio() por 1024.

Compilamos con:
mkdir b4
cd b4
cmake -DUSE_SDL2=ON -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
make -j4

Copiamos el directorio data que viene con los sources al mismo directorio donde metamos el ejecutable.

Para que se ejecute en modo fullscreen, sin cambiar resolución, sin escalado XBRZ y con escalado 1x, ejecutamos con:
./hcl -f -d -x1 --no-xbrz


*************CELESTE nativo en la Raspberry Pi***************

Clonamos su repo:
git clone --depth 1 https://github.com/lemon32767/ccleste.git

Editamos el Makefile, y en la línea de las CFLAGS quitamos el -g y ponemos los flags de la Pi4, que son:
-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Editamos sdl12main.c y allí:
-Comentamos toda la sección donde aparece SDL_Delay(), todo el bloque de principio a fin.

Editamos sdl20compat.inc.c y allí:
-En SDL_Flip(), duplicamos el bloque:
  SDL_RenderClear(sdl2_rendr);
  SDL_RenderCopy(sdl2_rendr, sdl2_screen_tex, NULL, NULL);
  SDL_RenderPresent(sdl2_rendr);
(Para que el juego vaya a 30FPS pero sincronizados con el VSYNC).
-Añadimos como único flag SDL_WINDOW_FULLSCREEN_DESKTOP a SDL_CreateWindow(), quitamos cualquier otro que haya.
-Añadimos antes de la llamada a SDL_CreateRenderer(): SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
-Añadimos estos flags a SDL_CreateRenderer(): SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC

Compilamos, y copiamos el ejecutable a ~/celeste/
Copiamos también el directorio "data" que viene con los sources a ~/celeste/

Lo lanzamos con:
CCLESTE_START_FULLSCREEN=1 ./ccleste

Se sale con la tecla DELETE

*************MightyMike en la Raspberry Pi*********************

git clone --recurse-submodules --depth 1 https://github.com/jorio/MightyMike.git

Editamos src/Heart/Window.c y allí metemos todo el bloque de
SDL_UpdateTexture, SDL_RenderClear, SDL_RenderCopy y SDL_RenderPresent dentro de esta condición:
if (gSDLTexture && gSDLRenderer) { }

Configuramos y compilamos:
mkdir b4
cd b4

cmake .. \
-DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

Copiamos el ejecutable MightyMike y el directorio "Data" que viene con los sources a ~/mightymike

*************Nanosaur en la Raspberry Pi*********************

Clonamos su repo:

git clone --recurse-submodules --depth 1 https://github.com/jorio/Nanosaur.git

Configuramos y compilamos:
mkdir b4
cd b4

cmake .. \
-DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

Copiamos el ejecutable Nanosaur y el directorio "Data" que viene con los sources a ~/nanosaur

*************Commander Genius en la Raspberry Pi*************

Podemos bajarnos una release (lo más recomendado), la última de aquí:

https://gitlab.com/Dringgstein/Commander-Genius/-/tags

O si decidimos clonar el repo, se requieren tres pasos:

git clone --depth 1 https://gitlab.com/Dringgstein/Commander-Genius.git
git submodule init
git submodule update

creamos un directorio de compilación y entramos en él:
mkdir b4
cd b4

Ahora configuramos:

cmake .. -DUSE_OPENGL=0 -DDOWNLOADER=OFF -DUSE_VIRTUALPAD=OFF -DDISABLE_HOVER=ON -DUSE_BOOST=OFF -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

Ya sólo es hacer make -j4 en el directorio de compilación y debería ir.

El resultado queda en src/CGeniusExe

Nos creamos ~/keen
Ahora editamos ~/.CommanderGenius/cgenius.cfg, y dejamos el primer searchpath así:
SearchPath1 = ${HOME}/keen
Ahora, creamos ~/keen/games, y metemos el directorio keen1 (que contrendrá los archivos del keen1) ahí, en ~/keen/games/keen1
Y ya lo tiene que ver el cargador.

Si queremos lanzar un juego directamente sin pasar por el lanzador, es con:
./CGeniusExe dir=games/keen1

Y si quieres tener música en keen1, gráficos mejorados, etc... te vas al directorio hqp que viene con los sources de gitlab,
y copias el directorio hqp/global a ~/keen, y luego lo que hay en hqp/keen1 a ~/keen/games/keen1,
lo que hay en hqp/keen2 a ~/keen/games/keen2, etc...

También puedes editar cgenius.cfg, y poner EnableLogfile=false para que no te genere un log en HTML cada vez que se ejecuta el juego.

*************Doomretro en la Raspberry Pi*************************************************************************************

Bajamos la última stable de https://github.com/bradharding/doomretro/releases

Si queremos que la resolución interna sea 320x200:
Entramos en src, editamos doomdef.h y ponemos SCREENSCALE a 1.

Si por el contrario dejamos que se renderize en alta resolución, pasamos "-nosplash" al ejecutable para que no salga el splash screen,
ya que sólo sale en alta resolución.

Editamos el Makefile y ponemos los CFLAGs "-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer", y quitamos el -g.
Compilar y listo.

En doomretro.cfg, ponemos:
vid_scalefilter a "linear"
gp_thumbsticks 2 si tenemos dos analógicos, y gp_sensivity_horizontal a 32 (la mitad que la vertical, vamos, que si no
es imposible apuntar bien en horizontal).

La música tiene que ir en un WAD (no valen PK3 ni movidas de esas) y tienen que estar los .ogg, los .mp3 o los .flac ahí dentro sin estar en ningún directorio ni nada, con sus extensiones y nombres originales. Y debes haber compilado SDL_Mixer con soporte para ogg o flac, claro.
Vengo usando estas músicas, que ya vienen en WAD y todo listas: https://zandronum.com/forum/viewtopic.php?t=97

Para usar el SIGIL, usa la versión COMPAT del WAD, y créate otro WAD a parte con la música en MP3, OGG o lo que sea, tal como se indica
en el párrafo anterior.

Para el 8Bitdo receiver, los botones son:
bind gamepad4 +fire
bind gamepad3 +use
bind leftshoulder +tun
Cuidado particularmente con no tener ya puesto leftshoulder a alguna otra función!

*************Problemas 8BITDO SN30******************************************************************************************

¡Tienes que encenderlo (START) y emparejarlo (SELECT) cada vez que cambias de modo!
Se cambia de modo apagando el mando (mantener START pulsado), y luego se entra en los diferentes modos al encenderlo:
START+B es el modo Dinput y es el único modo que te interesa. 
Los demás son:

B + START : Dinput mode, for Android devices or PC
X + START : Xinput mode, for PC
Y + START : Switch mode
A + START : MacOS mode, for Apple computers (NOT PHONES/TABLETS)

*************Abbaye des morts************************************************************************************************

Clonamos su repo:
git clone --depth 1 https://github.com/nevat/abbayedesmorts-gpl.git

Editamos src/main.c, y ponemos fullscreen = 1 y grapset = 1, y en Mix_OpenAudio() ponemos el tamaño de buffer a 1024 o 512.

Compilamos con:
make PLATFORM=rpi4_64 -j4

Para hacerlo funcionar, copiamos estos directorios que vienen con los sources al mismo directorio donde metamos el ejecutable:
data graphics screenshots sounds xcf

Puedes asignar el botón en src/base.h
Para usar el 8bitdo SN30, usa JUMP_BUTTON 0.

*************System Shock en la Pi con Shockolate****************************************************************************

Clonamos su repo:

git clone --depth 1 https://github.com/Interrupt/systemshock.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
cd systemshock
mkdir b4
cd b4
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_SDL2=ON -DENABLE_SOUND=ON -DENABLE_FLUIDSYNTH=ON -DOpenGL_GL_PREFERENCE=GLVND ..
make -j4

Ahora creamos ~/sshock y ahí dentro:
Copiamos el directorio shaders que viene con los sources a ~/sshock/shaders
Metemos los datos del juego en ~/sshock/res/data

Ejecutamos con:
./systemshock -nosplash

*************Chocolate DOOM en la Raspberry Pi con SDL2**********************************************************************

Usamos el branch sdl2-branch, que clonamos con:

git clone --depth 1 -b sdl2-branch https://github.com/chocolate-doom/chocolate-doom.git 

Editamos src/i_video.c y cambiamos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest"); 
por 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Ahora editamos configure.ac ponemos el optimization level a 3 y quitamos y el -g que encontremos.
Ahora configuramos con 
CFLAGS="-mfpu=vfp -mfloat-abi=hard -march=armv6j" CXXFLAGS="-mfpu=vfp -mfloat-abi=hard -march=armv6j" ./configure
NO LE PASES el -O2 al script de configuración: ya lo has puesto en el configure.ac.

Compilamos con
make -j8 V=1
Verificamos que no hay -g, que se compila con -O2 y que los flags de cpu son correctos.
Listo!

NOTA: La opción de configuración de los gráficos en chocolate-setup peta. Da igual.

**************SWAP de emergencia*************************************************************************************************
Algunos sistemas, como la Raspberry Pi, no usan swap normalmente porque nos cargaríamos la SD rápido.
Así que, si necesitamos un swap de emergencia para algo concreto, como compilar o linkar un programa grande que por razones de falta de 
RAM no se puede compilar en la Pi ni con distcc (esto suele pasar con el linkado, que siempre se hace de manera local), lo mejor es usar un swap
de emergencia en un disco duro mecánico, conectado por USB. Es tan simple como esto:

mkswap /dev/sdx
swapon /dev/sdx

También podemos hacer un archivo de swap si no queremos cargarnos una partición:

dd if=/dev/zero of=/path/to/swapfile bs=1M count=1024 # For 1GB swap file
swapon /path/to/swapfile

Al acabar con el swap, siempre

swapoff <device>

si no queremos colgar el sistema.

Podemos comprobar cómo se usa la swap con "free" mientras se linka.

**************Tyrian en la Raspberry Pi**********************************************************************************************

Clonamos el repo de:

https://github.com/opentyrian/opentyrian.git

Editamos src/nortsong.c y cambiamos la función JE_setTimerInt() y JE_resetTimerInt() y simplemente dejamos esto ambas funciones:
jasondelay = 0;
(Con esto conseguimos que no se espere a ningún timer interno).

Editamos src/video.c, y:
-Repetimos la secuencia de llamadas:
       SDL_RenderClear(main_window_renderer);
       SDL_RenderCopy(main_window_renderer, main_window_texture, NULL, &dst_rect);
       SDL_RenderPresent(main_window_renderer);
(Con esto conseguimos que cada frame se pinte dos veces, con lo que el juego va a la mitad de frames que nuestro modo de vídeo,
así que irá a unos 30FPS suaves que no está mal).
-Añadimos SDL_RENDERER_PRESENTVSYNC a SDL_CreateRenderer()
-Añadimos SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear"); antes de la llamada a SDL_CreateRenderer()

Editamos Makefile y añadimos al lado de -O2 los flags de la Pi4:
-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Compilamos con:
make -j4

Se ejecuta sin más, con los datos del juego original en el mismo directorio que el ejecutable.
Puedes bajar el original de:
https://exodos.the-eye.us/public/eXo/
Los archivos originales de DOS vienen todos en mayúsculas, los puedes pasar a minúsculas con:
sudo rename 'y/A-Z/a-z/' * 

**************Extraer datos de CUALQUIER ejeculable*******************************************************************************

Usa Universal Extractor:
https://github.com/Bioruebe/UniExtract2/releases

Es de Windows, usa WINE.

**************VIM autocompletion**************************************************************************************************

Ya era hora de tener esto pasado a un fichero de texto!

Instalamos exhuberant-ctags, que es el programa que genera paquetes de tags a partir de ficheros de cabecera:

sudo apt-get install exuberant-ctags

Creamos el directorio donde vamos a guardar los paquetes de tags generados a partir de los ficheros de cabecera:

mkdir -p ~/.vim/tags

Nos bajamos el plugin de VIM para autocompletion de aquí:
(si lo cambian de sitio, busca eso, el plugin de VIM para autocompletion)

http://www.vim.org/scripts/script.php?script_id=1520 

Lo mandamos a ~/.vim, y lo descomprimimos ahí con unzip omnicpp*zip. Nos crea directorios y tal, como un mini-sistema vim.

Nos bajamos también las cabeceras de C++ standard de aquí, para poder generar sus tags:

http://www.vim.org/scripts/script.php?script_id=2358 

Las descomprimimos en ~/.vim también, por ejemplo, con tar xvjpf cpp_src.tar.bz2

..y estando en ~/.vim, empezamos a generar los paquetes de tags:

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/INC /usr/include
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/STL cpp_src
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/SDL /usr/include/SDL
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ --sort=1 -f tags/BCM /opt/vc/include   
(Esta de BCM es para la Rpi, dispmanx y tal)

Ahora, dejamos el /etc/vim/vimrc.local de esta guisa:

=====================================================

syntax on

" Para que NO nos transforme 8 espacios en un TAB
set expandtab

set number
set ls=2
set sw=1
set noswapfile

filetype plugin on
set tags+=~/.vim/tags/INC
set tags+=~/.vim/tags/STL
set tags+=~/.vim/tags/SDL
set tags+=~/.vim/tags/BCM

" para que se abra y se cierre automáticamente el menú desplegable de preview e info  
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview

"para regenerar los tags de nuestro proyecto, los que no incluimos de base, con F12 
map <F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<cr><cr>

"para desactivar la autoinserción de comentarios, que es lo que nos jode cuando copiamos código desde el navegador
"Es fundamental que esté colocada esta línea después de la de filetype plugin on,
"porque esa línea activaría de nuevo la autoinserción.
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

colo desert

set encoding=utf-8                     "Estas líneas son para poder poner tildes, eñes y demás. 
setglobal fileencoding=utf-8

" Esto es para que no entremos en modo VISUAL al usar un ratón desde SSH
set mouse-=a

" Esto es para cambiar entre buffers. Hemos usado w porque se puede hacer con una mano la combinación,
" pero se cambia de buffer y no de ventana.
" Es para cuando se tienen dos ficheros abiertos a la vez. La exclamación es para poder cambiar entre buffers sin guardar cambios.
map <C-w> :bnext!<cr>

" tap indent movement 
vmap <Tab> >gv
vmap <S-Tab> <gv

" para que cuando estás en modo visual y mueves el texto con < y >, no se pierda la selección.
vnoremap < <gv
vnoremap > >gv

" Para que VIM no cree ficheros raros si no cerramos un fichero, que son una molestia.
set nobackup       "no backup files
set nowritebackup  "only in case you don't want a backup file while editing
set noswapfile     "no swap files

===========================================================

Y ahora, para que VIM recuerde la última posición en que estábamos cuando abrimos un fichero dado por última vez, editamos /etc/vim/vimrc
y descomentamos esto, que viene comentado por defecto:

" Uncomment the following to have Vim jump to the last position when
" reopening a file
if has("autocmd")
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

Y cambiamos el ownership de ~/.viminfo al usuario, ya que viene como propiedad del root y así no funciona lo que pongas en vimrc.
Y si aún así no funciona, comenta todo lo que has puesto en ~/.vimrc, debería funcionar. Entonces ve descomentando líneas y comprobando qué setting de .vimrc es el que
impide que funcione. Sí, esto me ha pasado.

En DEBIAN como ROOT, edita /usr/share/vim/vim82/defaults.vim y comenta lo del mouse para que no entre en modo visual.

===========================================================

Para que VIM no entre en modo VISUAL cada vez que pinchamos con el ratón, editamos /usr/share/vim/vim82/defaults.vim y
cambiamos
set mouse=a
por
set mouse-=a
(O SIMPLEMENTE BORRAMOS TODA ESA SECCIÓN!!!)

SI NO SABES dónde se está configurando lo del mouse, haz:
:verbose set mouse
y te lo dirá.

**************Traducir en tiempo real la consola desde una codificación distinta de UTF-8 a UTF-8***************************************

Por ejemplo, en este caso nos conectamos por telnet a un servidor que "emite" en ISO-8859-1, y de este modo vemos tildes y todo:

luit -encoding ISO-8859-1 telnet rlmud.org

**************Abrir varias ventanas en VIM y cambiar entre ellas***********************************************************************

Con el comando Sex (ESC, : Sex, Enter) y luego se cambia entre ellas con CTRL+ww
También podemos partir la ventana en dos con CTRL+ws y luego cambiar entre ellas!

**************Convertir archivos de DOS a UNIX**************************************************************************************

Para procesar todo un árbol de directorios quitando esos ridículos ^M de los documentos que generan los tontos que usan Windows:

find ./ -name '*.cpp' | xargs dos2unix

**************VIM con color en la Raspberry Pi****************************************************************************************

Tan simple como crear .vimrc en mi carpeta de usuario y añadir

syntax on
set number

**************Compilar un programa que da errores en la fase de linkado porque no encuentra las librerías********************************

Si da errores de que no encuentra los ficheros de cabecera de las librerías, tendremos que añadir -I<ruta de los  .h que necesita> a los CFLAGS 
y/o a los CXXFLAGS. Esto sería un error de compilación, no un error en el linkado. No te confundas.

Si lo que pasa es no encuentra las liberías en el linkado ("undefined reference"), tendrás que añadir, en teoría, -L<ruta de la librería> a los LDFLAGS.

**************Localizar dónde está instalada una librería******************************************************************************

ldconfig -p

**************Script que procesa varios ficheros, en este caso canciones, y las va reproduciendo******************************************
#!/bin/bash

PLAYER="omxplayer -o hdmi"
PLAYLIST="play.pls"

# Play arguments on command line if they exist
if [ $# -ne 0 ]
then
    for file
    do
        $PLAYER "$file"
    done
    exit
fi

# Play the playlist if it exists
if [ -e "$PLAYLIST" ]
then
    IFS=$'\012'
    for file in $(cat "$PLAYLIST")
    do
        $PLAYER "$file"
    done

# Play the directory structure otherwise
else
    for file in *
    do
       $PLAYER "$file"
    done
fi 


***************Compilar e instalar un programa que usa unas librerías que están instaladas en una ubicación no estándar******************

Para compilar las librerías, habremos hecho:

./configure --prefix=/home/manuel/sidplay
make -j5
make install

...con lo que acabaremos con las librerías en /home/manuel/sidplay/lib

Y para compilar el programa que las usa, en este caso un sid player, lo que le decimos es dónde está el archivo .pc de la librería, NO dónde está
la propia librería:

PKG_CONFIG_PATH=/home/manuel/sidplay/lib/pkgconfig ./configure --prefix /home/manuel/sidplay/

(En este caso concreto, el player se empeña en compilar con PULSEAUDIO, así que alteramos el script "configure", NO el Makefile, ojo, para cambiar a pkg_failed a yes justo antes
de la parte de script que lo comprueba, ya que no hay manera de desactivarlo de otra manera).
Le podríamos anteponer también la variable de entorno LDFLAGS, para decirle al linker dónde están las librerías contra las que tiene que linkad el ejecutable, 
con lo que quedaría:

LDFLAGS+=-L/home/manuel/sidplay PKG_CONFIG_PATH=/home/manuel/sidplay/lib/pkgconfig ./configure --prefix /home/manuel/sidplay

PERO esto es redundante, ya que dentro del fichero .pc de las librerías que compilamos antes, y que le pasamos mediante PKG_CONFIG_PATH, ya
sabe el linker dónde están esas librerías.
No nos sirve LDFLAGS como solución para decirle dónde están las librerías en tiempo de ejecución, ya que LDFLAGS es sólo para indicarlo en
tiempo de compilación. En tiempo de ejecución no nos quedará más remedio que usar LD_LIBRARY_PATH, como siempre, ya que está definido en el 
sistema cuáles son las localizaciones donde pueden estar las librerías, y NO es el ejecutable el que las busca.

Ahora: 

make -j5
Y para ejecutar

LD_LIBRARY_PATH=/home/manuel/sidplay/lib ./sidplayfp <tema>.sid
 

***************Rogue en Linux**************************************************************************

Descarga los últimos sources de
git clone --depth 1https://github.com/gillesdami/rogue.git

Antes de nada, instala las libncurses5-dev, antes de hacer el configure.
sudo apt-get install libncurses5-dev --no-install-recommends

Ahora actualiza el config.guess, que el que trae el rogue es viejo y no detecta bien el sistema:
wget 'http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD' -O config.guess

Configurar y compilar:
CFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ./configure
make -j4

Ayuda de teclas con shift+?

Puedes pasarle un nombre de jugador, un archivo de salvado, etc.. usando la variable de entorno ROGUEOPTS. Como por ejemplo así:
ROGUEOPTS="name=Manuel,file=manuel.save" ./rogue.bin -r

***************Borrar un archivo con nombre que contiene caracteres extraños*****************************

Lo primero, buscamos su inode:
ls -il

(el número largo que aparece a la izquierda del todo es el inode de cada archivo)

Ahora, usamos find para encontrarlo por inode y borrarlo

find . -inum 14071947 -exec rm {} \;

Si el problema es que el archivo lleva un par de guiones al inicio de su nombre, lo que hacemos es:

rm -- --*

ya que el primer -- indica a rm que no se le van a pasar mas parámetros, por lo que ya no interpretaría el nombre del
archivo como tales.

***************Configurar la salida de audio de la Raspberry para que use el jack*****************************

sudo amixer cset numid=3 1

Lo pones una vez y ya queda configurado en los valores de ALSA.

Y para el audio por HDMI otra vez:

amixer cset numid=3 2

***************Gestión avanzada de acceso a ficheros en Linux********************************************

Para ver qué procesos tienen algún fichero abierto en un directorio, a quién pertenecen, etc:

lsof +D /var
lsof +D /etc
...

Para ver los números de los procesos que tienen algún fichero abierto en un directorio, a quién pertenecen, etc:

lsof -t +D /var
lsof -t +D /etc
...

Para matar los procesos que tienen algún fichero abierto en un directorio:

lsof -t +D /var | xargs kill
lsof -t +D /etc | xargs kill
...

Para matar todos los procesos de un usuario:

killall -u <usuario>

Para matar todos los procesos lanzados por un proceso (por ejemplo todos los procesos lanzados por un script):

pkill -P <PID_del_proceso_padre>

Por ejemplo, yo mato todos los procesos lanzados por el proceso con PID 1, que es mi script mínimo de inicio, con:

pkill -P 1

***************Sidplay no encuentra /dev/dsp*************************************************************

sudo modprobe snd-pcm-oss 

***************Sacar copia de seguridad del sistema*******************************************************

Del rootfs. Si hay partición de arranque, va a parte.

sudo tar -cvpzf backup.tar.gz --exclude=/backup.tar.gz --one-file-system /

Y para restaurar:

sudo tar -xvpzf backup.tar.gz -C /media/whatever --numeric-owner

***************Bajarse los sources de un programa en Debian***********************************************

Lo primero que necesitamos es una entrada de sources en el /etc/apt/sources.list, del tipo:

deb-src http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi

Hacemos un 

sudo apt-get update

Y luego ya podemos hacer 

apt-get sources timidity

NO HAY que ser root para hacer esto, ya que los sources NO se instalan sino que se descargan en el directorio actual y ya.

****************Bajarse los sources de un kernel en debian/ubuntu******************************************

Pongamos que uname -r te dice que usas el kernel

linux-image-3.4.0-1490-omap4

Entonces, para bajarte los sources de ese kernel, haces:

apt-get source linux-image-3.4.0-1490-omap4

Si estás compilando justo este kernel, al compilar los módulos te dira no sé qué.
Deactiva CONFIG_BINFMT_AOUT y vuelve a compilar.

-Podemos extraer una configuración de un kernel previo con

./extract-ikconfig ~/panda/boot/uImage > ~/panda/.config

O bien podemos crear una muy básica que arranca, por ejemplo, en todos los OMAP, con

make ARCH=arm omap2plus_defconfig

make ARCH=arm menuconfig 

-Compilamos el kernel

make -j4 ARCH=arm CROSS_COMPILE=~/x-tools/arm-unknown-eabi/bin/arm-unknown-eabi-  uImage

-Compilamos los módulos del kernel:

make -j4 ARCH=arm CROSS_COMPILE=~/x-tools/arm-unknown-eabi/bin/arm-unknown-eabi- modules

-E instalamos los módulos:

sudo make ARCH=arm modules_install INSTALL_MOD_PATH=/media/manuel/LINUX/

-Y lo mismo el kernel:

sudo cp arch/arm/boot/zImage /media/manuel/BOOT/


****************Extraer la configuración de un kernel*******************************************************

Para extraer un .config de un kernel que sabemos que funciona, en el directorio scripts de los kernel sources tenemos un script apropiado que funciona así:
./extract-ikconfig ~/panda/boot/uImage > ~/panda/.config


***********Recuperar un archivo corrupto de Abiword u otro procesador de textos que se niega a abrir*********

Nos instalamos ipython 

sudo apt-get install ipython

Y vamos haciendo las siguientes cosas, una por línea:

data = open('current_events.abw', 'r').read()

from lxml import html

doc = html.fromstring(data)

doc

print ''.join(doc.xpath('//text()'))

Listo. Lo copiamos de la consola a un editor en condicioes y arreglado.
(Sacado de http://stephenmw.wordpress.com/2011/01/18/abiword_recovery/)


********Instalar FSV, el navegador de archivos en 3D****************

Clonamos el repo
https://github.com/mcuelenaere/fsv
e instalamos: 
sudo apt-get install libgtk2.0-dev
Ya sólo queda un -/config y make, y a correr.

*********Averiguar qué paquete contiene un archivo dado***************

dpkg -S filename

*********************Versión que tenemos instalada de un paquete******

dpkg -l |grep libgbm-dev

*********************Buscar un archivo recursivamente a partir de un punto del sistema de ficheros***********

find ./ -name '*gtk*'

************Tabla de permisos de Unix*****************

Esto lo deberías tener en la cabeza, pero se te suele olvidar.
Las tres posiciones de los números corresponden con OWNER, GROUP (del owner) y OTHER USERS.
Y los valores de los números son decimales de tres bits. Estos tres bits pueden estar activos o inactivos (¿no me digas?) configurando así el valor.
Su órden es R, W, X. (Lectura, escritura y ejecución).
Así, si queremos que el propietario tenga permisos de ejecución y lectura, será un 101 binario, que inmediatamente sabemos que es un 5.
Si queremos que el grupo tenga permisos de lectura solamente, será un 100, que es un 4.
Y si queremos que el resto sólo tengan permisos de ejecución, será un 001, que es un 1.
O sea que haremos chmod 541 nombrearchivo y nos quedaremos tan anchos.
 


***************Escanear las Ips conectadas en red local (la misma del equipo en que estoy)***********************

nmap -sn 192.168.1.0/24

Esto escanearía las Ips conectadas a la red 192.168.1.x, que es lo que seguramente quieres hacer.
Fácil y muy, muy útil.

****************Arrancar Lubuntu en modo texto**********************

Editamos /etc/default/grub y añadir “text” a los parámetros de la línea  GRUB_CMDLINE_LINUX_DEFAULT

Ejecutamos sudo update-grub


******************El sistema se empeña en que tenemos 0 bytes free en partición EXT4*******

Borramos archivos pero no recuperamos el espacio!
Esto es porque se reserva un 5% por defecto para el root. Para cambiar esto, simplemente hacemos:

tune2fs -m 1 <device>

y de este modo sólo se reserva el 1%. Solucionado.

******************Cambiar el tamaño del texto y la fuente en la consola**********************

sudo dpkg-reconfigure console-setup

*******************Limpiar Lubuntu de los "procesos malditos", whoopsie y apport**********

Esta pareja de hijos de puta gusanos de la fundación Canonical se tiene que ir de cualquier sistema con Lubuntu que yo instale.
Así que empieza la fiesta del dpkg...

dpkg -r --force-depends apport-gtk
dpkg -r --force-depends apport
dpkg -r --force-depends whoopsie

y por último, aunque te suene raro, desinstalamos lubuntu-desktop porque el paquete queda con sus dependencias rotas y 
nos estaría avisando el gestor de paquetes en cada arranque si no lo desinstalamos:

dpkg -r --force-depends lubuntu-desktop

Ya veremos qué pasa si intento instalar algo que dependa de lubuntu-desktop.. si empiezan a fallar las cosas, es hora de
pasar a Debian.

*******************Autologin en modo texto en Lubuntu************************************

Con systemd. 
Sabemos que el fichero principal de la unit de getty@tty1.service está en:

/lib/systemd/system/getty@.service

Vale. Tenemos varias alternativas. Podemos editar /lib/systemd/system/getty@.service y cambiar lo que necesitemos, o podemos crear un drop-in, que es 
como un parche para cambiar cosas de la unit sin cambiar la unit. 
Vamos a hacer esto segundo, a usar un drop-in. Para ello, creamos el fichero (y los directorios precedentes si hiciese falta):

sudo vim /etc/systemd/system/getty@tty1.service.d/autologin.conf

Metemos en ese fichero esto:

[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin username --noclear %I 38400 linux

Salvamos, recargamos la configuración de los daemons:

systemctl daemon-reload

y reiniciamos el servicio:

systemctl start getty@tty1.service

Para ver que todo va bien, podemos hacer:

systemctl status getty@tty1.service

FALLO GORDO: que la ruta de agetty sea incorrecta. Si no lo es, no puede funcionar el servicio, lógicamente.
Así que comprueba que tienes /sbin/agetty y que efectivamente este ejecutable existe.

Añadimos una segunta tty que se lance automáticamente (los agetty sobre tty1, tty2, tty3, etc.. se lanzan por activación
de socket, pero sólo viene que se lance el primero, así que añadimos otra agettty sobre tty2):

-Creamos la UNIT para agetty sobre tty2:
sudo ln -sf /usr/lib/systemd/system/getty@.service /etc/systemd/system/getty.target.wants/getty@tty2.service

-Creamos eo drop-in override para autologearnos en tty2 también:

sudo vim /etc/systemd/system/getty@tty2.service.d/override.conf

con el contenido:
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin manuel --noclear %I 38400 linux

-Recargamos settings y reiniciamos el servicio:
systemctl daemon-reload
systemctl start getty@tty2.service

Fuentes:

https://wiki.archlinux.org/index.php/Automatic_login_to_virtual_console
https://wiki.archlinux.org/index.php/Systemd_FAQ#How_do_I_change_the_default_number_of_gettys.3F

Para cambiar la fuente de letra, de momento hacemos setfont Lat15-TerminusBold24x12 en .bash_profile y listo.

Ya que estás, puedes quitar más mierdas:

sudo systemctl disable NetworkManager-wait-online
sudo systemctl disable apparmor
sudo systemctl disable ModemManager
sudo systemctl disable whoopsie
sudo systemctl disable apport

fuente:

http://www.samplerbox.org/article/fastbootrpi

INFO ANTIGUA DE ANTES DE SYSTEMD

Editamos /etc/init/tty1.conf y añadimos -a username a la línea donde se lanza la consola tty1. Quedaría así:

exec /sbin/getty -8 38400 tty1 -a <nombre_usuario>

******************Desactivar tap to click en el synaptics trackpad en Lubuntu*********************************************

Entramos en Preferences->Default Applications for LXSession->Autostart, y añadimos 

synclient MaxTapTime=0

bajo la categoría "Manually Autostarted Applications". Le damos a + y ya.

*****************Gestor de conexiones no aparece************************************************************

Añadir nm-applet en el mismo lugar que cabamos de mencionar, en Preferences->Default Applications for LXSession->Autostart

*******************Desactivar servicio de los que se lanzan en arranque en Lubuntu****************************

Es un poco distinto que en Debian. 
Modemmanager se quita con un apt-get install purge modemmanager.
Por ejemplo, para deshabilitar el network manager, movemos /etc/init/network-manager.conf a /etc/init/network-manager.conf-disabled

Para volverlo a habilitar, pues lo movemos donde estaba.

Otra manera es hacer 

sudo update-rc <nombre_servicio> disable

De hecho, lo mejor es hacer ambas.

Ahora tendrás que especificar la configuración de red a piñón en /etc/network/interfaces

iface eth0 inet static
address 192.168.1.35
netmask 255.255.255.0
gateway 192.168.1.1


Y NO TE OLVIDES de añadir eth0 a la linea auto, quedando

auto lo eth0

O si no, tendrás que andar haciendo a mano ifup eth0 en cada arranque. 
Y si ves que tienes salida a internet pero no resuelve nombres, tienes dos opciones:

1)

Añadir en el propio /etc/network/interfaces

dns-nameservers 208.67.222.222 8.8.8.8

El primero es el de OpenDNS, y el segundo el servidor DNS de google, o sea que mejor usar el primero.

2)

Deshabilitar el servicio resolvconf, moviendo /etc/init/resolvconf.conf a /etc/init/resolvconf.conf-disabled, 
para que /etc/resolv.conf no sea sobreescrito. 
Ahora ya sólo queda borrar /etc/resolv.conf que es un link duro a un fichero del servicio resolvconf (concretamente, antes de borrarlo vemos 
que /etc/resolv.conf -> ../run/resolvconf/resolv.conf, por si lo quieres restaurar), editar un nuevo /etc/resolv.conf y añadirle ahí nuestros servidores DNS:

nameserver 208.67.222.222 
nameserver 8.8.8.8

Mola más este segundo estilo, ya que lo dejamos todo más sencillo y más estándar.

****************Usar SUDO sin password***************************

Hacemos sudo visudo y la línea del grupo sudo la dejamos así:

%sudo ALL=NOPASSWD: ALL 

*****************Desactivar tarjeta gráfica ATI********************

En /etc/rc.local:

echo OFF > /sys/kernel/debug/vgaswitcheroo/switch

*****************Configurar un servidor SAMBA y un share. Montar el share.********************

En el servidor:

-Instalamos el paquete samba

sudo apt-get install samba

-Editamos /etc/samba/smb.conf
 En la sección [global] dejamos el workgroup por defecto y descomentamos la línea “security = user”, para que se puedan logar usuarios.

-Al final del fichero, añadimos un share. MUY IMPORTANTE, atento al nombre que le pones al share entre corchetes porque es el nombre que necesitas luego para acceder a él a través de la IP del servidor SAMBA.
Nosotros lo hemos llamado [biblio], porque contendrá la base de datos de este programa, para que distintas instancias a través de la red accedan a la misma base de datos.
Nos queda así nuestro primer share:

[biblio] 
    comment = Biblio Database
    path = /home/edu/database
    browsable = yes 
    guest ok = yes 
    read only = no 

-En este caso, el directorio del share no tenemos que crearlo porque ya lo crea la instalación del Biblio, pero si no, habría que crearlo.
Lo que sí tenemos que hacer es cambiarle el propietario y los permisos:

sudo chown nobody.nogroup /home/edu/database
sudo chmod -R 0777 /home/edu/database

En este caso lo he hecho para .wine y todos sus subdirectorios y funciona. Es un poco radical, pero había que resolver el tema.

Relanzamos el servidor SAMBA:

sudo restart smbd 
sudo restart nmbd 


En el cliente:

-Instalamos las cifs-utils
sudo apt-get install cifs-utils
-Ya deberíamos ser capaces de montar el share con

sudo mount -t cifs -o username=edu,password=marta //192.168.1.35/biblio fakebase/

-Habremos creado previamente el directorio fakebase dentro de la instalación local de Biblio (/home/vader/.wine/drive_c/Biblio/fakebase)
y habremos hecho un link simbólico (soft) al fichero Biblio.mdb de fakebase, de manera que cuando Biblio accede a su Biblio.mdb, en realidad lo hace al Biblio.mdb del share Biblio del servidor de ficheros SAMBA.
O sea que, estando en home/vader/.wine/drive_c/Biblio, hacemos un

ln -s fakebase/Biblio.mdb Biblio.mdb 

-Ahora podemos automatizar el montaje del share en los clientes, añadiendo a /etc/fstab las líneas:

#El servidor de ficheros con la base de datos de BIBLIO 
//192.168.1.35/Biblio /home/manuel/.wine/drive_c/Biblio/fakebase cifs username=corchetema,password=enfermera 0 0 

Por supuesto, para esto deberíamos tener una IP fija en el servidor.
No hace falta acceso sin user/pass ni nada, va bien así y no hay problemas especificando el user/pass en el fstab.

Y ya podemos dar de alta libros desde dos instancias del programa sobre la misma base de datos. Enjoy!

*****************************Error recalcitrante con “sdb write cache” en Lubuntu***************************

Es un problema de los drivers del lector de tarjetas. 
Ubuntu no hace caso a los parámetros que se le pasan a los módulos en /etc/modules e ignora las entradas en /etc/modprobe.d/blacklist.conf, así que al final tuve que añadir a /etc/rc.local la línea sudo rmmod ums_realtek. 


******************************Añadir repositorio en Ubuntu************************************************ 

sudo add-apt-repository <repo_address>

*****************************Cómo instalar pyrit + módulo CUDA (Nvidia) en Lubuntu************************

Lo primero que hay que tener claro que pyrit funciona por defecto usando la CPU, y que para que use la gráfica hay que instalar unas cosas de nvidia (además del driver propietario) y luego un módulo de pyrit para cuda.

Lo primero es instalar el driver propietario de NVIDIA, ya que nouveau NO VALE para esto:
sudo apt-get install nvidia-current

El siguente paso a lo mejor no es necesario, aunque yo lo hice. Probablemente todo esto se instale al instalar los cachivaches de nvidia:

sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev

Instalamos python-dev y otras cosas:

sudo apt-get install python-dev 
sudo apt-get install libpcap-dev
sudo apt-get install libssl-dev 

Ahora instalamos las cosas de nvidia:

sudo apt-get install nvidia-cuda-dev
sudo apt-get install nvidia-cuda-toolkit

Hacemos el siguiente link simbólico, ya que libcuda se instala en una localización por defecto distinta de donde la buscará el módulo cuda de pyrit, y si no lo hacemos, no la encuentra, con el consiguiente error:

ln -s /usr/lib/nvidia-304/libcuda.so /usr/lib/libcuda.so

Nos bajamos el pyrit y los módulos:

wget http://pyrit.googlecode.com/files/cpyrit-cuda-0.4.0.tar.gz
wget http://pyrit.googlecode.com/files/pyrit-0.4.0.tar.gz

Empezamos instalando el módulo, entrando en el directorio de cpyrit-cuda y poniendo:

python setup.py build
sudo python setup.py install
Estas cosas no deberían darme ningún error. Si dice algo de unas cabeceras que hacen falta pero no se encuentran y continuing anyway, pasamos del tema.

Entramos en el directorio de pyrit y hacemos la misma:

python setup.py build
sudo python setup.py install

El binario de pyrit se instala en /usr/local/bin/pyrit, así que le hacemos un 

ln -s /usr/local/bin/pyrit /usr/bin/pyrit

Y ya debería estar. Lanzamos

pyrit list_cores

y deberíamos ver algo como:

The following cores seem available...
#1:  'CUDA-Device #1 'GeForce 9400''
#2:  'CPU-Core (SSE2)

Ahora lanzamos un 

pyrit benchmark

...y vemos si merece la pena o no...A la gente le da 3000 y pico, con máquinas decentes.

Ahora usamos el pyrit para romper una contraseña:

pyrit -r “84:9C:A6:A3:8E:8F-01.cap” -b "84:9C:A6:A3:8E:8F" -e "Orange-8E8D" -i <diccionario.txt> attack_passthrough

**************************Tirar el servidor gráfico (Xorg) en Lubuntu************************************

sudo service lightdm stop

y para volver, obviamente, start.

**********Configuración óptima de RetroArch************

VIDEO: driver VULKAN, VSYNC off, MAX_SWAPCHAIN 2
AUDIO: driver ALSA, 44100 Hz, 32ms, resampler quality normal
(Si bajas el audio a 44100, bájalo también en las opciones del core FBNeo)

SHADER:

Usamos el shader crt-pi, que está en /crt, con los parámetros:
Curvature horizontal 		0.10
Curvature vertical			0.15
Mask brightness				0.70
Scanline weight				6.00
Scanline gap brightness 	0.90
Bloom factor				1.00
Input gamma					2.40
Output gamma				2.20
Y editamos el shader en ~/.config/retroarch/shaders/slang/crt/shaders/crt-pi.slang,
y ponemos MASK TYPE a 1, que consume menos CPU y se ve mejor.
(OJO!!! ESTE SHADER NECESITA QUE TENGAS "INTEGER SCALE" ACTIVADO Y "ASPECT RATIO" FORZADO A "4:3"
 EN SETTINGS->VIDEO->SCALING, O SE RALENTIZARÁ).

(OJO!!! COMO ÚLTIMO RECURSO PARA QUE EL SHADER NO CAUSE DROPOUTS DE AUDIO EN LOS CORES EXIGENTES,
edita el shader y comenta todos los defines posibles, dejando toda esa sección comentada así:
//#define SCANLINES
//#define CURVATURE
//#define FAKE_GAMMA
//#define GAMMA
//#define SHARPER
//#define MULTISAMPLE
OJO!!! PARA EVITAR MOVIMIENTO HORIZONTAL "SUCIO", ya que estás editándolo, pon MASK_TYPE a 1.  
)

O bien usamos el shader ZFast, que está en /crt, con los parámetros:
Blur amount:				1.00
Scanline Darkness - Low:	0.00
Scanline Darkness - High:	0.00
Dark pixel brightnes boost: 1.25
Mask effect amount:			0.80
Mask/Scanline fade:			0.80
(OJO!! Para que el efecto MASK se vea, edita el shader y comenta la línea "#define FINEMASK". Viene maqueado para pantallas de baja resolución.)
(OJO!! ZFAST en realidad es más lento que CRT-PI, porque en ZFAST no podemos comentar las scanlines y dejar sólo la máscara).

O bien usamos FAKELOTTES, que tiene una mask increíble, pero olvídate de mGBA y de SwanStation, claro.

PARA EL SWANSTATION, ACUÉRDATE DE PONER EL RENDERER DEL CORE EN "SOFTWARE" (No le eches la culpa al shader si hay audio dropouts)...

PARA EL CORE DE NES (NESTOPIA) USA LA PALETA "CXA2025AS", O LA CONFIGURACIÓN DE SHADERS SE VERÁ MUY RARA.

SI USAS INTEGER SCALING Y QUIERES UN BORDE PARA LA PANTALLA:
-Clona el repo https://github.com/libretro/common-overlays.git, y mete los overlays que quieras en ~/.config/retroarch/overlay
-Ve a QUICK MENU->ON-SCREEN OVERLAY, activa DISPLAY OVERLAY, y selecciona un overlay preset de los que has copiado.
(Se podría activar y ajustar también en SETTINGS->ON-SCREEN DISPLAY->ON-SCREEN OVERLAY, estableciendo así un solo overlay
para todos los cores, pero como cada core aparece de un tamaño en pantalla al usar INTEGER SCALING, nos conviene gestonarlo
aquí en QUICK MENU para que quede configurado core a core).

*********No funcionan los input en RetroArch**********

PARA que haya input con el driver udev (input_driver = "udev") debemos crear /etc/udev/rules.d/99-evdev.rules con el contenido:
KERNEL=="event*", NAME="input/%k", MODE="666"
Ahora podemos hacer
sudo udevadm control --reload-rules
sudo chmod 666 /dev/input/event*
o simplemente reiniciar.

*********Conservar la asignación de mandos a los puertos de RetroArch***************************************

La idea es que, si tenemos dos mandos por ejemplo, uno de ellos sea siempre el del puerto 1 de RetroArch y el otro sea el del puerto 2 de RetroArch.

¡¡¡NO HACE FALTA ANDAR CON REGLAS DE UDEV!!!

Nos vamos a SETTINGS->INPUT->PORT 1 CONTROLS y en DEVICE INDEX seleccionamos el mando que queramos que sea siempre
el del puerto 1.
Repetimos para  SETTINGS->INPUT->PORT 2 CONTROLS y su DEVICE INDEX.

Puedes quitar y poner los mandos como quieras, etc... y la configuración se conserva siempre. Si inicias RetroArch con uno solo de los dos mandos
conectado, tampoco hay problema y sigue en su puerto correcto.

*********Configurar RETROARCH para que cuando usas el driver de video VULKAN no cambie la resolución********

En retroarch.cfg, pon el modo de vídeo que usa el sistema en los parámetros:

video_fullscreen = "true"
video_fullscreen_x = "1280"
video_fullscreen_y = "720"

Y así ya no cambiará el modo de vídeo.

**********RETROARCH no salva las partidas de SRAM a veces**************************

Hay que tener en cuenta que RETROARCH no salva la SRAM automáticamente, sino que vuelca la SRAM al salir del core que sea.
Para tener algo parecido a un volcado de SRAM automático, activa SETTINGS->SAVING->SaveRAM Autosave Interval,
que por defecto deberían ser unos 10s.
Sólo escribe en disco si encuentra diferencias en la SRAM (así que no escribe continuamente!) e incluso así, es una tarea que
va en su propio thread si tienes activada la opción SETTINGS->USER INTERFACE->Threaded Tasks (cosa que SIEMPRE deberías tener activada).

****************************Para configurar PINN después de actualizarlo***********

Montamos /dev/sdb1, y ponemos en config.txt:

disable_splash=1
disable_overscan=1

Para establecer una espera en segundos, puedes añadir en recovery.cmdline:
bootmenutimeout=60

Y para que no busque actualizaciones, puedes añadir en recovery.cmdline:
no_update

Tienes todas las posibles opciones de recovery.cmdline en:
https://github.com/procount/pinn/blob/master/README_PINN.md#cmdline-options

****************************Cómo compilar libmodplug*******************************

Cambia automake-1.13 a automake-1.11 en el Makefile.
Configura con: 
CFLAGS="-O2 -mfpu=vfp -mfloat-abi=hard -march=armv6j" CXXFLAGS="-O2 -mfpu=vfp -mfloat-abi=hard -march=armv6j" ./configure --enable-static

****************************Cambiar la resolución al vuelo en KMSDRM*******************

Se haría con switchres, que puede ser un programa que tienes aquí para bajar y compilar:

git clone --depth 1 https://github.com/antonioginer/switchres.git

Editamos custom_video_drmkms.cpp y ponemos drm_name[15] a "/dev/dri/card1" y más abajo comentamos la línea donde hace
drm_name[13] = '0' + num;

También podemos comentar el drmDropMaster() más abajo para que no nos diga "[ERROR] limited DRM rights on this screen"
(aunque funciona igual, vamos).

Y luego es simplemente:
switchres 1280 720 50 -s -k
(OJO!! -k hace los cambios permanentes!!)

...O bien compilando RetroArch con soporte para SwitchRes y luego configurando la resolución que queramos en:
Settings->Video->CRT SwitchRes

****************************Milkytracker en la Raspberry Pi****************************

Para evitar undefined symbols en tiempo de linkado, hacemos:

CFLAGS="-Ofast -march=armv6 -mfpu=vfp -mfloat-abi=hard -lasound" CXXFLAGS="-Ofast -march=armv6 -mfpu=vfp -mfloat-abi=hard -lasound" ./configure

***************************Menú XBM en RetroArch con carátulas, autolanzado de cores, etc...**********************************

OJO: Para tener el menú XMB funcionando con sus fuentes, mostrando iconos en lugar de cuadros negros. etc...

-Si no quieres shimmering en las letras del RGUI, tienes que irte a SETTINGS->USER INTERFACE->APPEARANCE
y activar LINEAR FILTERING.

-Tienes que habilitar el soporte para PNG (rpng) al configurar

-Necesitas los assets de aquí: https://github.com/libretro/retroarch-assets
De ese repo, necesitas solamente el directorio xmb en el directorio de assets. El directorio de assets se cambia en el menú o en el cfg. Yo los tengo en ~/retro/assets,
de tal manera que ahí quedaría el directorio xmb del repo, tal que ~/retro/assets/xmb

-Si quieres que RetroArch te ofrezca con qué emulador quieres correr una ROM, tienes que clonar este repo:
git clone --depth 1 https://github.com/libretro/libretro-super.git
Y mandar el contenido del directorio libretro-super/dist/info a ~/.config/retroarch/cores. Sí, junto con los cores. Así:
cp -R libretro-super/dist/info/* ~/.config/retroarch/cores/
Ahora en RetroArch, en Settings->File Browser, desactiva todo y activa "Filter Unknows Extensions"

-Para poder tener las opciones de escanear directorios y tal, de modo que se nos creen las playlists que es lo que permite que al cargar una ROM
 se cargue automáticamente su core, tienes que activar libretrodb.
 Además, tienes que tener las databases de libretro, de manera que pueda comparar tus roms contra las de las databases.
 Así que te bajas las databases de este repo:
 clone --depth 1 https://github.com/libretro/libretro-database.git
 De ese repo sólo necesitas en realidad el directorio rdb.
 Ahora tienes que configurar el setting "content_database_path" de tal manera que apunte al directorio rdb. Si tengo todo el contenido del repo
 en ~/home/pi/retro/db, pues pongo content_database_path apuntando a ~/home/pi/retro/db.
Lo puedes hacer desde el propio XMB en Settings > Directory
 Ahora ya debería escanear las ROMS y sacártelas ordenadas por icono de sistema en la parte de arriba, pero si intentas lanzar una te dirá que "not cores found".
 Pues vale, nos vamos a settings > playlist, y ahí podemos asociar los playlists con cores, de tal manera que el playlist de NES cargue el nestopia, etc...
 Por CADA directorio de ROMs escaneado, XMB te va a crear una playlist, donde todas las ROMs de esa playlist se van a abrir con un determinado core. 
 Estas playlist son archivos.lpl que los crea al principio en ~/.config/RetroArch/playlists, pero tenemos el setting playlist_directory.
 Yo lo que he hecho ha sido configurar playlist_directory para que apunte a ~/retro/db/playlists, y ahí he metido las playlists que ya tenía, y ahí meterá XMB las nuevas
 que vaya creando.

-Si además quieres fotos de las carátulas, etc.. en las playlist, pues te bajas los thumbnails de aquí: http://thumbnailpacks.libretro.com/
 Los mandas a donde quieras, hay que descomprimir el zip. y luego apuntas el setting thumbnails_directory a ese directorio. Por ejemplo, yo me creé ~/home/pi/retro/db/thumbnails,
o sea, mandé los thumbnails a un directorio bajo retro/db, y ahí dentro tengo Atari\ -\ 7800, etc...
Pues  pongo thumbnails_directory apuntando a ~/home/pi/retro/db/thumbnails. Así de sencillo. Lo puedes hacer desde el propio XMB en Settings > Directory

-Si quieres poner RA en autoarranque, ~/.profile es una buena opción.. PERO desactiva el autologin en la segunda TTY, o estarás lanzando dos instancias de RA
 y las cosas irán LENTAS.

-Para que se autoarranque, pero no se intente lanzar cuando entres por ssh, pon esto en .profile:

if [ -z "$SSH_TTY" ] ; then  
    cd retro
    ./retroarch-xmb -c cfg/xmb.cfg &> /dev/null && sudo poweroff
fi

-Si ves que al cargar varios juegos tienes errores de EGL, pon gpu_mem=256 en el config.txt

RETROARCH EN UN PC GENÉRICO SOBRE X11
=====================================

Dependencias previas:
sudo apt-get install libasound2-dev glslang-dev glslang-tools spirv-tools \
xcb libxcb-xkb-dev x11-xkb-utils libx11-xcb-dev libxkbcommon-x11-dev

CFLAGS="-march=native -mtune=native -O2" \
CXXFLAGS="-march=native -mtune=native -O2" \
./configure --disable-ibxm --disable-vg --disable-sdl2 --disable-al --disable-cheevos --disable-ffmpeg \
--disable-networking --disable-netplaydiscovery --disable-libretrodb --enable-udev --disable-sdl --disable-pulse --disable-oss \
--disable-freetype --disable-7zip --disable-imageviewer --disable-rjpeg --disable-rbmp --disable-rtga --disable-flac \
--disable-qt --disable-materialui --disable-xmb --enable-rgui --disable-ozone --disable-gfx_widgets --disable-langextra \
--disable-cdrom --disable-accessibility --disable-tinyalsa --disable-rpiled \
--enable-opengl --enable-vulkan

Ahora ya compilamos:
make -j8 V=1
El V=1 es para ver las líneas de compilación y comprobar que nuestros flags se están usando, etc

Si quieres compilar en modo debug, haz:
make -j6 DEBUG=1 V=1
y se le pasará -O0 -g al compilador, y nada de -O2 ni -O2

COMPILAR UNA VERSIÓN MÍNIMA DEL CORE FBALPHA CON DRIVERS DESHABILITADOS
===========================================================================

Lo primero, nos vamos a
cd src/burner/libretro

En Makefile.common, quitamos los directorios de la parte de FBNEO_BURN_DRIVERS_DIR. Busca la cadena snes y ahí ves qué tipo de líneas tienes que quitar.
No hace falta que quites los directorios de los includes, esos dan igual.

Editamos Makefile y dejamos la platform definition de la pi4 asi:

   else ifneq (,$(findstring rpi4,$(platform)))
      PLATFORM_DEFINES := -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer
   endif

Ahora hacemos un 
make platform=rpi3 generate-files
de manera que nos genere los headers sólo con los drivers que hemos dejado en el makefile.libretro_common,

y luego ya el 
make platform=rpi3 -j4
y listo. 


ERROR DE LANGUAGE DE PERL al acceder por ssh a una máquina
=====================================================

Esto ocurre porque la máquina desde la que accedemos exporta los settings de lenguaje a la máquina a la que estamos accediendo, y en esa no está instalado el 
soporte para el lenguaje que sea.
Para quitar los avisos de mierda de LANGUAGE de perl:

export LANGUAGE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LC_TYPE=en_US.UTF-8

en el .bashrc y listo. Si persiste, añadimos lo mismo a .bash_profile.


Móviles Android, SONY walkman y dispositivos MTP que fallan al funcionar en modo MTP en Lubuntu como cámaras, etc
======================================================================================================

El problema es que el PCMANFM los automonta como MTP y no van bien. Para que los monte como MSC, es decir, como pendrives normales y corrientes, simplemente ELIMINA
o mueve a otro sitio /usr/lib/gvfs/gvfs-mtp-volume-monitor
Y el PCMANFM ya no toca los huevos.

Ahora pon el móvil en modo PTP (en los ajustes de la conexión USB) y debería ir. MTP es mierda. Se cambia en las opciones de desarrollador, en "modo USB predeterminado" o algo así.

También podrías usar jmtpfs para montarlos a mano desde la línea de comandos. Es muy fácil. Creas un punto de montaje, y se lo pasas a jmtpfs, sin nodo ni nada. Él sabe qué hacer.
jmtpfs ~/mnt

Instalar la versión que queramos de IOS desde Linux en Ipad/Ipod/la basura para retrasados que sea
=====================================================================================

Se usa un opensource que se llama idevicerestore. Tiene dependencias y mierdas varias, pero cuando lo instales puedes hacer estas cosas tan... estúpidas.

sudo idevicerestore iPad2\,5_9.3.3_13G34_Restore.ipsw

LA PESADILLA SYSTEMD: COMO LIBRARNOS DE ELLA
=============================================

Podemos simplemente hacer que fncione en modo sysvinit, que es lo bueno:
apt-get install sysvinit-core systemd-sysv-

Y para saber por qué coño se nos instaló SYSTEMD al actualizar, miramos las dependencias inversas:
apt-cache rdepends systemd --installed

GUÍA RÁPIDA PARA COMPILAR UN KERNEL REALTIME (TIEMPO REAL) EN LA RASPBERRY PI  (INSTRUCCIONES DE NOVIEMBRE DE 2017)
==================================================================================================================

NOTA: NO TIENE SENTIDO compilarte un kernel realtime si puedes aislar CPUs y ejecutar tareas en ellas (aunque sí sería interesante que esas CPUs
fueran además tickless: de ese modo tienes un desempeño similar a baremetal). Es mejor esa alternativa para asegurarte de que nada va a interrumpir
tu tarea.
Por otra parte, aumentar mucho los ticks del scheduler (Kernel features->Timer frequency) tampoco tiene sentido subirlos a 1000Hz
en un sistema para emuladores: eso es para escritorios, que NO ES LO MISMO! En un escritorio quieres responsividad y hay muchas tareas
a la vez que dan soporte a los programas (un navegador, correo electrónico, mensajería instantánea, programa de diseño, reproductor de música...
lo tienes TODO a la vez y quieres que todo tenga una respuesta buena).
EN UN SISTEMA EMULADOR ese no es el caso: tienes un proceso y se acabó. NO TIENE SENTIDO un scheduler repartiendo la CPU 1000 veces por segundo,
con 100 va que chuta. 
Si quieres elige 250 por aquello de la frecuencia de polling de los USBs, que con usbhid.jspoll=1 puedes leerlos a 1000 Hz, 
o porque para audio es algo mejor, PUES OLVÍDATE: NO TIENE SENTIDO: EL KERNEL CORRE SOBRE HRTIMERS, QUE SON TIMERS INTERNOS DE ALTA RESOLUCIÓN.
O sea que EL KERNEL NO CORRE SOBRE EL VALOR DE LOS HZ DEL SCHEDULER: ESTE VALOR SÓLO INFLUYE EN PROGRAMAS MULTITHREAD DONDE LOS THREADS
ESTÁN "ATADOS" A TIEMPO DE COMPUTACIÓN.
Así que, SÍ, PUEDES TENER UN KERNEL CON HZ_100 Y QUE A LA VER HAGA EL POLING DE LOS USBS A 200HZ (EL VALOR POR DEFECTO ES 120HZ, así que ni te molestes
con lo del polling rate de todos modos).

Tampoco te compliques con el modelo de preemption: el modelo CONFIG_PREEMPT es para escritorios de baja latencia, una vez más son muchos procesos
a la vez y quieres responsividad en todos ellos, que NO es nuestro caso. Así que CONFIG_PREEMPT_VOLUNTARY va bien, que es el valor por defecto.
Puedes usar si quieres el CONFIG_PREEMPT, que es el siguiente, y que pone que es para sistemas embedidos de baja latencia. Bueno, no nos va a aportar gran
cosa en nuestro caso.

Lo de CONFIG_PREEMPT y 250HZ NO INFLUYE en la latencia, ni en el desempeño ni en nada.
Si luego te quieres meter con CPU isolation (que es DISTINTO a que las CPUs sean tickless: las CPUs aisladas no tienen que ejecutar ticks del scheduler CUANDO NO CORRE NADA EN ELLAS,
si hay algo corriendo en varias CPUs aisladas, tienen que correr ticks del scheduler sí o sí) ya es cosa tuya, el ningún beneficio evidente es que los programas que se ejecutan en una CPU aislada
no se quedan sin CPU nunca por culpa de otros programas: combínalo con ejecutar las aplicaciones con "chrt -f 99", que le da prioridad realtime y no suelta la CPU
porque no hay otra aplicación a la que dársela con la misma prioridad (SCHED_FIFO). Luego hay SCHED_RR, que es con -r, y que genera más ticks del scheduler, así que nos conviene menos.

EL MEJOR hilo donde se habla de estas cosas es este:
https://github.com/raspberrypi/linux/issues/1216
Yo no he encontrado mejor convensación sobre este tema en internet jamás.

PERO SI AÚN ASÍ QUIERES UN KERNEL REALTIME (para emuladores fuera de las X como único proceso de usuario no tiene sentido, pero bueno), ESTOS SON
LOS PASOS (que te pueden venir bien para compilar un kernel sin más):

git clone --depth 1 https://github.com/raspberrypi/tools ~/tools

export KERNEL=kernel7
export ARCH=arm
echo PATH=\$PATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin >> ~/.bashrc
source ~/.bashrc
export CROSS_COMPILE=~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin

git clone --depth=1 https://github.com/raspberrypi/linux

make bcm2709_defconfig

Necesitamos parchear dos cosas: lo del RT del kernel, y una movida de los USB que hace que si no el kernel RT se cuelgue aleatoriamente.
Pillamos los dos parches y los dejamos en el directorio previo al de los surces del kernel (CUIDADO: pilla el parche de RT que empieza por patch.*,
NO el que empieza por patches.*, porque fallará):

wget https://raw.githubusercontent.com/fedberry/kernel/master/usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch
wget https://www.kernel.org/pub/linux/kernel/projects/rt/4.9/patch-4.9.47-rt37.patch.xz

Aplicamos ambos parches:
xzcat ../patch-4.9.33-rt23.patch.xz | patch -p1
patch -i ../usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch -p1 --dry-run
patch -i ../usb-dwc_otg-fix-system-lockup-when-interrupts-are-threaded.patch -p1

KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig

Si quieres ajustar algo del kernel, ahora es el momento de hacer:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
Tenemos al menos que cambiar:
Kernel features->Preemption model->Fully preemptible kernel (RT)
Kernel features->Timer frequency->(lee las notas más arriba: depende de lo que necesites, 1000Hz para un sistema casi mono-proceso no tiene
ningún sentido).

make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs

La instalación ya te la miras en la guía de compilación oficial:
https://www.raspberrypi.org/documentation/linux/kernel/building.md
PERO ESO SÍ: RECOMIENDO COPIAR EL NUEVO KERNEL COMO "kernel7_rt.img" Y ARRANCAR OPCIONALMENTE DESDE ÉL PONIENDO
kernel=kernel-myconfig.img EN CONFIG.TXT, POR SI NO ARRANCA NUESTRO KERNEL RT.

COMPILAR EL KERNEL CON FULL PREEMPTION Y BFS PARA LA RASPBERRY PI
=================================================================

INFO DE https://www.raspberrypi.org/documentation/linux/kernel/building.md COMPLETADA POR MÍ PARA EL TEMA DEL SCHEDULER

Clonamos el kernel, rama por defecto que ahora mismo es la 4.9:
git clone --depth=1 https://github.com/raspberrypi/linux

Yo estaba en ~/src/pi, así que lo tengo en ~/src/pi/linux
Sigo en ~/src/pi

Me bajaré los parches a ~/src/pi

Nos bajamos el parche BFS correspontiente para nuestro kernel de
http://ck.kolivas.org/patches/bfs

Nos bajamos el parche RT correspontiente para nuestro kernel de
https://www.kernel.org/pub/linux/kernel/projects/rt

Ahora aplico ambos parches. Entro en ~/src/pi/linux y hago:
patch -p1 < ../patch-4.4.9-rt17.patch
patch -p1 < ../4.4-sched-bfs-467.patch

Ahora ponemos en el path la ruta del crosscompilador:
PATH=$PATH:$HOME/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin 
Ya deberíamos tener accesibles los binarios arm-linux-gnueabihf-

Ahora pillo la config por defecto para Pi2 y Pi3, que es la misma (estos pasos son de https://www.raspberrypi.org/documentation/linux/kernel/building.md):
KERNEL=kernel7
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig

Ahora, miramos http://ck.kolivas.org/patches/bfs/bfs-configuration-faq.txt y tratamos de cumplir las condiciones para mobile/netbook, o sea:
300 Hz
Tickless
Full preemption
CPU frequency scaling, ondemand default

Para ello entramos en menuconfig:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
Y vamos punto por punto:
-Lo de los HZ está en  KERNEL FEATURES->TIMER FREQUENCY
-Lo de Full Preemption está en KERNEL FEATURES->PREEMPTION MODEL
-Lo de Tickless está en GENERAL SETUP->TIMERS SUBSYSTEM->Timer tick handling
-Lo de CPU frequency scaling está en CPU POWER MANAGEMENT->CPU FREQUENCY SCALING
-Verifica que tienes activo el BFS en GENERAL SETUP, justo la PRIMERA opción que sale tras aplicar el parche.
 Una vez que ha arrancado el kernel, puedes comprobarlo del todo haciendo dmesg | grep scheduler y debería salir el BFS

-En menuconfig podemos quitar muchas cosas. Para saber cuáles son las mínimas mínimas para que funcione lo básico, mírate esto:
http://raspberrypi.stackexchange.com/questions/24092/kernel-config-necessary-options
EL DRIVER OTG (Synopsis DWC host support en DEVICE DRIVERS->USB SUPPORT) tiene que ir INCLUIDO, NO COMO MÓDULO, o el kernel no compilará.
EN FILESYSTEMS, deja tranquilo el AUTOMOUNT ese o systemd se quejará.

-Si quieres quitar el DEBUG_KERNEL, primero desactiva "Embedded system" en General Setup, y luego desactiva "Configure standard kernel features (expert users)"
que está un poco más arriba.
Ahora ya te puedes ir a "Kernel Hacking" y desactivar "Kernel debugging". Listo! 

Ahora compilamos:
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs -j8

Para instalar kernel, módulos y demás, sigue ya con: https://www.raspberrypi.org/documentation/linux/kernel/building.md

RIGEL ENGINE, Duke Nukem II en Linux
====================================

Clonamos su repo:

git clone --depth 1 https://github.com/lethal-guitar/RigelEngine.git
git submodule update --init --recursive

Creamos el directorio de compilación, configuramos y compilamos:
mkdir b4
cd b4
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" cmake -DUSE_GL_ES=ON -DCMAKE_BUILD_TYPE=Release ..

DEVILUTIONX, Diablo en Linux
============================

Dependencias previas:
sudo apt-get install libsodium-dev --no-install-recommends

Bajamos la última estable de:
https://github.com/diasurgical/devilutionX/releases

Configuramos con:
cmake -DVERSION_NUM=<NUMERO_DE_VERSION> -DBINARY_RELEASE=ON -DDEBUG=OFF -DASAN=OFF \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..

Compilamos y metemos en el directorio ~/diablo:
-El ejecutable "devilutionx"
-La versión actual del fichero "devilutionx.mpq" que se descarga de aquí:
https://github.com/diasurgical/devilutionx-assets/releases
(También se genera un "devilutionx.mpq" con el proceso de compilación si tienes smpq instalado).
-El fichero de los datos del juego, que se llama "diabdat.mpq" y que tienes que conseguir por tu cuenta.

La primera vez que ejecutemos el juego, se creará el fichero de configuración en ~/.local/share/diasurgical/devilution/diablo.ini
Para saber más de su contenido, mira esto: https://github.com/diasurgical/devilutionX/wiki/DevilutionX-diablo.ini-configuration-guide

-Puedes poner Scaling Quality a 1, que es BILINEAR simplemente (viene a 2 que es anisotrópico).
-Puedes poner Buffer Size a 1024
-Si quieres que vaya a 16:9, pon "Fit to Screen=1"
(En 16:9 usa un 10% más de CPU, y upscaling es por hardware así que no usa nada de CPU extra).

Si nos da un error repetido de "Unhandled SDL Event: SDL_AUDIODEVICEADDED", ni caso. No es por el sistema sino porque el código del juego imprime eventos que no usa.
Manda la salida a /dev/null y fuera.

SM64EX, port del Mario64 para GNU/Linux
========================================

Clonamos los surces, y el repo de los parches:
git clone --depth 1 https://github.com/AloXado320/sm64ex-alo.git

Editamos src/pc/gfx/gfx_sdl2.c y: 
-Añadimos SDL_WINDOW_FULLSCREEN_DESKTOP a los flags de SDL_CreateWindow()
-Añadimos "SDL_ShowCursor(SDL_DISABLE);" justo debajo de la llamada a SDL_CreateWindow()
-Comentamos la llamada a gfx_sdl_set_fullscreen() que hay justo debajo.

Hay que tener baserom.us.z64 en el directorio raiz.

Se compila para la Pi con:

make TARGET_RPI=1 HIGH_FPS_PC=1 RUMBLE_FEEDBACK=0 BETTERCAMERA=0 -j4

El ejecutable queda en build/us_pc/sm64.us.f3dex2e.arm

Le puedes tocar el tamaño de buffer de audio en src/pc/audio/audio_sdl.c, busca 32000 y a partir de ahí ves todo. Pero vamos, viene en 512, si lo tocas será para subirlo a 1024.

Las versiones más antiguas, como el sm64-ex original, piden algunas dependencias que sólo necesita en la máquina donde se extraen
los datos del juego, que puede ser un PC de escritorio y luego compilar en la Pi.
Si al compilar en la Pi te da errores con las tools que se hayan compilado antes en X86_64, haz todo esto:

rm tools/aifc_decode
rm tools/aiff_extract_codebook
rm tools/vadpcm_enc
rm tools/textconv
rm tools/skyconv
rm tools/n64graphics
rm tools/n64cksum
rm tools/audiofile/libaudiofile.a
make clean
Si aun así da error, borra el fichero con el que da error (el tool que da el error seguramente ya lo hayas borrado antes).

ZELDA OOT EN LINUX
==================

Instrucciones WIP en: https://github.com/mrneo240/ooot-lite/blob/master/Instructions.md

FLARE, un engine RPG libre en la Raspberry Pi
=============================================

Clonamos el repo del engine y del juego:
git clone --depth 1 https://github.com/flareteam/flare-engine.git
git clone --depth 1 https://github.com/flareteam/flare-game.git

creamos el directorio de compilación, entramos en él, configuramos y compilamos:
mkdir b3
cd b3
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -flto" \
cmake -DCMAKE_BUILD_TYPE=Release ..
make -j4

creamos ~/flare y mandamos el ejecutable flare allí.

entramos en flare-game, copiamos el mod default de flare-engine al directorio de mods de flare-game, y copiamos el directorio mods a ~/flare
cd flare-game
cp -R ../flare-engine/mods/default mods/
cp -R mods ~/flare

Ahora ya podemos ejecutar el juego y activar la campania.

NUVIE (Ultima VI) en la Raspberry Pi
==============================

Clonamos:

git clone --depth 1 https://github.com/nuvie/nuvie.git

Ejecutamos el autogen.sh

Añadimos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
en screen/Screen.cpp, justo antes de SDL_CreateWindowAndRenderer()

Configuramos así:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ./configure --disable-debug

Compilamos:

make -j8

Creamos el directorio ~/ultima6 donde meteremos el ejecutable "nuvie" resulante, y allí dentro copiamos el directorio data que viene con los surces, 
y creamos otro directorio ultima6data donde metemos todos los datos del juego.
O sea que nos tiene que quedar:
~/ultima6/nuvie  <---Este es el ejecutable que hemos generado
~/ultima6/data/<aquí los contenidos originales del directorio data de los sources>
~/ultima6/ultima6data/<aquí los datos originales del juego>

En ~/.nuvierc tenemos que poner el gamedir apuntando a ./ultima6data
Si queremos ajustar cosas, en ~/.nuvierc (puedes poner <show_console> a "no", por ejemplo...)

EXULT, Ultima VII en la Raspberry Pi
====================================

Cosas que debemos instalar previamente:
sudo apt-get install autoconf automake libtool

Clonamos

git clone --depth 1 https://github.com/exult/exult.git

---MODIFICACIONES AL CÓDIGO

Editamos exult.cc, comentamos la línea
std::atexit(SDL_Quit);
Y añadimos SDL_Quit() al final de la función Play(), antes del return(0).

---CONFIGURACIÓN DEL CÓDIGO

Ejecutamos el autogen.sh

Configuramos con:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
./configure --disable-all-hq-scalers --disable-nxbr --disable-tools --disable-timidity-midi --disable-alsa \
--enable-lto --with-optimization=normal --prefix=$HOME/ultima7

PODRÍAS PONER --with-optimization=heavy EN LUGAR DE --with-optimization=normal, PERO ESO CAUSA SEGFAULTS A VECES.

Compilamos con make -j4

---INSTALACIÓN DEL JUEGO

Hacemos:
make install
...Esto creará:
~/ultima7/bin, donde la instalación que acabamos de hacer mete el ejecutable "exult" y el fichero "exult.cfg",
~/ultima7/share, donde la instalación que acabamos de hacer meterá unas cosas, y nosotros meteremos a mano los datos del juego,
siguiendo las instrucciones a continuación.

Creamos el directorio ~/ultima7/share/exult/forgeofvirtue
Copiamos los directorios "static" y "gamedat" de nuestra instalación de Ultima 7 a ~/ultima7/share/exult/forgeofvirtue

Para tener música y efectos de sonido, bájate el ZIP all-in-one de aquí:
http://exult.sourceforge.net/download.php
Y simplemente mete los contenidos del zip en ~/ultima7/shared/exult, ahí a saco sin más. No hay que añadir nada en el CFG, va solo con lo que tienes.

La pantalla lo mejor es dejarla así:
Full Screen: Enabled
Display Mode: 1280x720 (<---Suponiendo que tengas el sistema a 720p!! Si no, usa la resolución que uses en el sistema).
Scaler: Interlaced
Scaling: 2x
Game Area: Auto
Fill Quality: Point
Fill Mode: Fit
AR Correction: Disabled

Y listo!

LOVE2D en la Raspberry Pi (love)
============================

Bajamos los últimos source estables de:
https://github.com/love2d/love/releases

Satisfacemos algunas dependencias.
sudo apt-get install --no-install-recommends libmodplug-dev libphysfs-dev libtheora-dev libmpg123-dev libluajit-5.1-dev luajit

La otra dependencia es OpenAL (tienes instrucciones para compilarlas e instalarlas).

Configuramos love con:
cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..

Instala copiando el ejecutable love donde quieras.

INSTALAR JACKD2 EN LA RASPBERRY PI
=================================
FUENTES: http://jrigg.co.uk/linuxaudio/jack2debian7.html
		 http://jackaudio.org/faq/linux_rt_config.html

NO debes usar el gestor de paquetes para esto, porque la versión de libjack, jackd2, etc.. que trae Debian
está compilada con soporte para basuras varias, como X11 o DBUS.
Así que toda compilar a instalar la nuestra:
Bajamos los últimos sources estables de: https://github.com/jackaudio/jack2/releases
cd jack2
./waf configure --alsa --prefix=/usr
./waf -j4
sudo ./waf install
Instala tanto las librerías, como los las headers para desarrollo, como jackd.

Ahora añadimos el overlay que permite que el audio i2s funcione con mmap de verdad:
dtoverlay=i2s-mmap
(Esto es si estás usando una tarjeta de audio conectada por i2s, como la hifiberry)

Ahora añadimos mi usuario al grupo audio (probablemente ya esté):

sudo adduser pi audio

Y editamos /etc/security/limits.conf, añadiendo unas cosillas para quitar ciertas limitaciones a los miembros de ese grupo:
@audio   -  rtprio     99
@audio   -  memlock    unlimited

Comprobamos que tenemos quitados esos límites con:
ulimit -r -l
Nos tiene que salir algo como:
real-time priority (-r) 99
max locked memory (kbytes, -l) unlimited
¡¡¡CUIDADO!!!! COMPRUEBA ESTO EN LOCAL Y NO POR SSH, porque POR SSH PUEDE NO FUNCIONAR Y SÍ EN LOCAL.
En el caso de DROPBEAR, que es el servidor SSH que usamos nosotros, NO ESTÁ LINKADO con libpam, así que 
LOS SETTINGS DE limits.conf son directamente IGNORADOS SI NOS CONECTAMOS POR SSH si usas dropbear.

Puedes lanzar jackd a mano para que empieze a escuchar con:
jackd -R -P 70 -d alsa -r 48000 -n 2 -p 1024

--BLOQUE ERROR RECALCITRANTE--
SI TE DA UN ERROR COMO ESTE:
Cannot bind server to socket err = No such file or directory
Server channel open error
JackServer::Open failed with -1
..:SIGNIFICA QUE TE FALTA /dev/shm, ASÍ QUE DEBERÍAS TENER ESTO EN EL CUSTOM INIT SCRIPT QUE LEVANTA TU SISTEMA:

mkdir /dev/shm
mount -t tmpfs tmpfs /dev/shm
--FIN BLOQUE ERROR RECALCITRANTE--

También puedes lanzar retroarch compilado con soporte para jack y funciona muy bien, con una latencia por defecto de 21ms
que hasta donde yo sé no se puede cambiar porque la opción de la latencia de audio no hace nada, siempre son 21ms (lo dice retroarch al iniciarse
si no has silenciado todos los mensajes).
Y aunque la pudieras bajar da igual porque la latencia de audio que tienes viene dada por dispmanx, o sea, viene del vídeo, no se puede bajar más.
Con esos 21ms hay algo de cracking, así que mejor nos quedamos con el driver ALSA y ya.

UN SCRIPT PARA DETECTAR SI ESTAMOS EN UNA RPI
===========================================

if grep -q BCM2708 /proc/cpuinfo; then
        echo "Estamos en una Raspberry Pi"
fi

INSTALAR GCC 6.3 USANDO LOS REPOS DE STRETCH EN JESSIE (RASPBIAN)
================================================================

Actualizamos la lista de paquetes y los paquetes, estando aún en jessie:
sudo apt-get update
sudo apt-get upgrade

Cambiamos jessie por stretch en 
sudo vim /etc/apt/sources.list

Actualizamos la lista de paquetes a la de stretch:
sudo apt-get update

Instalamos gcc 6:
sudo apt-get install gcc-6 g++-6

Desisntalamos gcc 4.x:
sudo apt-get purge 4.9

Volvemos a poner jessie donde estaba stretch, y actualizamos a los índices de jessie:
sudo vim /etc/apt/sources.list
sudo apt-get update

TWIN, el gestor de ventanas para TTY
=============================

Clonamos su repo de:
https://github.com/cosmos72/twin

Instalamos esta dependencia previa si queremos ratón en la consola:
sudo apt-get install gpm libgpm-dev --no-install-recommends

Configuramos e instalamos:
CFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
./configure --prefix=/usr --enable-hw-tty=yes  --enable-hw-x11=no 
make -j4
sudo make install

Se activa el menú para moverse por él con el teclado con F12.

HEROES OF MIGHT AND MAGIC II (fheroes2) en Linux
================================================

Bajamos la última estable de:
https://github.com/ihhub/fheroes2/releases

Compilamos con:
WITHOUT_AUDIOCD=1 WITHOUT_XML=1 make -j4

Para Raspberry Pi 4:
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
WITHOUT_AUDIOCD=1 WITHOUT_XML=1 make -j4

SI TIENES MOVIMIENTO ERRÁTICO DEL RATÓN: Desconecta el mando USB.

Creamos ~/heroes2
Copiamos el ejecutable a ~/heroes2
Copiamos el directorio files que viene con los sources a ~/heroes2, quedando ~/heroes2/files
Copiamos el archivo heroes2.key que viene con los sources a ~/heroes2
Creamos ~/heroes2/data y metemos ahí el contenido de DATA de una instalación del Heroes 2 de GOG
Creamos ~/heroes2/maps y metemos ahí el contenido de MAPS de una instalación del Heroes 2 de GOG
Copiamos los .ogg que vienen en MUSIC de una instalación del Heroes 2 de GOG a ~/heroes2/music (los de GOG vienen desordenados,
ya que van de 01 a 42 y deberían ir de 02 a 43! Es sólo moverlas una posición adelante todas al renombrarlas, que tienes que renombrarlas a Track02.ogg, Track03.ogg, etc).
(No hace falta que les cambies el nombre ni nada, con que lleven en el nombre el número de pista, le vale).

El fichero de configuración es ~/.config/fheroes2/fheroes2.cfg
Se genera cuando ejecutas el engine por primera vez.
Ahí puedes ponerlo a pantalla completa, activar el vsync, hacer que no salga la cutre-intro con "show game intro = off", etc.

LIBOPENAL en la Raspberry Pi
============================

Por si alguna vez lo necesitas para algo.
Bajamos la última release de: https://github.com/kcat/openal-soft/tags
Configuramos así:
cmake -DCMAKE_BUILD_TYPE=Release -DALSOFT_BACKEND_OSS=OFF -DALSOFT_BACKEND_WAVE=OFF -DALSOFT_EXAMPLES=OFF \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..

STUNT CAR RACER EN LA RASPBERRY PI
==================================

Instalamos una dependencia previa (a parte de openal, justo encima lo tienes):
sudo apt-get install libglm-dev

Clonamos el repo de 
git clone --depth 1 https://github.com/ptitSeb/stuntcarremake.git

Añadimos en StuntCarRacer.cpp, debajo de la llamada a SDL_SetWindowTitle:
SDL_GL_SetSwapInterval(1);

Compilamos con:
make -j4 LINUX=1 SDL=2 DEBUG=0

ELDRITCH en la Raspberry Pi
===========================

Clonamos su repo:
git clone --depth 1 https://github.com/ptitSeb/Eldritch.git

Creamos el directorio de compilación, entramos, configuramos y compilamos:
mkdir Code/b4
cd Code/b4
cmake -DGLES=ON -DWITH_SDL2=on -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
make -j4

Para instalar el juego:
-Copia b4/Projects/Eld/Eld a ~/eldritch
-Copia los datos del juego (que los tienes ya preparados en el disco duro de backup) junto con el ejecutable.

SI TIENES QUE PRERARAR DE NUEVO LOS DATOS DEL JUEGO...(COSA QUE NO DEBERÍA PASAR)
Para preparar los datos del juego, tenemos que obtener el directorio Config, que tiene unos archivos .ccf dentro.
-Bájate la versión "Eldritch Reanimated 406". Instálala, y copia los archivos eldritch*.cpk a ~/eldritch. Todos.
-Cópiate eldritch-base.cpk a algún directorio de trabajo junto con la herramienta FilePacker.exe, que viene incluida con los sources
 en Eldritch/Projects/Eld/Tools/unpack.
 Descomprime eldritch-base.cpk así: wine FilePacker.exe -u eldritch-base.cpk
 Obtendrás los directorios Config, Fonts, Misc, y Shaders. Copia el directorio Config (SÓLO ESE) a ~/eldritch, junto con el ejecutable del juego.

OTRAS NOTAS 
CUIDADO porque este juego carga manualmente libSDL2.so en Code/Libraries/SoLoud/src/backend/sdl/soloud_sdl_dll.c,
en la función openDLL(). Así que si no arranca, fíjate que tu libSDL2.so (que es un link simbólico) esté apuntando
a una librería que realmente exista en el sistema (a veces hay lio con esto porque en Lubuntu desinstalas malamente
las SDL2 que vienen e instalas las tuyas para desarrollo, etc).

GZDOOM (LZDOOM) en la Raspberry Pi
==================================

-Primero, necesita OpenAL. Tienes las instrucciones de instalación en este documento.

-Segundo, necesita ZMUSIC. Vamos con ZMUSIC pues:
Instala libmpg123-dev y libvorbis-dev.
Descarla los últimos sources estables de:
https://github.com/coelckers/ZMusic/releases

Creamos el directorio de compilación, entramos y configuramos, compilamos e instalamos:
mkdir b4
cd b4
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"
make -j4
sudo make install

Vamos a por LZDoom en sí.
GZDoom usa OpenGL incluso en modo hardware, así que no va en la Pi. Usa el branch LZDOOM (Legacy ZDoom), que usa GLES2:

git clone --depth 1 https://github.com/drfrag666/gzdoom.git

https://forum.zdoom.org/viewtopic.php?f=1&t=66675&start=30

Puedes añadir 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
SDL_ShowCursor(SDL_DISABLE);
en
src/common/platform/posix/sdl/sdlglvideo.cpp
justo antes de SDL_CreateWindow(), como siempre.

También debes poner a SDL_FALSE las llamadas de SDL_ShowCursor() en vim src/common/platform/posix/sdl/i_gui.cpp

cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_BUILD_TYPE=Release ..

Y compilamos con make -j4

Tenemos que copiar, al directorio de ~/doom:
lzdoom
*.pk3
soundfonts

OJO! SI INTENTAS HACERLO FUNCIONAR EN VULKAN, mira los valores win_h y win_w en ~/.config/lzdoom/lzdoom.ini,
que se tienen que corresponder con un modo de vídeo soportado o KMSDRM_Vulkan_CreateSurface fallará.
(Viene puesto por defecto para crear una ventana de 1024x576... ¿Estamos locos o qué?)
Por ejemplo, si el modo nativo de tu monitor es 720p (1280x720), dejarías los valores win_w y win_h así:
win_w=1280
win_h=720
Y luego ya, dentro del juego, lo pones a 320x200.

Podemos elegir renderer pasándoselo al ejecutable así.
Para usar el renderer software, que SÍ funciona en la Pi:
./lzdoom +vid_preferbackend 2
Para usar el renderer Vulkan, tienes que establecer un tamaño de pantalla que corresponda a un modo de video soportado por el monitor. Lo puedes establecer en ~/.config/lzdoom/lzdoom.ini usando las variables win_h y win_w.
Y le pasarías este parámetro a lzdoom para que use el renderer Vulkan:
./lzdoom +vid_preferbackend 1
Queda pendiente investigar el setting de lzdoom.ini: gl_es

Para pasarle un wad externo, con música tracker por ejemplo, zdoom -file nesmus.wad

NETHACK EN LA RASPBERRY PI
==========================

Se instala con:

sudo apt-get install nethack-common

Ahora creamos el fichero ~/.nethackrc con el contenido:
OPTIONS=name:Manuel
OPTIONS=number_pad:1

Eso es para que el jugador se llame Manuel, y que se use el numpad para jugar con diagonales y todo: las flechas no se deben usar
porque Nethack necesita que nos movamos en diagonal (o se gasta comida innecesariamente y no se puede ganar).

Para salir del juego, pulsa #, escribe quit, y dale al intro.

DUNGEON CRAWL STONE SOUP EN LA PI
=================================

Instalamos una dependencias previas (se puede compilar contra LUA o contra LUA-JIT, que es más rápido en la Pi):
sudo apt-get install libluajit-5.1-dev python3-yaml

Clonamos su repo (no se puede compilar desde release por el tema de las dependencias incluidas que lleva como submódulos):
git clone --depth 1 https://github.com/crawl/crawl.git
git submodule update --init

Descomprimimos y nos vamos al directorio crawl-ref/source, y compilamos con:
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
make -j4 TILES=y LUAJIT=y

Ahora creamos el directorio ~/crawl, y metemos allí el ejecutable "crawl"
Ahora copiamos el directorio "dat" que viene dentro de "sources" a ~/crawl

BARONY, UN DUNGEON CRAWLER 3D OPENSOURCE PARA LINUX
====================================================

Clonamos su repo o pillamos la última estable de:
https://github.com/TurningWheel/Barony

Instalamos una dependencia adicional que tiene:
sudo apt-get install libphysfs-dev rapidjson-dev --no-install-recommends

Editamos src/main.hpp y quitamos
#include <GL/glu.h>

Editamos CMakeLists.txt y cambiamos la línea
find_package(OpenGL REQUIRED)
que está debajo de 
ELSE (APPLE)
por esto:
	find_package(OpenGL QUIET)
	if(OpenGL_FOUND)
		message(STATUS "Using OpenGL GLX for OpenGL")
	else(OpenGL_FOUND)
		# If we couldn't find old GLX package, try to use modern libglvnd libOpenGL.so instead.
		message(STATUS "Using GLVND for OpenGL")
		FIND_LIBRARY(OpenGL_LIBRARY OpenGL)
		SET(EXTRA_LIBS ${OpenGL_LIBRARY})
    endif(OpenGL_FOUND)

Configuramos y compilamos con:
mkdir b4
cd b4
EDITOR_ENABLED=0 cmake -DCMAKE_BUILD_TYPE=Release -Wno-dev \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DFMOD_ENABLED=OFF -DOPENAL_ENABLED=ON  ..
make -j4

CSBWin, UN PORT DEL DUNGEON MASTER DE ATARI ST PARA LINUX
=========================================================

Esto lo lleva sin github Paul Stevens:
prsteven@facstaff.wisc.edu

Bajamos los últimos sources estables de aquí:
http://dianneandpaul.net/CSBwin/
Son los ficheros con nombre CSBwin_SRC_*, baja el de fecha más reciente.

Tiene un Makefile que se llama makefile, en minúsculas.

Editamos LinCSBUI.cpp y:
-Hacemos que la función LIN_PlaySound retorne SDL_TRUE (MUY importante, porque si no da un segfault al entrar en la mazmorra)
-Añadimos, antes de RenderCopy(), SDL_RenderClear(sdlRenderer);
Editamos CSBlinux.cpp y:
-Añadimos SDL_RENDERER_PRESENTVSYNC a los flags de SDL_CreateRenderer()
-Añadimos 
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
 antes de SDL_CreateWindow()

Editamos makefile y añadimos en el options de "ifeq ($(target), Ubuntu_SDL20)"
-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Compilamos con:
make target=Ubuntu_SDL20 -j4

Necesitamos los ficheros:
dungeon.dat
graphics.dat
..que los podemos bajar de alguna release compilada de http://dianneandpaul.net/CSBwin/

Ejecutamos con:
./CSBwin --fullscreen

CRISPY DOOM
============

Primero instalamos una dependencia suya para que pre-convierta TODOS los efectos de sonido y así el juego no pegue tirones:
sudo apt-get install --no-install-recommends libsamplerate0-dev

Nos bajamos la última estable de:
https://github.com/fabiangreffrath/crispy-doom/releases

Reemplazamos en src/i_video.c  todas las ocurrencias de
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
por
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");

Tenemos dos métodos para compilarlo:

USANDO CMAKE (RECOMENDADO):
mkdir b4
cd b4
cmake -DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -fsigned-char" \
-DCMAKE_BUILD_TYPE=Release ..
make -j4

USANDO MAKE (RECOMENDADO SI FALLA CMAKE):
Editamos configure.ac, quitamos el -g de los CFLAGS, ejecutamos ./autogen.sh,
y a continuación configuramos y compilamos:
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -fsigned-char" ./configure
make -j4

El fichero de configuración está en ~/.local/share/crispy-doom/crispy-doom.cfg

Para que la música digital vaya, nos bajamos un pack (de OGG, de FLAC o de lo que queramos y SDL_Mixer() tenga soporte para reproducir)
y lo mandamos, por ejemplo, a ~/heretic/heretic-music, dejando ahí los OGG o los FLAC tirados sin más.
Ahora editamos ~/.local/share/crispy-doom/crispy-heretic.cfg y en el setting music_pack_path ponemos el path: "/home/pi/heretic/heretic-music"
(O el que sea, vamos).
Vengo usando estas músicas, que están en OGG directamente para bajar:
https://zandronum.com/forum/viewtopic.php?t=97
FÍJATE BIEN QUE AL PRINCIPIO DIGA: "Pre-caching all sounds..."

MONITORIZAR ACCESO A FICHEROS EN GNU/LINUX
===========================================

Instalamos inotify-tools si no las tienes:

sudo apt-get install inotify-tools

Y ahora, si queremos ver todos los accesos a archivos de $HOME, por ejemplo...:
inotifywait -r -m $HOME

Otra alternativa es iotop
sudo apt-get install iotop

Nos permite ver cuánto se ha escrito en disco, estadísticas después de dejarlo correr minutos u horas, etc:
iotop -oPa

XASH3D, ENGINE DE HALF LIFE EN LA RASPBERRY PI
=============================================

Clonamos el repo de:
git clone --depth 1 https://github.com/FWGS/xash3d.git

cd source
Editamos el Makefile.linux y ponemos la línea XASH_X11 ?= 1 a 0, así:
XASH_X11 ?= 0
Ahora compilamos:
make -f Makefile.linux NANO_GL=1 XASH_VGUI=0 -j4

OpenDUNE
=========

Empezamos con los sources del munt (emulador de mt32):
Clonamos de:
https://github.com/munt/munt.git

Ahora entramos en munt/

Ahora, vamos a por el OpenDUNE en sí.
Bajamos los últimos sources de:
https://github.com/OpenDUNE/OpenDUNE.git

Configuramos con:
./configure --with-asound --without-oss --without-pulse --with-sdl2 --with-munt

NOTAS TIMIDITY
==============

Para inicializarlo y que suenen a ritmo las percusiones, necesitamos los buffers más pequeños posibles, para lo que hacemos:

timidity -iA -B 4,8

Su fichero de configuración, donde le especificamos el soundfont, está en /etc/timidity++/timidity.cfg
Ahí le podemos pasar, o bien un cfg y una ruta:

dir /usr/share/timidity/freepats
source /etc/timidity++/freepats/freepats.cfg

...O bien un sounfont:

soundfont /usr/share/soundfonts/FluidR3_GM2-2.sf2

Para fluidsynth haríamos algo como:

sudo fluidsynth --audio-driver=alsa -s Downloads/WeedsGM3.sf2

INSTALAR VARIOS SISTEMAS OPERATIVOS EN LA RASPBERRY PI SIN DHCP, USANDO IP ESTÁTICA
================================================================================

Usamos NOOBS (nos vale tanto la version light esa como la completa) pero hacemos algunas modificaciones a capón.
Arrancamos el NOOBS este y nos vamos a la consola TTY2 con CTRL+ALT+F2
Nos logueamos con root/raspberry

killall recovery

Tendremos disponible el vi, no el vim, pero nos vale.
Hacemos
		ip addr add 192.168.5.8/24 dev eth0
		ip route add default via 192.168.5.7	
Dejamos /etc/resolv.conf como:
		nameserver 8.8.8.8
Pingamos a google a ver si va.
Si tira, hacemos:

/usr/bin/recovery –qws

Listo! Nos dirá no sé qué de un sistema de settings corruptos: ni puto caso.

Para modificar el cmdline.txt o el config.txt, tienes que usar shift en el menú de arranque NOOBS, y te saldrán opciones para modificar
los ficheros de configuración de cada SO instalado. Así es como se overclockea la CPU y tal.

Para modificar el órden en que aparecen los OSes en el menú de arranque, editamos  installed_os.json que está en la partición SETTINGS, 
que en mi caso es /dev/mmcblk0p5

Para modificar el SO que arranca por defecto, editamos noobs.conf que está en una de las particiones, la llamada SETTINGS. En mi caso es /dev/mmcblk0p5
La monto desde la Pi por ssh:
sudo mount /dev/mmcblk0p5 /mnt/hdd
Y hago lo que tengo que hacer. ¡¡OJO: DESDE EL PC NO DEJA GUARDAR ESTE ARCHIVO CON SUS CAMBIOS!!
Podemos ver qué sistema arranca de qué partición consultando installed_os.json en ese misma partición. 

PARA PASAR un rootfs de Linux desde otra tarjeta, usa "rsync -av --progress <dir_orígen>/* <dir_destino>", NO USES CP -R QUE LA LIAS CON LOS PROPIETARIOS!!

COPIA DE SEGURIDAD DE UN ROOTFS, COMO EN TIEMPOS DE GENTOO!
===========================================================

Un poco de revival del 2004... Para sacar un tar del rootfs, estando en él y dejando fuera algunos directorios grandes:

sudo tar -cvpf ~/pi/cea0b7ae-2fbc-4f01-8884-3cb5884c8bb7.tar * --exclude=proc/* --exclude=sys/* --exclude=dev/pts/* --exclude=home/pi/scummvm/* --exclude=home/pi/retro/* --exclude=home/pi/src/*

Ahora, para descomprimirlo en una partición de una SD:

sudo tar -xvf cea0b7ae-2fbc-4f01-8884-3cb5884c8bb7.tar -C /media/manuel/root/

ARRANCAR LA RASPBERRY PI CON VÍDEO KMS
=======================================

Simplemente añadimos esta línea a config.txt:

dtoverlay=vc4-kms-v3d

Luego, instalamos libdrm-dev, y copiamos /usr/include/libdrm a /usr/include/drm, para que las cabeceras las encuentren bien los ejemplos (no se arregla pasando -I<ruta> ya
que depende de cabeceras que no son nuestras y en las que vienen mal las rutas), y la podemos hacer funcionar mi ejemplo 2D-KMS de atomix pageflipping.

Tenemos que instalar:
libgl1-mesa-dev
libdrm-dev
libgbm-dev
libgles2-mesa-dev

sudo apt-get install libgl1-mesa-dev libdrm-dev libgbm-dev libgles2-mesa-dev

..y el KMSCUBE original de robclark, tras añadir VC4 a la lista de drivers, tira perfectamente.

CARGAR TAP DE SPECTRUM DESDE LINUX
====================================

Lo primero cargamos el OSS:

sudo modprobe snd-pcm-oss
sudo modprobe snd_hda_intel

Ahora buscamos los sources del "playtap", tal cual, compilamos con el Makefile.linux, y hacemos
./playtap juego.tap 

Justo cuando empiece a sonar bajamos el sonido con el control de volúmen normal, como a 3/4 que si no suena muy alto y falla.

CÓMO LOGUEARSE AL SVN DE RETROGURU Y CLONAR REPOS, Y LUEGO GUARDAR LOS CAMBIOS QUE HAGAS
==============================================================================================

Lo primero es autentificarse, sólo hay que hacerlo la primera vez:
(El password es uno de los típicos que usas, tiene letras y números)
cvs -d:pserver:vanfanel@sun.hasenbraten.de:/usr/src/cvs login
El pass es: Manuel22

Y luego ya clonar el proyecto giana, por ejemplo:
cvs -d:pserver:vanfanel@sun.hasenbraten.de:/usr/src/cvs checkout giana

Una vez hechos los cambios, metemos los nuevos ficheros con
cvs add <nombre_fichero>

Si tenemos nuevos ficheros, directorios, etc, hacemos estos dos pasos porque CVS es muy espartano con esto, no hay equivalente a "git add ."
find . -type d \! -name CVS -exec cvs add '{}' \;
find . \( -type d -name CVS -prune \) -o \( -type f -exec cvs add '{}' \; \)

Y guardamos los cambios en el server con
cvs commit

COMPILAR GIANA SISTERS RETURN
==============================

Lo primero es compilar libmodplug:

O bien clonamos la última versión...
git clone --depth 1 https://github.com/Konstanty/libmodplug.git
autoreconf -i
 ./configure --enable-static

O bien usamos la 0.87 que traen los sources de los juegos, ya que en algunos casos la última versión no es compatible
CXXFLAGS="-fpermissive" ./configure --enable-static
make -j8

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
./configure --enable-static

Buscamos libmodplug.a
find ./ -name 'libmodplug.a'
Y lo copiamos a la raiz de los sources del giana.
Así mismo, copiamos el directorio de los sources de libmodplug (llamado así, libmodplug) a la raiz de los sources del giana, porque necesita headers que buscará ahí.

Ahora, si vamos a compilar en Linux de 64 bits, tenemos que usar estos flags en nuestro Makefile, que son de Makefile_ubuntu64:
CFLAGS = $(INCLUDES) -DMODPLUG -DLINUX $(OPTIM) -Wall -DFADEINOUT -DLINUX64 -DHOME_DIR
...de lo contrario, el ejecutable resultante nos medio peta el sistema y da errores raros.

Si nos da errores de "undefined symbol" con funciones como initFPS() en main.c, añadimos fpshelper.o a nuestro Makefile en la sección de OBJS 

PARA ARREGLAR lo de la transparencia de la estrella cuando cogemos un powerup, añade:
    SDL_SetSurfaceBlendMode(scrback, SDL_BLENDMODE_BLEND);
    SDL_SetSurfaceBlendMode(star, SDL_BLENDMODE_BLEND);
justo antes de donde sea que hagas:
    SDL_SetSurfaceAlphaMod(scrback,192);
    SDL_SetSurfaceAlphaMod(star,128);
...porque estás estableciendo un nivel de transparencia sin haber dicho que quieres que esa surface sea transparente en el proceso de blitting para empezar.

Debes copiar el directorio data que viene con los sources al directorio donde metas el ejecutable.
El fichero de configuración lo crea en ~/.giana/giana.cfg.
Puedes poner ahí fast=1 para que no tengas que ver la intro, elegir idioma y todo eso.
Puedes pasarle al ejecutable  "-fs -aspect" para conservar el aspect ratio.

HURRICAN, EL TURRICAN DE LINUX
==============================

Empezamos por su dependencia libepoxy, que la tenemos que compilar a mano porque la que viene en DEBIAN depende de X11
y toda su basura:
Bajamos la última versión estable de libepoxy desde:
https://github.com/anholt/libepoxy/releases

Configuramos, compilamos e instalamos:
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dx11=false ..
ninja -j4
sudo ninja install

AHORA VAMOS CON EL HURRICAN EN SÍ:
Clonamos su repo:
git clone --depth 1 --recurse-submodules https://github.com/drfiemost/Hurrican.git
cd Hurrican/Hurrican
Configuramos y compilamos:
mkdir b4
cd b4
cmake -DCMAKE_BUILD_TYPE=Release -DRENDERER=GLES2 \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..
(Hay otros renderers disponibles, mira en el README)
make -j4 

Creamos el directorio ~/hurrican, y allí copiamos el ejecutable, junto con los directorios data y lang, que vienen con los sources.

AUDIO POR I2C: EL PI TOP SPEAKER
================================

Lo primero es saber que el pi top speaker (pts de ahora en adelante) va por i2c pillando el sonido del hdmi.
Para que el i2c funcione, tenemos que tener estos módulos cargados:

snd_bcm2835
i2c_bcm2835
i2c_dev

Para ello, en config.txt añade:

dtparam=i2c1=on
dtparam=i2c_arm=on

Y luego a parte en /etc/modules añade:
i2c_dev

Reiniciamos, y probamos que detecta el dispositivo en el i2c:

sudo i2cdetect -y 1

Si el i2cdetect no encuentra /dev/i2c-1, es que nos falta algo de los módulos. El pts debería estar en el 73 en la tabla que nos sale.

MPV, ALTERNATIVA A OMXPLAYER EN LA PI
=====================================

El MPV tiene video output a KMS/DRM con --vo drm, y a la vez, por otra parte, decoding de vídeo por hardware usando mmal con -vd=lavc:h264_mmal
El decoding usando mmal se hace mediante una versión de ffmpeg que tenga habilitada aceleración de mmal para Raspberry Pi.
O sea, que lo primero es conseguir una versión de ffmpeg con aceleración mmal para Rpi.

Ahora vamos a por ffmpeg:

git clone --depth 1 https://git.ffmpeg.org/ffmpeg.git
Y luego configurando con:
./configure --enable-mmal --disable-debug --enable-shared

Para comprobar que nuestro ffmpeg tiene aceleración mmal para Rpi, haz:
ffmpeg -codecs

Antes de compilar mpv, tenemos que compilar e instalar libass. La versión de libass que hace falta no viene en Raspbian, así que clonamos, compilamos e instalamos esto:
git clone --depth 1 https://github.com/libass/libass.git

Otras librerías que nos hacen falta son: libavutil libavcodec libavformat libswscale libavfilter y bien:
libswresample o bien libavresample (son la misma librería y se instalan al instalar ffmpeg, creo)

Ahora compilamos mpv con soporte para egl/drm:
./bootstrap.py
./waf configure --help
./waf configure --enable-egl-drm --disable-x11 --disable-oss
./waf
./waf install

Si tenemos todo, se debería poder hacer algo como:
mpv --vd=lavc:h264_mmal --vo=drm somefile.mp4
...y debería ir genial.
Debemos tener
lavc:h264_mmal
en la lista de decoders si hacemos:
mpv --vd=help

SELECCIONAR LA SALIDA DE AUDIO CON MPV
======================================

Podemos ver los dispositivos de salida con: mpv --audio-device=help
Y elegit el que queramos de la lista con: mpv --audio-device=<NOMBRE_DISPOSITIVO>

PROBLEMA: UN PROGRAMA NO ENCUENTRA UNA LIBRERÍA QUE SÍ ESTÁ INSTALADA Y CONTRA LA QUE SE HA LINKADO DINÁMICAMENTE SIN PROBLEMAS
================================================================================================================================

Vemos con ldd <nombre_ejecutable> que busca una librería que sí está instalada en /usr/local/...etc
Pues limpiamos la caché de ld:

sudo rm /etc/ld.so.cache
sudo ldconfig

Y ya debería ver la librería que le faltaba con ldd <nombre_ejecutable>

NOTAS HIFIBERRY
===============

En Debian Stretch, las cosas se han complicado ligeramente para poner a funcionar bien la HIFIBERRY DAC+, así que aquí voy a poner algunas notas.
Para que funcione perfectamente:
****En config.txt, mira que tengas estas cosas:***
-Comentada la línea
#dtparam=audio=on

-Añadidas las líneas:
dtoverlay=i2s-mmap
dtoverlay=hifiberry-dacplus

(!!!!!!!!!!!)Ahora, asegúrate de que, además de los módulos típicos, tengas, según lsmod, un módulo llamado "fixed". Si no, ve y quítalo de blacklist.conf...

Ahora, deberías poder ver la tarjeta con "aplay -L" y ver los controles de volúmen y ajustes de la hifiberry con "alsamixer".
Pero puede que alsamixer no guarde los cambios entre reinicios: esto es porque el servicio "alsa-restore.service" falla, lo que puedes comprobar
con "sudo systemctl status alsa-restore.service".
Y falla porque no se cumple la condición de que exista "/dev/snd/control*" cuando se intenta cargar alsa-restore.service
Si editamos completamente el unit del servicio alsa-restore.service ("sudo systemctl edit --full alsa-restore.service"), vemos que tiene la condición:
ConditionPathExistsGlob=/dev/snd/control*
...que es la que está fallando.
Pues bien: vamos a quitar esa condición. Para ello, editamos un "override" del unit, no el unit en sí (ya que esto se perdería al actualizar el sistema...).
Lo editamos con:
sudo systemctl edit alsa-restore.service
Y simplemente añadimos esa condition pero "en blanco":

[Unit]
ConditionPathExistsGlob=

Salvamos, reiniciamos, y alsamixer debería restaurar los niveles sin problemas. Comprueba que "systemctl status alsa-restore.service" se ha iniciado correctamente ahora.

CONVERTIR VÍDEO MPEG2 A MENOS RESOLUCIÓN SIN PERDER CALIDAD
============================================================

El vídeo de entrada era de 1440x1080, así que lo convierto a 720x540, que es exactamente la mitad, y así mantengo el aspect ratio.

ffmpeg -i maddog.m2v -an -qscale:v 10 -vf scale=720:540 -codec:v mpeg2video maddogsd.m2v

La parte de "-qscale:v 10" es para un variable bitrate de calidad 4 (1 es la máxima, 31 la mínima).
Podríamos, en lugar de eso, usar "-b:v 3000k" para un bitrate constante máximo de 3000k.
(OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).

Más información: https://trac.ffmpeg.org/wiki/Encode/MPEG-4
Más ejemplos en: https://github.com/DirtBagXon/hypseus_singe_data
Más juegos: https://archive.org/details/@dirtbagxon

FFMPEG con aceleración MMAL en aarch64
======================================

Este hilo tiene información muy interesante:

https://github.com/raspberrypi/userland/pull/586

Se supone que hay que compilar ffmpeg con soporte para mmal.

MMAL es parte del userland de la Pi, que está en:

https://github.com/raspberrypi/userland

EMPEZAMOS:

Clonamos el repo:

git clone --depth 1 https://git.ffmpeg.org/ffmpeg.git

Puedes probal a reproducir un vídeo con:

ffplay -vcodec h264_mmal -i test.mkv

SINGE, el sistema de LASERDISC libre y abierto
==============================================

Su página oficial es:
https://kangaroopunch.com/?page=Software%2F3000-2006-singe.xjs&fbclid=IwAR2eZxtVnzNR7bZWKozmVLAb6NDcVN3bpKAIDicZbavUl72N35nGW9i_00I

El código fuente está en:
https://skunkworks.kangaroopunch.com/skunkworks/singe

Aquí hay más juegos a parte de los de la página oficial:
http://www.emuline.org/topic/2134-singe-2-new-laserdisc-engine-games-031220-final-update/

EMPEZEMOS!

Lo primero sería compilar ffmpeg con soporte de mmal. Podemos probar que funciona con:

ffplay -vcodec h264_mmal -i test.mkv

Clonamos su repo:
git clone --depth 1 https://skunkworks.kangaroopunch.com/skunkworks/singe.git

PROGRAMAS Y JUEGOS XNA EN LINUX, CON FNA
========================================

XNA es una plataforma para desarrollar programas en C# de Micro$oft.
Quedó abandonada, y el proyecto FNA nos permite ejecutar programas XNA en sistemas actuales.
Las versiones de juegos que podemos ejecutar son las que tienen soporte FNA (no las viejas XNA) así que siempre tienen que traer un FNA.dll
incluido con el juego.

Los juegos son independientes de la plataforma, PERO el mono-runtime y las librerías nativas (SDL2, libmojoshaders, etc)
sí que dependen de la plataforma.

NO HAY QUE INSTALAR NADA DEL PROYECTO FNA, SIMPLEMENTE LOS JUEGOS VAN CON MONO SI LES DAS LAS LIBRERÍAS NECESARIAS.
SE EJECUTAN SIMPLEMENTE CON: mono <juego.exe>

Instalamos mono-runtime y el compilador de mono (FNA está escrito en C#):
sudo apt-get install mono-runtime mono-mcs --no-install-recommends
(EN SU LUGAR, se podría usar monokickstart, que es un monoruntime auto-contenido y que lo renombras como el juego
y te lanza el juego que sea:
https://github.com/flibitijibibo/MonoKickstart)

AHORA VAMOS "RECOLECTANDO" LAS LIBRERÍAS QUE USAN LOS JUEGOS, QUE LAS NECESITAS PARA AARCH64

1--LIBFNA Y SUS SUB-LIBRERÍAS (UNA SUB-LIBRERÍA DE FNA, LLAMADA FNA3D, INCLUYE LIBMOJOSHADER ESTÁTICAMENTE LINKADA.
LIBMOJOSHADER NO VENÍA INCLUIDO NO VENÍA INCLUÍDO, Y POR ESO LO TRAEN ALGUNOS JUEGOS COMO UN .SO A PARTE,
QUE YA NO ES NECESARIO PORQUE AHORA FORMA PARTE DE FNA3D, QUE ES PARTE DE FNA COMO VAMOS A VER
Así que NUNCA te pongas a compilar libmojoshader...).

LO PRIMERO es conseguir nuestro propio y actualizado FNA.dll + FNA.dll.config.
ESTA ES LA LIBRERÍA "CENTRAL", independiente del sistema, que hace que se llame a librerías .so dependientes del sistema,
así que al actualizar FNA.dll + FNA.dll.config conseguimos tener el control de qué .so se necesitan.

Los juegos suelen traer su propio FNA.dll, y de hecho el FNA.dll es el mismo en todas las arquitecturas,
pero nos conviene compilar TODO EL ECOSISTEMA FNA, ya que algunas sub-librerías de FNA pueden necesitar cambios.
(Por ejemplo, BASTION sólo funciona tras parchear FNA3D, como veremos, que es una sub-librería de FNA).

Clonamos su repo:
git clone --depth 1 https://github.com/FNA-XNA/FNA.git
git submodule update --init --recursive

Compilamos con:
make release -j4

Nos deja el FNA.dll y FNA.dll.config en bin/Release/
Los copiamos al directorio del juego, sobreescribiendo los que trae.

Ahora tenemos que entrar en cada uno de los directorios de las sub-librerías de FNA,
que están en FNA/libs, e ir compilándolas una a una, y copiándolas donde estaban las librerías incluidas con el juego
que queremos correr:
(FÍJATE que los .so van al directorio de las librerías dependientes del sistema, en este caso llamado "lib64",
pero que las .dll van al mismo directorio que el ejecutable del juego... Esto no sé si es así siempre, pero al menos
para el BASTION funciona así)

	-Entramos en lib/FAudio y hacemos:
		mkidir b4
		cd b4

		cmake .. -DCMAKE_BUILD_TYPE=Release \
		-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

		cp libFAudio.so* ~/bastion/game/lib64/

	-(OPCIONAL: ESTO ES UN HACK Y SÓLO ES PARA BASTION Y NO VA BIEN, QUEDA AQUÍ CON FINES DOCUMENTALES, PERO NO LO HAGAS)
	Entramos en FNA3D (que incluye libmojoshader estáticamente linkado así que NO hay que compilar libmojoshader a parte) y hacemos:
		-Editamos lib/FNA3D/src/FNA3D_Driver_OpenGL.c, nos vamos a "static int32_t XNAToGL_TextureInternalFormat[]"
		y cambiamos GL_RGB5_A1, GL_RGBA4 y GL_RGBA8 por GL_BGRA.
		(Sí, GL_BGRA aparecerá varias veces en la matriz, no hay problema, es lo que queremos: que aparezca GL_BGRA
		en vez de GL_RGB5_A1, GL_RGBA4 y GL_RGBA8).
		-Compilamos con:
		mkdir b4
		cd b4

		cmake .. -DCMAKE_BUILD_TYPE=Release \
		-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"
		
		cp libFNA3D.so* ~/bastion/game/lib64/

	-Entramos en lib/SDL2-CS y hacemos:
		make release -j4
		cp bin/Release/SDL2-CS.dll* ~/bastion/game/

	-Entramos en lib/Theorafile y hacemos:
		CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" make -j4
		cp libtheorafile.so* ~/bastion/game/lib64/

2--PIPEWIRE
En la Raspberry Pi, usando el dispositivo de audio vc4-hdmi, NO funciona DMIX por el tema del formato extraño que soporta vc4-hdmi.
Eso es un problema para los juegos FNA ya que abren varias veces el mismo dispositivo de audio, cosa imposible sin DMIX ya que no
se pueden reproducir varios streams de audio a la vez.
Por ello, al no tener DMIX en ALSA, necesitamos un servidor de audio que mezcle los diferentes streams de audio de los juegos.
Ese servidor de audio es PIPEWIRE.

Lo que necesitamos es compilar SDL2 para que use PIPEWIRE en lugar de ALSA directamente.
Con instalar esto sería suficiente, en teoría, y luego reconfigurar y recompilar SDL2:
sudo apt-get install libpipewire-0.3-dev
...PERO EN DEBIAN 11 ESTO NO ES POSIBLE, PORQUE SÓLO TIENE HASTA PIPEWIRE 0.3.19 Y SDL2 NECESITA PIPEWIRE 0.3.20 MÍNIMO.
(O sea que cuando salga Debian 12, simplemente instalaremos libpipewire y recompilaremos SDL2, y ya podremos
borrar el siguiente bloque).

---BLOQUE PARA COMPILAR PIPEWIRE A MANO EN DEBIAN 11 BULLSEYE---
Dependencias previas:
sudo apt-get install libdbus-1-dev

Lo primero es instalar los últimos MESON y NINJA, porque los que trae DEBIAN 11 BULLSEYE son viejos y las versiones
actuales de pipewire necesitan versiones actuales para compilar:
sudo apt-ger purge ninja meson
sudo apt install python3-pip --no-install-recommends
python3 -m pip install ninja
python3 -m pip install meson

Nos bajamos la última release de aquí:
https://gitlab.freedesktop.org/pipewire/pipewire/-/releases

Configuramos y compilamos con meson así:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
meson -Dgstreamer=disabled -Dbluez5=disabled -Djack=disabled -Dpipewire-jack=disabled \
-Dv4l2=disabled -Dpipewire-v4l2=disabled -Dudev=disabled -Dman=disabled ..

ninja -j4
sudo ninja install
sudo rm /etc/ld.so.cache
sudo ldconfig
(OJO!!! SIEMPRE regenera la caché de librerías después de instalar!!)

Ahora editamos /usr/local/share/pipewire/minimal.conf, y comentamos el dispositivo "source" (porque la Pi no tiene
dispositivo de grabación, y si no lo comentamos da error).

Ahora, en una TTY lanzamos Pipewire:
XDG_RUNTIME_DIR=/tmp pipewire -v -c /usr/local/share/pipewire/minimal.conf

En otra TTY lanzamos el juego:
PIPEWIRE_LOG_SYSTEMD=false PIPEWIRE_DEBUG=3 XDG_RUNTIME_DIR=/tmp SDL_AUDIODRIVER=pipewire ./prince.bin

Y en otra TTY vemos las conexiones que podemos hacer:
XDG_RUNTIME_DIR=/tmp pw-link -o
..O consultamos tw-dump:
XDG_RUNTIME_DIR=/tmp pw-dump

---FIN BLOQUE PARA COMPILAR PIPEWIRE A MANO EN DEBIAN 11----

Ahora para ejecutar pipewire:
export XDG_RUNTIME_DIR=/tmp
pipewire
..Y ya podemos lanzar un programa SDL2 usando el backend pipewire con:
SDL_AUDIODRIVER=pipewire ./programa

3--LIBFMODEX
Algunos juegos necesitan FMODEX, que es una librería cerrada.
EL PROBLEMA es que los juegos usan FMODEX, que es antigua, pero sólo FMOD está para descargar para aach64.
FMOD es la versión moderna de FMODEX.
Puedes descargar FMOD de aquí para tu arquitectura.
https://www.fmod.com/download
COMO HEMOS DICHO, LOS JUEGOS USAN FMODEX EN VEZ DE FMOD, ASÍ QUE AQUÍ TENEMOS UN WRAPPER PARA TENER FMODEX... SOBRE FMOD!!!
...Y ASÍ ENGAÑAR A LOS JUEGOS:
https://github.com/ptitSeb/fakemodex
...Para usarlo, primero es copiar las librerías fmod para aarch64,
y luego usar el mencionado wrapper "fakemodex", tras compilarlo e instalarlo en el directorio de librerías del juego.

(NOTA: Aunque BASTION necesita FMODEX, en teoría, en algún momento será posibe lanzar BASTION en Pi4 sin usar FMODEX, con:
"LD_LIBRARY_PATH=lib64 mono Bastion.exe -usefnasound"
...Pero de momento, la versión GOG que es la que yo tengo comprada no soporta "-usefnasound".)


Para lanzar BASTION, versión Linux, por ejemplo, entramos en Game y hacemos:
LD_LIBRARY_PATH=lib64 mono Bastion.exe
(En lib64 tendríamos las librerías como SDL2, etc... compiladas para nuestra arquitectura.)
(También podríamos lanzar directamente Bastion.bin.x86_64 que es el monokickstart que sabe que tiene que pillar las librerías de lib64/).

OTROS JUEGOS DE FNA QUE FUNCIONAN BIEN EN LA PI:
https://bootdiskrevolution.itch.io/bleed
https://bootdiskrevolution.itch.io/bleed-2
https://www.gog.com/game/timespinner
https://www.gog.com/game/chasm
https://www.gog.com/en/game/owlboy
https://store.steampowered.com/app/1280300/Steel_Assault/
https://supergiant-games.itch.io/transistor

COMPILAR NUESTRA PROPIA VERSIÓN DE WPA_SUPPLICANT
=================================================

La versión que viene en Debian depende de systemd para funcionar (falla si no tenemos systemd corriendo),
así que para tener un sistema mínimo sin init necesitamos compilar nuestra propria versión de WPA_SUPPLICANT.

Las instrucciones para compilar wpa_supplicant desde sus sources se han obtenido de:
https://www.linuxfromscratch.org/blfs/view/svn/basicnet/wpa_supplicant.html

¡EMPEZEMOS!

Dependencias previas:
apt-get install libnl-3-dev libnl-genl-3-dev libreadline-dev 

Bajamos la última estable de aquí (busca "source" en esa página):
https://w1.fi/wpa_supplicant/

Descomprimimos, entramos en el directorio wpa_supplicant, y creamos un fichero de configuración para la compilación que contenga
las opciones básicas para poder establecer una conexión estándar:

cat > .config << "EOF"
CONFIG_BACKEND=file
CONFIG_CTRL_IFACE=y
CONFIG_DEBUG_FILE=n
CONFIG_DEBUG_SYSLOG=n
CONFIG_DRIVER_NL80211=y
CONFIG_DRIVER_WEXT=y
CONFIG_DRIVER_WIRED=y
CONFIG_EAP_GTC=y
CONFIG_EAP_LEAP=y
CONFIG_EAP_MD5=y
CONFIG_EAP_MSCHAPV2=y
CONFIG_EAP_OTP=y
CONFIG_EAP_PEAP=y
CONFIG_EAP_TLS=y
CONFIG_EAP_TTLS=y
CONFIG_IEEE8021X_EAPOL=y
CONFIG_IPV6=n
CONFIG_LIBNL32=y
CONFIG_PEERKEY=y
CONFIG_PKCS12=y
CONFIG_READLINE=y
CONFIG_SMARTCARD=n
CONFIG_WPS=n
CFLAGS += -I/usr/include/libnl3
EOF

PARA SABER QUÉ SIGNIFICA CADA OPCIÓN, EDITA EL FICHERO LLAMADO "defconfig" Y AHÍ VIENEN DESCRITAS TODAS.

Compilamos e instalamos con:
make BINDIR=/usr/local/sbin LIBDIR=/usr/local/lib -j4
make install

Para desinstalar, es a mano porque no hay uninstall, y se haría con:
rm /usr/local/sbin/wpa_*

GLEW EN LA RASPBERRY PI
=======================

GLEW es usado por los Sonic-1-2-2013 y SonicCD decompilation projects, por Scummvm para el render OpenGL de los juegos 3D
(NO para el modo OpenGL de los juegos 2D, y a parte para el render de los juegos 3D también se puede usar GLES2, así que
glew no es necesario ni para juegos 2D ni para aceleración de juegos 3D en Scummvm) y por otros programas que no recuerdo ahora. 

GLWE sólo conoce de OpenGL/ES, no sabe nada de sistemas de ventanas (X11, Wayland, KMSDRM).

Dependencias previas:

apt-get install python

Clonamos su repo:

git clone --depth 1 https://github.com/nigels-com/glew.git

Entramos en el raiz de los sources y hacemos:

make extensions

Y compilamos e instalamos con un solo comando, así:

CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
make SYSTEM=linux-egl-glvnd -j4 install

AHORA EDITA /usr/local/include/GL/glew.h y, o bien añade:
#define GLEW_NO_GLU 1
(Añádelo debajo de "#define GLEW_OK 0"
...O bien ELIMINA TODO EL BLOQUE GLU, es decir, busca "GLEW_NO_GLU" y elimina todo lo que hay en el bloque donde está eso.
SI NO HACES ESTO, los programas que usen GLEW los tienes que compilar siempre pasándole al compilador "-DGLEW_NO_GLU"

AMBERMOON.NET EN LINUX
======================

Necesitamos un sistema Wayland funcionando, e instalar GLFW.
Nos bajamos la última estable de GLFW de:
https://www.glfw.org/

Y configuramos, compilamos e instalamos GLFW:
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=1 -DGLFW_USE_WAYLAND=1 -DGLFW_BUILD_EXAMPLES=0 -DGLFW_BUILD_TESTS=0 \
-DCMAKE_C_FLAGS="-DEGL_NO_X11 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

make -j4
sudo make install

OPCIÓN 1: BAJARNOS LOS BINARIOS PRECOMPILADOS PARA AARCH64 Y USARLO DIRECTAMENTE:

Nos bajamos los últimos binarios compilados de:
https://github.com/Pyrdacor/Ambermoon.net/releases

OPCIÓN 2: COMPILARLO NOSOTROS

Clonamos su repo:

git clone --depth 1 https://github.com/Pyrdacor/Ambermoon.net.git

Nos bajamos el DOTNET SDK de nuestra arquitectura (NO hay que instalarlo). Se baja de:
https://dotnet.microsoft.com/download/dotnet/3.1
Hay dos descargas: el SDK y el RUNTIME. El SDK incluye el RUNTIME pero ocupa más. Para compilar, necesitamos el SDK,
y luego ya para jugar nos vale con el RUNTIME.

Entramos en el directorio del SDK y compilamos el proyecto Ambermoon.net con:
./dotnet build ~/src/Ambermoon.net/Ambermoon.net.sln --configuration Release

Copiamos el RUNTIME de dotnet al directorio de Ambermoon.net (el SDK completo no hace falta, pero funcionaría igual)
y ejecutamos el DLL con:
./dotnet Ambermoon.net/bin/Debug/netcoreapp3.1/Ambermoon.net.dll
(Alternativamente, podríamos ejecutar el projecto directamente sin compilar con: dotnet run -p Ambermoon.net/Ambermoon.net.csproj)
Podemos cambiar las opciones editando ambermoon.cfg

Tenemos que tener los .ADF (llamados Amber_a.adf, Amber_b.adf, etc...) en el mismo directorio que la DLL del juego.
Podemos descargarlos ya preparados desde: https://github.com/Pyrdacor/Ambermoon/tree/master/Disks/English

COMPILAR LA VERSIÓN MODERNA DE HYPSEUS (HYPSEUS-SINGE)
======================================================

Clonamos el repo (usando el branch RetroPie, esto es importante para que se use el libmpeg2 del sistema!):

git clone --depth 1 -b RetroPie https://github.com/DirtBagXon/hypseus-singe.git

Ahora, configuramos pasándole a CMAKE el directorio src desde nuestro directorio de compilación (OJO que esto es
distinto a como se suele hacer!!!):

mkdir b4
cd b4

cmake ../src -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

make -j4

Copia, al mismo directorio donde metas el ejecutable hypseus, los directorios fonts y pics.

Para poner un buffer de audio más pequeño, puedes pasar el parámetro -sound_buffer 1024
(Por defecto viene puesto 2048 que es mucho).

Para configurar el joystick:
Copia, al mismo directorio donde metas el ejecutable hypseus, el archivo docs/hypinput.ini,
y ahí, para configurar el joystick, fíjate en el formato de cada línea. Por ejemplo:
KEY_BUTTON1 = SDLK_LCTRL 0 0
..significa que el botón 1 del juego está en el botón 0 del mando (último campo).
Así que si queremos la espada en el botón 0 del mando, dejamos esa línea como:
KEY_BUTTON1 = SDLK_LCTRL 0 1
...ya que a los números de botón del mando hay que sumarle 1.
Los números de botón del mando los puedes sacar de jstest, del paquete de Debian llamado "joystick".
Recuerda que tienes que sumarle +1 a los números de botón que te da jstest!!!

Yo tengo las líneas relevantes así:
KEY_COIN1 = SDLK_5 0 7
KEY_COIN2 = SDLK_6 0 0
KEY_START1 = SDLK_1 0 8
KEY_START2 = SDLK_2 0 0
KEY_BUTTON1 = SDLK_LCTRL 0 1
KEY_BUTTON2 = SDLK_LALT 0 2
KEY_BUTTON3 = SDLK_SPACE 0 3

Los detalles sobre los dip switches están en dle21.txt, que acompaña a las roms del Dragon's Lair Enhanced 2.1
Recuerda que ahí se cuentan los switches del 0 al 7. Se empieza de derecha a izquierda a contar.
Por lo demás, el banco A es el 0, y el B es el 1.

Para lanzar juegos de SINGE (es decir, conversiones nativas), tenemos que meter el directorio del juego que sea dentro del directorio singe,
y luego pasarle como parámetros el framefile del juego (como en cualquier juego de daphne) y el script del juego singe.
Es decir, timegal quedaría metido en:
~/laserdisc/singe/timegal
Y luego lo ejecutaríamos como:
./hypseus singe vldp -framefile singe/timegal/timegal.txt -script singe/timegal/timegal.singe -fullscreen -nolog

Si quieres juegos SINGE con buena calidad, están aquí: https://archive.org/details/@dirtbagxon
Pero recuerda que si están en HD, como la Pi no descomprime mpeg2 por hardware, tienes que convetir su fichero de vídeo con algo como esto:

ffmpeg -i maddog.m2v -an -qscale:v 10 -vf scale=720:540 -codec:v mpeg2video maddogsd.m2v

(OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).

Lo ideal sería que ambas dimensiones de salida fueran divisoras de las originales.
Libmpeg2 no tiene forma de usar aceleración de descompresión de vídeo (la última version de libmpeg2 es de 2008 y no tiene ninguna
optimización para ARM: para tener aceleración sería con libffmpeg).

Para ajustar cosas del Maddog, puedes hacerlo durante el juego pulsando 9, o editando maddog.cfg

EL CARGADOR para el Maddog para evitar desincronizaciones de audio al principio, y con los parámetros necesariospara que vaya bien, es así:

LA CONVERSIÓN DE JUEGOS DE SINGE2 (TRON, Sucker Punch, etc) PARA LA RASPBERRY PI, QUE SON 1920x1080p
(CONSISTE EN DEJARLOS EN LA MITAD DE RESOLUCIÓN Y LA MITAD DE CALIDAD).

  PARA CONVERTIR EL TRON desde mp4 de 1920x1080 a m2v de 960x540, hacemos esto:
  ffmpeg -i TRON.mp4 -vf tpad=stop_mode=clone:stop_duration=2,scale=960:540 -qscale:v 10 -c:v mpeg2video tron.m2v
  ffmpeg -i TRON.mp4 -ss 00:00:00.33 -vn -c:a libvorbis -ar 44100 -map a -b:a 160k tron.ogg
  
  (OJO!!! si especificas la calidad con "-qscale:v 10", no especifiques el bitrate con "-b:v 3000k" o "-b:v 6000k", es calidad o bitrate constante,
  PERO NO AMBAS. Si especificases ambas, la calidad (-qscale) prevalece).
  
########################
#INICIO CARGARDO MADDOG#
########################

sync

# Send the code and the audio to the cache to avoid initial desync problems.
cat singe/maddog-hd/*.singe > /dev/null
cat singe/maddog-hd/*.ogg > /dev/null

./hypseus singe vldp -framefile singe/maddog-hd/maddog-hd.txt -script singe/maddog-hd/maddog-hd.singe -fullscreen -nolog -oversize_overlay -manymouse -blend_sprites

#####################
#FIN CARGARDO MADDOG#
#####################

COMPILAR HYPSEUS (Daphne)
==========================

Clonamos el repo de btlab:
git clone --depth 1 https://github.com/btolab/hypseus.git

Ahora, creamos directorio de compilación dentro de src, y usamos cmake y luego make:

cd src
mkdir b4
cd b4

cmake .. -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer"

make -j4

Copia, al mismo directorio donde metas el ejecutable hypseus, los directorios fonts y pics.

Los detalles sobre los dip switches están en dle21.txt, que acompaña a las roms del Dragon's Lair Enhanced 2.1
Recuerda que ahí se cuentan los switches del 0 al 7. Se empieza de derecha a izquierda a contar.
Por lo demás, el banco A es el 0, y el B es el 1.

CREAR UN ALIAS EN LINUX DE MANERA PERMANENTE
===============================================

Lo añadimos a ~/.bashrc. Por ejemplo, para que make se ejecute siempre en las CPUs privilegiadas del 1 al 3:
alias make='chrt -r 1 taskset -c 1-3 make'

HACER ALGO EN UN SCRIPT DE LINUX SÓLO SI EXISTE UN FICHERO
========================================================

Es muy útil, por ejemplo, para montar unidades sólo si no están montadas ya, etc...

#!/bin/bash
if [ ! -f mnt/mpeg/lair/lair.txt ]
then
    echo "Montando unidad mpeg..."
    sudo mount /dev/sda1 mnt
fi

DUDA: SI USO UN KERNEL CON EL SCHEDULER PUESTO A 100HZ, ¿PUEDO ESPECIFICAR usbhid.jspoll=1 QUE HACE QUE LOS USB SE LEAN A 1000HZ?
=============================================================================================================================

Sí. El kernel corre sobre HRTIMERS, lo de los 100HZ es la velocidad del sheduler, es decir, cuántas veces por segundo mira a ver qué se ejecuta dónde.
Son cosas distintas e independientes, la granularidad del kernel es mucho mayor que 100HZ... eso es sólo el scheduler.
Y el scheduler, en tus sistemas de no-escritorio, va de sobra a 100Hz para una cosa que ejecutas a la vez (mas el housekeeping del kernel fuera de las CPUs aisladas).
Así que sí, se puede.

COMPILAR FROTZ 
===============

Instala las ncursesw, que es una versión más mehó de las ncurses:
sudo apt-get install libncursesw5-dev

Si quieres sonido en modo texto, instala estas dependencias antes, PERO NO HACE FALTA PORQUE SFROTZ TIENE SONIDO
A TRAVÉS DE LAS SDL, así que simplemente los juegos con audio lánzalos con sfrotz.
sudo apt-get install libao-dev libsamplerate0-dev libsndfile1-dev --no-install-recommends

Baja los surces de la última estable de:
https://gitlab.com/DavidGriffith/frotz/-/releases

Ahora edita src/sdl/sf_video.c:
-Añade estos FLAGS a la línea de SDL_CreateRenderer()
SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
-Añade esta línea antes de que se creen la ventana y el renderer
SDL_ShowCursor(SDL_DISABLE);

Ahora edita el Makefile y:
-Pon sound a NONE si no quieres sonido en modo texto (sin SDL). En sfrotz el sonido va por las SDL,
 así que usa SFROTZ para los juegos que tienen sonido, y ya.
-Comenta la línea de los CFLAGS del -g, y en la que tiene el -O3, y añade el flag -fsigned-char y los flags propios de la Pi4.

Ahora compila con "make frotz" (hay "make sfrotz" para SDL, etc...)
Y sudo make install

Para compilar SFROTZ, no te olvides de pasar el CFLAG -fsigned-char, o el cursor aparecerá descolocado. En el futuro no debería ser necesario.

Hay juegos con sonido, gráficos, etc.. Estos añadidos van en ficheros .BLB, que te puedes bajar de aquí ya preparados:
http://www.ifarchive.org/indexes/if-archiveXinfocomXmediaXblorb.html
Luego sólo tienes que lanzar el sfrotz (que es el que soporta gráficos, y sonido sin depender de AO) pasándole tanto el archivo del juego como
el blb, tal que así:
sfrotz SHERLOCK.Z5 SHERLOCK.BLB
OJO que para que Sherlock suene necesitas el .DAT o .Z5 (son lo mismo) de la versión de Amiga, NO la de PC.

PARA CAMBIAR LA FUENTE DE LETRA POR UNA TRUETYPE ESCALADA CON ANTIALIAS (o sea, un lujazo!)
-Instala el paquete:
sudo apt-get install fonts-dejavu-extra
-Crea el fichero ~/.sfrotzrc con el contenido:

[Window]
AcWidth = 1280
AcHeight = 800 

[Fonts]
fontdir=/usr/share/fonts/truetype/dejavu
textroman=DejaVuSans.ttf@24
textbold=DejaVuSans-Bold.ttf@24
textitalic=DejaVuSans-Oblique.ttf@24
textbolditalic=DejaVuSans-BoldOblique.ttf@24
fixedroman=DejaVuSansMono.ttf@24
fixedbold=DejaVuSansMono-Bold.ttf@24
fixeditalic=DejaVuSansMono-Oblique.ttf@24
fixedbolditalic=DejaVuSansMono-BoldOblique.ttf@24
antialias=1

NOTA: Los valores de AcWidth y AcHeight se han elegido por ser múltiplos de los 640x400 originales que usa sfrotz,
de manera que las imágenes gráficas se escalan correctamente y además se usa una fuente DejaVu tamaño 30 para que salgan
los mismos caracteres por línea que con la fuente VGA original.

NOTA2: Para que, al salvar partida o al cargar, SFROTZ no nos saque diálogos gráficos, sino que nos pida el filename a mano como debe ser,
le pasamos el parámetro -T.

PARA CONVERTIR JUEGOS DE THE QUILL A FROTZ
Puedes convertir juegos de THE QUILL a .z5 para el frotz con el unquill: https://www.seasip.info/Unix/UnQuill/
Pero el unquill recibe .SNA, y lo más que hay por ahí son .Z80, así que para pasar .SNA a .Z80 usa el spconv:
https://live.worldofspectrum.org/infoseek/utils
Una vez que tengas el .SNA, sólo tienes que hacer:
./unquill -T5 -L -OBORED1.z5 BORED1.SNA
Tienes juegos de THE QUILL en .Z80 en: http://ifmirror.russotto.net/indexes/if-archiveXgamesXspectrum.html


COMPILAR FROTZ VERSIÓN SDL, QUE SOPORTA ACENTOS, SIN INSTALAR LIBJPEG EN EL SISTEMA
===================================================================================

Empezamos compilando libjpeg-turbo, que nos va a hacer falta la versión estática de las librerías. Pillamos la última versión estable de su repo:
https://github.com/libjpeg-turbo/libjpeg-turbo/releases

Ahora creamos directorio de compilación, entramos, y configuramos con CMAKE así:
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" cmake -DCMAKE_BUILD_TYPE=Release ..

Ahora, clonamos el repo del FROTZ:
git clone --depth 1 https://github.com/DavidGriffith/frotz.git

Ahora, en el directorio de los sources del FROTZ, nos creamos un directorio llamado jpeg, donde vamos a meter las librerías estáticas y los headers de libjpeg. 
Vamos a necesitar tener en nuestro directorio jpeg dentro de los sources del FROTZ estos archivos (unos del diretorio raiz de los sources de libjpeg y otros de nuestro
directorio de compilación de libjpeg, b3 o como lo llames):
jconfig.h 
jmorecfg.h 
jpeglib.h 
libjpeg.a

Ahora, editamos el Makefile del FROTZ, y a los CFLAGS le añadimos, para que encuentre los headers de SDL2, de freetype2, de la libjpeg que hemos compilado, etc, 
quedando así la línea de CFLAGS:
CFLAGS += -I$(INCLUDEDIR) -I/usr/include/SDL2 -I/usr/include/freetype2 -I/home/pi/src/frotz/jpeg

Y la línea de LDFLAGS quedará así:
jpeg/libjpeg.a -lSDL2 -lSDL2_mixer -lz -lfreetype -lpng
(Como ves, no le pasamos -ljpeg, sino que directamente le pasamos la librería estática al linker y listo).

CONFIGURAR BLUETOOTH MANUALMENTE Y CONECTARSE A DISPOSITIVOS EN LA RASPBERRY PI
=================================================================================

Instalamos los paquetes requeridos para usar hcitools y todo eso:

sudo apt-get install bluez

Insertamos los módulos necesarios del kernel y conectamos el sistema de gestión hci a nuestro hardware bluetooth:

sudo modprobe hci_uart
sudo modprobe btbcm
sudo hciattach /dev/ttyAMA0 bcm43xx 921600 noflow -

Ahora deberíamos poder ver qué dispositivos bluetooth tiene nuestro microordenador:

sudo hciconfig -a

Ahora levantamos nuestro dispositivo hci:

sudo hciconfig hci0 up

Podemos ver más información con esto:

sudo hciconfig dev

Escaneamos dispositivos bluetooth al alcance:

sudo hcitool scan

Si aparece el nuestro, nos podemos conectar con:

hcitool cc 30:23:18:DA:8A:AE
hcitool lecc 30:23:18:DA:8A:AE

Listamos las conexiones hechas con:

hcitool con

Para quitar el LAG:

sudo iwconfig wlan0 txpower off
O bien deshabilitar el WIFI en el inicio con:
dtoverlay=pi3-disable-wifi

hcitool con (para verificar que está conectado!)
sudo hcitool enc 30:23:18:DA:8A:AE off
sudo hcitool sr 30:23:18:DA:8A:AE slave

ADVENTURE ORIGINAL EN LA PI USANDO SIMH
=======================================

Clonamos el repo de simh:
git clone --depth 1 https://github.com/simh/simh.git

Editamos el makefile y comentamos toda la sección donde detecta libpng (busca png y comenta ese bloque)
También le puedes añadir los flags de la arquitectura donde se añade el -fipa-cp-clone, por ejemplo.

Compilamos sólo el simulador de pdp8 que es el que vamos a usar
make pdp8
El ejecutable queda en BIN/pdp8

Ahora necesitamos el adventure y un .ini que irá en el mismo directorio que el ejecutable pdp8. Todo eso viene en un blog:
https://raymii.org/s/articles/Running_ADVENT-on-the-PDP-8-with-SIMH.html

DESCARGAR LIBROS DE GOOGLE BOOKS EN PDF
========================================

sudo apt-get install python-glade2

git clone https://github.com/tokland/pysheng
cd pysheng
sudo python setup.py install

Y para que guarde en PDF:
pip install reportlab

DESHABILITAR SCREEN LOCK (BLOQUEO DE PANTALLA) TRAS SUSPENDER
=============================================================

No es cosa de xscreensaver, aunque se usa para bloquear.
El setting está en: 
preferences->LXQT Settings->Session settings->Lock screen before suspending

MPS-YOUTUBE: CÓMO HACER QUE FUNCIONE EN RASPBIAN (Y EN GENERAL)
===============================================================

Lo primero, NO INSTALES MPS-YOUTUBE O YOUTUBE-DL DESDE APT-GET o el gestor de paquetes que sea: instálalo siempre desde pip,
pero NO hagas una instalación tipo user como dicen las instrucciones, sino exactamente así:

sudo pip3 install -U git+https://github.com/mps-youtube/mps-youtube.git

O así, si quieres la versión estable:

sudo pip3 install mps-youtube

NO OLVIDES instalar youtube-dl desde pip también, ya que es una versión de youtube-dl que se instala entre las extensiones de phyton:

pip3 install youtube-dl

Al lanzarlo puede que te diga que no encuentra mplayer, porque no puedes especificarle otro player ya que aún no lo haz lanzado. Vale, pues instala mplayer:
sudo apt-get install --no-install-recommends mplayer

Ahora entras en mps-yt y haces:
set player omxplayer
o bien
set player vlc

Y a continuación desinstala mplayer y sus dependencias:
sudo apt-get purge mplayer
sudo apt-get autoremove

Ahora, para que mps-yt te busque vídeos y no sólo audio, haz:
set search_music false
Y para que se vea el vídeo, ya que por defecto sólo reproduce el audio, haz:
set show_video true

RESTAURAR (UNDELETE) ARCHIVOS BORRADOS EN UN FILESYSTEM EXT4
============================================================

Se hace con extundelete. Desmonta la partición en la que estaba el archivo antes de pasarte extundelete.
Si no te sabes el nombre del archivo, extundelete te lo sugerirá, así que tranquilo.

sudo extundelete /dev/sdb5 --restore-file installed_os.json

Te lo va a guardar en RESTORED_FILES, en el directorio donde estés cuando ejecutes extundelete. Así que lo tienes que copiar a mano a donde estaba originalmente.

Si fuese en un fat32, usa testdisk.
Keep calm and... undelete!

INSTALANDO UN SISTEMA CUSTOM EN NOOBS
=====================================

Normalmente no es posible instalar un nuevo SO después de instalar NOOBS en una SD, pero bueno, yo lo he hecho y no es para tanto.
-Creamos las particiones. Necesitamos dos: una en FAT32, y otra en EXT4 (si vas a instalar un GNU/Linux propio "from scratch" por ejemplo, como un sistema de 64 bits, etc)
	Vamos a suponer que quedan como sdb8 (fat32) y sdb9 (ext4) desde el PC. Una es la partición de boot y otra la de rootfs, obviamente. Les puedes poner de nombre CUSTOM_BOOT
	y CUSTOM_ROOT, por ejemplo. Se cambia el nombre de las particiones con fatlabel para la fat32 y e2label para la ext4.
	Apunta también sus PARTUUID, que puedes averiguar con sudo blkid /dev/sdb8 y blkid /dev/sdb9

-En la partición boot copia todo lo que se necesita (kernel, dbts, overlays, ficheros de configuración, firmware, etc...). Con cp -R vale.
-En la partición del rootfs copia el rootfs del sistema a instalar, pero recuerda hacerlo con rsync -av --progress origen/* destino/ ,
NO con cp que la lías con los permisos.
-Crea una entrada nueva para el sistema en el fichero installed_os.json de la partición SETTINGS de NOOBS, es decir, en SETTINGS/installed_os.json. Por ejemplo así:
{ 
  "bootable" : true,
  "description" : "Sistema GNU/Linux de 64bits para juegos",
  "folder" : "/settings/os/debian64",
  "icon" : "/settings/os/debian64/icon.png",
  "name" : "Debian 64 bits",
  "partitions" : [
"/dev/mmcblk0p8",
"/dev/mmcblk0p9"
  ],
  "release_date" : "2018-11-13",
  "supported_models" : [
"Pi 3"
  ]
 },

^^^Como ves, ahí se le especifican las particiones que tiene. El directorio SETTINGS/os/debian64 lo creamos nosotros también y metemos ahí el icono que queramos que
se muestre en el arranque. Con el icono vale, no hace falta tener nada más en ese directorio.
El icono tendrá un tamaño de 40x40 pixels en png para no desentonar con el tamaño de los demás. Aqui tienes un ejemplo:
http://www.iconarchive.com/show/super-mario-icons-by-ph03nyx/Retro-Block-Question-icon.html 
Puedes escalar cualquien imágen con GIMP, en image->scale image, y dejarla a 40x40 que es lo que se necesita.

-Ahora edita el cmdline.txt del sistema custom que acabas de instalar, y ajusta el parámetro root= con el PARTUUID de la partición de rootfs.
-Ahora edita el /etc/fstab del sistema custom que acabas de instalar, y lo mismo, ajusta los dos PARTUUID a los de la partición boot y rootfs.
...Y ya debería arrancar sin ningún problema.
Si te sale sólo la pantalla en negro, es que el kernel necesita los módulos instalados en el rootfs para poder mostrar algo por pantalla.

USAR WIFI EN LA RASPBERRY PI 4 CON KERNEL GENÉRICO
==================================================

Asegúrate de no tener blacklisteado el módulo brcmfmac en /etc/modprobe.d. Con ese módulo cargado ya deberías poder ver el interface wlan0
con iwconfig.

O bien, déjalo blacklisteado, y lo cargas manualmente en: 

sudo modprobe brcmfmac

INSTALAR LIBREELEC EN UNA SD CON NOOBS QUE YA TIENE OTROS SISTEMAS INSTALADOS
=============================================================================

Es igual que lo de instalar un sistema custom tuyo, solo que lo vamos a ver de manera más resumida.
-Creamos con GPARTED las dos particiones necesarias en la SD donde haya espacio libre: una de FAT32 de 512MB llamada LIBREELEC y otra en EXT4 del tamaño que puedas llamada STORAGE.
 No hay que cambiar nada en gparted al crearlas, los tipos por defecto fata FAT32 y EXT4 nos valen.
-Copiamos los contenidos de la partición LIBREELEC de la imágen descargada de LibreeElec para Raspberry Pi a nuestra partición LIBREELEC de la tarjeta (tienes en este mismo documento cómo montar una partición individual de una imágen con varias particiones, es muy fácil).
 La partición STORAGE la dejamos vacía totalmente.
-MUY IMPORTANTE: ajustamos los parámetros boot= y disk= de cmdline.txt en la partición LIBREELEC de la tarjeta, poniendo los UUID de las dos particiones LIBREELEC y STORAGE
 que puedes conseguir en gparted, mirando INFORMATION de cada una de las particiones.
-Creamos la nueva entrada para LibreeElec el archivo installed_os.json de la partición SETTINGS de la tarjeta, es decir, en /media/manuel/SETTINGS/installed_os.json.
 En ella tienes que poner qué particiones va a tener disponibles el sistema. La manera más fácil de ver qué número tiene cada partición es con fdisk -l, pero también lo puedes
 mirar en gparted. Mi entrada queda así:


{ 
  "bootable" : true,
  "description" : "Distro orientada a la reproducción de audio y vídeo",
  "folder" : "/settings/os/libreelec",
  "icon" : "/settings/os/libreelec/icon.png",
  "name" : "LibreElec",
  "partitions" : [ 
"/dev/mmcblk0p12",
"/dev/mmcblk0p13"
  ],  
  "release_date" : "2019-02-05",
  "supported_models" : [ 
"Pi 2",
"Pi 3",
"Pi Compute Module 3"
  ]
},

¡¡CUIDADO CON LA COMA DEL FINAL!! SI EL SISTEMA QUE VAS A INSTALAR ES EL ÚLTIMO, NO TE HACE FALTA UNA COMA, PERO SI NO, PUES SÍ. Y SI NO LA PONES, TE VA A SALIR
EL MENÚ EN BLANCO.

-Ahora ya sólo queda crear el directorio /media/manuel/SETTINGS/os/libreelec, y encontrar un png adecuado para ser el icon.png de ese directorio: 
Tiene que ser de 40x40 pixels: puedes coger cualquier imágen y escalarla con GIMP: la abres, pinchas sobre ella con el boton derecho, image->scale image.
Si necesitas recortarla, usa el rectángulo de selección (arriba a la izquerda), y luego en image->crop to selection.
En SETTINGS/os/libreelec, con que esté el archivo icon.png vale, no hace falta nada más.

USAR MAME (a palo seco)
=======================

Va contra las SDL2 y usa el renderer que usen las SDL2.
Primero creamos un .ini en el directorio actual:
mame -createconfig
Lo editamos a nuestro gusto, y le pasamos a MAME la ruta del .ini para cargarlo:
mame -inipath /home/manuel/mame ridgerac
Uno de los sitios donde busca por defecto los .zip de las ROMs es en $HOME/mame/roms, pero pedemos espeficar otras rutas en el .ini

COMPRIMR CUE/BIN A CHD
======================

Necesitamos las mame-tools:
sudo apt-get install mame-tools p7zip-full

Y se comprime pasándole el CUE:
chdman createcd -i BC\ Racers.cue -o BC\ Racers.chd

Si tienes un directorio con varios 7z (cada uno de los cuales conteniendo un cue/bin), puedes convertir todos los 7z
de ese directorio usando este sencillo script:

		------
		
#!/bin/bash
#extract 7z
  for x7zFile in *.7z; do
                gameName="$(basename "$x7zFile" .7z)"
                echo "!!!!!!!!!!Extracting ${gameName}..."
                7z x "${x7zFile}" -o./"${gameName}-tmp"

                echo "!!!!!!!!!!Converting ${gameName}..."
                chdman createcd -i "./${gameName}-tmp/${gameName}.cue" -o ./"${gameName}.chd"
#rm temporary directory
                rm -R ./"${gameName}-tmp"
### uncomment below to rm the original 7z archive
#               rm ./"$x7zFile"

                echo "!!!!!!!!!!${gameName} complete..."
done
echo "All done."

		-------

Y para convertir todos los cue/bin de un directorio, usa este script:
for i in *.cue; do chdman createcd -i "$i" -o "${i%.*}.chd"; done

ESCRIBIENDO Y GESTIONANDO SERVICIOS EN SYSTEMD
==============================================

Por ejemplo, he creado el servicio retroarch.service y lo he puesto en /etc/systemd/system/retroarch.service

El contenido de retroarch.service es:

[Unit]
Description=RetroArch service

[Service]
User=pi
Group=pi
ExecStart=/home/pi/retro/ragui.sh
Restart=always

[Install]
WantedBy=multi-user.target

Para habilitarlo, lo que hago es:
systemctl enable retroarch

En realidad esto lo único que hace es copiar /etc/systemd/system/retroarch.service a /etc/systemd/system/multi-user.target.wants/retroarch.service, es decir, lo mete
en el directorio del target "multiuser", que es el último, supongo, cuando se inicia el sistema. (Bueno, crea un symlink, pero ya me entiendes).

Naturalmente, "systemctl disable retroarch" hace lo contrario: borra /etc/systemd/system/multi-user.target.wants/retroarch.service.

Saber esto nos permite habilitar y deshabilitar servicios manualmente sin necesidad de que arranque el sistema, accediendo al rootfs desde otro ordenador.

MÚSICA GRAVIS ULTRASOUND Y EFECTOS DE SONIDO EN DUNGEON MASTER 2 EN DOSBOX
==========================================================================

Necesitamos el directorio ULTRASND en C:\

Ahora, en el directorio del dm2, actualizamos el driver HMI desde el archivo de la web:
http://dmweb.free.fr/?q=node/612
Si no lo encuentras, pues copia los archivos desde el Anvil of Dawn.
Los archivos a sobreescribir para actualizar el driver son:

DRUM.BNK
HMIDET.386
HMIDRV.386  
HMIMDRV.386  
MELODIC.BNK  
SETUP.EXE  
TEST.HMI  
TEST.WAV
(CUIDADO, puedes acabar con cada archivo dos veces, una en mayúsculas y otra en minúsculas, 
así que te puedes quitar de problemas convirtiendo todo lo del dm2 a mayúsculas con: 
for f in *; do mv "$f" "${f^^}"; done
Acuérdate de convertir a mayúsculas también los archivos del subdirectorio DATA!).
Ahora ya sobreescribe los archivos desde el anvil o desde el zip de la actualización, lo que tengas más a mano.

Copiamos desde el Anvil of Down los archivos LOADPATS.EXE y PATCHES.INI

Tenemos que poner la Sound Blaster 16 en la dirección 240 y la GUS en la 220, o no funcionará el MIDI de la GUS.

En el setup del dm2, elegimos la SB16 para efectos de sonido (OJO! poniendo bien su IRQ), y luego seleccionamos como MIDI la GUS, sólo como MIDI!
Ejecutamos LOADPATS.EXE cada vez que carguemos el dm2. Debería funcionar si tienes una GUS activada y el ULTRASND en C:\

Tengo el DM2.BAT exactamente así (si viene puesto +VS, quítalo, para que vaya a 60HZ el juego y no a 70HZ):
LOADPATS
EREGCARD
IBMIOP SKULL.EXE

Puedes (debes, por comodidad) borrar el archivo INTRO.

Y ya debería ir... Ya sabes: Sound Blaster para los efectos, y GUS para la música. Es cutre, pero funciona de momento.

TURRICAN 2 EN DOSBOX
====================

En todas las páginas viene una versión que no funciona. 
Lo único que les falta a todas es establecer la variable de entorno "T2DIR" apuntando al diretorio "CFG" que viene con el juego.
Para que funcione, simplemente créate un PLAY.BAT con este contenido (suponiendo que tenemos el juego en C:\JUEGOS\T2):

@echo off
cls
set t2dir=c:\juegos\t2\cfg
oversmpl on
t2

Con esto ya te saldrá el menú con todas sus opciones, y el juego funcionará bien.
Para que vaya el audio, selecciona la SoundBlaster PRO, PUERTO 220, IRQ 7, DMA 1 (y que estén igual en la config del DOSBOX, claro).
NO TE MOLESTES con el audio GUS, suena peor que con SBPro...

LA MEJOR PÁGINA PARA BAJAR PELÍCULAS BUENAS Y ALTERNATIVAS
==========================================================

Busca ZOOWOMAN y el nombre de la peli.

ACTUALIZAR EL FIRMWARE DEL 8BITDO SN30
======================================

Conéctalo y escribe en la consola de comandos:

fwupdmgr get-devices

Luego haz:

fwupdmgr get-updates

Y si hay algo nuevo, pues se actualizará. Más fácil imposible.

Poner RETROARCH en el arranque de una manera moderna, basado en systemd
=======================================================================

Creamos el fichero del servicio en etc/systemd/system/retroarch.service, con este contenido:

[Unit]
Description=Systemd service and user to run Retroarch in stand-alone mode

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=/root/retro
ExecStart=
ExecStart=-/usr/bin/retroarch
Restart=always

[Install]
WantedBy=multi-user.target

y activaríamos el unit con 
sudo systemctl enable retroarch.service

Naturalmente, el ejecutable tiene que estar en /root/bin/retroarch, o donde sea pero que coincida con lo que dice el .service
Puedes quitar el Restart=always para hacer pruebas, porque al quitarlo se sale al TTY1 si tienes una consola ahí.

Si quieres tener diferentes cmdline.txt (en diferentes particiones boot) que lancen diferentes cosas, puedes:
1) NO activar el servicio
2) Entonces, puedes decirle a systemd que lance un servicio no activado desde el cmdline.txt con:
systemd.unit="retroarch.service"
3) Puedes hacer que cuando salgas del programa que sea la máquina se reinicie(y así puedes elegir otro): para ello, aniade en la sección [Unit] del .service:
SuccessAction=reboot

Algunos programas, como el Scummvm, necesitan en la sección [Service]:
WorkingDirectory=/root/scummvm
..O si no, no detecta los juegos que aniades.
Lo mismo pasa con todo lo que lances con un script en el que tienes un ejecutable al que le pasas cosas. Como no tengas un WorkingDirectory, no encontrará las cosas que le pasas.
Por ejemplo, para el doom (doomretro, siendo doom.sh un script donde a doomretro se le pasa un iwad y tal), haríamos:

[Unit]
Description=Systemd service and user to run Doom in stand-alone mode

[Service]
User=root
Group=root
PAMName=login
WorkingDirectory=/root/doom
ExecStart=
ExecStart=-/root/doom/doom.sh
Restart=always

[Install]
WantedBy=multi-user.target

OJO!!! doom.sh debe empezar con #!/bin/bash en la primera línea, o no funcionará! Esto igual para todos los scripts que lances desde units.

OPENFODDER, versión opensource de Cannon Fodder 1 y 2
==============================================

Clonamos el repo:

git clone --depth 1 https://github.com/OpenFodder/openfodder.git

Entramos en los sources y editamos el Makefile, cambiando el clang++ por g++, y quitamos el -ferror-limit=100 que eso es específico del CLANG ese.
Aniadimos las FLAGS que queramos, ya de paso.

Ahora, nos creamos ~/cf, y ahí:
-Copiamos el ejecutable que tendrás recién compilado en Run/OpenFodder
-Copiamos el archivo openfodder.ini.example a ~/cf/openfodder.ini, y lo dejamos a nuestro gusto
-Descomprimimos directamente los contenidos de un ZIP de datos del engine que está aquí:
https://github.com/OpenFodder/data/releases

Dentro del directorio Data de los datos del engine, si te fijas verás que hay directorios preparados para cada juego.
Nos interesa el directorio Dos_CD: ahí es donde meteremos los datos del juego en su versión DOS, que tiene más colores. Sólo nos hace falta el archivo CF_ENG.DAT.
Por si te lo preguntas, los datos de Amiga aún no parecen funcionar bien con el engine, da segfaults y movidas. Pero con la versión DOS, la música suena también en MOD, así que nos vale.

HEART OF DARKNESS en linux (HODE)
=================================

Bajamos la última versión de los sources de:
http://cyxdown.free.fr/hode/

Editamos el Makefile:
-Quitamos el -g y añadimos en su lugar los FLAGS: -O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer

Editamos system_sdl2.cpp  y:

-Dejamos la línea
desired.samples = 4096;
como
desired.samples = 512;

-Añadimos SDL_RENDERER_PRESENTVSYNC a la llamada de SDL_CreateRenderer()
-Puedes ajustar los controles del joystick también en system_sdl2.cpp:
Busca SDL_CONTROLLER_BUTTON y ahí asignas como quieras. Pero OJO, si ves SDL_CONTROLLER_BUTTON_B, no es el B del mando SN30 sino el B de un mando de XBOX360 que es como se detecta el mando en el ordenador. Así que mírate una foto del mando de 360 para hacerlo.
De todos modos, yo lo tengo así, de arriba a abajo: X, A, B, Y. Así coincide con los controles de PSX.

En el directorio donde va el ejecutable, creamos hode.ini con el contenido:

[engine]

# disable animations playback
disable_paf=false

# disable monsters handling code
disable_mst=false

# disable sound handling code
disable_sss=false

# maximum number of active sounds (original engine sets to 10 if a slow CPU or low memory is detected)
max_active_sounds=16

# 0:easy 1:normal 2:hard
difficulty=0

# frame duration in milliseconds (original is 80ms, eg. 12.5hz)
frame_duration=50


[display]

# scaling factor for game graphics (base resolution is 256x192)
scale_factor=1

# scaling algorithm for game graphics ('xbr', 'nearest', 'linear' or 'none')
scale_algorithm=none

# gamma correction
gamma=1.0

# use intensity color
grayscale=false

# fullscreen display
fullscreen=true

# widescreen (16:9)
widescreen=false

-Una vez que lo tengamos todo, ejecutamos con:
./hode --datapath=data_pc
...Donde data_pc es un directorio donde están los datos del juego (ver README para saber qué archivos se necesitan).
Las teclas son las flechas F, G y H.

Neverball en la Raspberry Pi
============================

Clonamos su repo en:
git clone --depth 1 https://github.com/Neverball/neverball.git

Compilamos con
CFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
CXXFLAGS="-march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
make ENABLE_OPENGLES=1 ENABLE_FS=stdio ENABLE_NLS=0 BUILD=release -j4

VVVVVV en la Raspberry Pi
=========================

Entramos en su repo y clonamos

git clone --depth 1 https://github.com/TerryCavanagh/VVVVVV.git

Entramos en desktop_version, creamos b4 y configuramos con:

cmake -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_C_FLAGS="-DNDEBUG -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" \
-DCMAKE_CXX_FLAGS="-DNDEBUG -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer" ..

Bajamos el data.zip que viene con la versión Windows del VVVVVV, disponible aquí:
https://thelettervsixtim.es/makeandplay/
Ponemos el data.zip junto al ejecutable... Y listo!

Puedes ocultar el cursor del ratón y poner el filtro bilineal en ~/.local/share/VVVVVV/saves/settings.vvv

DESCARGAR DESDE EMUPARADISE
===========================

Con el Firefox (si no funciona, usa Chromium) nos instalamos la extensión tampermonkey.
Ahora desde el Chromium también nos vamos a abrir este script: https://gist.github.com/infval/c69b479ff0bd590f2dd7e1975fe2fcad
Le damos a RAW (es como un github), y nos saldrá un botón de INSTALL. Instalamos el script, es un script para el tampermonkey.
Ahora nos vamos a emuparadise, le damos a Download Links de lo que queramos bajar, y nos sale una opción nueva que es "download with workaround script". Le damos y empieza a bajar.

HACER QUE LOS MANDOS SEAN DETECTADOS COMO GAMEPAD POR LA API DE SDL2
=====================================================================

Lo primero es conocer el GUID del controller. El GUID es propio de las SDL, no se puede sacar de otro sitio, y es el resultado de fundir el bus, vendor, product and version numbers en un sólo valor.

El programa con el que sacamos el GUID de un controller es este:

#include <SDL.h>

int main()
{
  SDL_Init(SDL_INIT_JOYSTICK);
  atexit(SDL_Quit);

  int num_joysticks = SDL_NumJoysticks();
  int i;
  for(i = 0; i < num_joysticks; ++i)
  {
    SDL_Joystick* js = SDL_JoystickOpen(i);
    if (js)
    {
      SDL_JoystickGUID guid = SDL_JoystickGetGUID(js);
      char guid_str[1024];
      SDL_JoystickGetGUIDString(guid, guid_str, sizeof(guid_str));
      const char* name = SDL_JoystickName(js);

      int num_axes = SDL_JoystickNumAxes(js);
      int num_buttons = SDL_JoystickNumButtons(js);
      int num_hats = SDL_JoystickNumHats(js);
      int num_balls = SDL_JoystickNumBalls(js);

      printf("%s \"%s\" axes:%d buttons:%d hats:%d balls:%d\n", 
             guid_str, name,
             num_axes, num_buttons, num_hats, num_balls);

      SDL_JoystickClose(js);
    }
  }

  return 0;
}


Compilamos este programa con:

gcc -o sdl2-joystick sdl2-joystick.c `pkg-config --libs --cflags sdl2`


Si queremos que el SN30 de 8Bitdo se detecte como un gamepad (importante en SDLPop!), tenemos que añadir en src/joystick/SDL_gamecontrollerdb.h, en la parte de #if defined(__LINUX__):
"03000000c82d00000031000011010000,8Bitdo Receiver,a:b1,b:b0,back:b10,leftshoulder:b6,leftx:a0,lefty:a1,rightshoulder:b7,start:b11,x:b4,y:b3,",

O bien en /etc/profile
export SDL_GAMECONTROLLERCONFIG="03000000c82d00000031000011010000,8Bitdo Receiver,a:b1,b:b0,back:b10,leftshoulder:b6,leftx:a0,lefty:a1,rightshoulder:b7,start:b11,x:b4,y:b3,platform:Linux,"

Y si queremos que el mando de DreamCast se detecte como gamepad, tenemos que añadir en src/joystick/SDL_gamecontrollerdb.h, en la parte de #if defined(__LINUX__):
"030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,",

O bien en /etc/profile
export SDL_GAMECONTROLLERCONFIG="030000009b2800000800000001010000,raphnet.net Dreamcast to USB,a:b10,b:b9,x:b2,y:b1,back:b0,guide:b3,start:b8,dpup:b4,dpdown:b5,dpleft:b6,dpright:b7,platform:Linux,"


DESCARGAR DE MEGA POR CACHOS CON LAS MEGATOOLS
==============================================

Se usa megadl.

Instalamos dependencias previas:
sudo apt-get install libglib2.0-dev libcurl4-gnutls-dev libssl-dev meson

Clonamos el repo de las megatools:
git clone --depth 1 https://megous.com/git/megatools

Creamos el directorio de compilación, entramos en él y configuramos con meson:
mkdir b4
cd b4
meson ..

Compilamos
ninja -j4
sudo ninja install

Y ya podemos descargar con:
megatools dl <LINK DE MEGA>
O bien
megadl <LINK DE MEGA>

WARCRAFT II NATIVO EN LINUX
===========================

Nos hacen falta dos cosas: el stratagus que es el engine, y el wargus que es un importador del WCII para que funcione para stratagus.

Instalamos dependencias previas:
sudo apt-get install tolua++ libluajit-5.1-dev libbz2-dev --no-install-recommends

Instalamos el stratagus:
git clone --depth 1 https://github.com/Wargus/stratagus.git
cd stratagus && mkdir b3 && cmake .. && make -j4 && sudo make install


Instalamos el wargus:
git clone --depth 1 https://github.com/Wargus/wargus.git
cd wargus && mkdir b3

Ahora atiende: configuramos stratagus pasándole el ejecutable del stratagus que tenemos instalado y el path de gameheaders, que es un directorio de los sources de stratagus. Es fácil, por ejemplo si tenemos los sources de stratagus en ~/src/stratagus, sólo hay que hacer:
cmake .. -DCMAKE_PROGRAM_PATH=/usr/local/games/stratagus -DCMAKE_INCLUDE_PATH=~/src/stratagus/gameheaders
make -j4
sudo make install

EJECUTAR EJECUTABLES DE 32BIT (armhf) EN LINU DE 64BIT (aarch64)
================================================================

Lo primero, ver si nuestro kernel soporta compat:
grep CONFIG_COMPAT= /boot/config-$(uname -r)

Ahora a ver qué arquitecturas extranjeras soporta el sistema de gestión de paquetes (nos tiene que salir armhf como mínimo):
dpkg --print-foreign-architectures

Tenemos instalado libc6 versión armhf?
dpkg -l libc6:armhf

Tenemos instalado libc++6 versión armhf?
dpkg -l libstdc++6:armhf

Si nos falta alguna, la instalamos:
sudo apt-get install libstdc++6:armhf

NO CONFUNDAS libstd con libc, son cosas distintas.

EASYRPG, EL MOTOR DE RPGMAKER EN LINUX
======================================

LO COMPILAMOS COMO UN CORE PARA LIBRETRO

Empezamos instalando libclf, que es parte del proyecto EASYRPG, así que hay que instalarla a mano:

Dependencias previas:
sudo apt-get install libexpat1-dev libpixman-1-dev libfmt-dev libsndfile1-dev --no-install-recommends

Ahora vamos a por libclf:
git clone --depth 1 https://github.com/EasyRPG/liblcf.git
mkdir b4
cd b4
cmake -DDISABLE_ICU=ON ..

Ahora vamos a por EASYRPG:
git clone --depth 1 https://github.com/EasyRPG/Player.git
git submodule init
git submodule update
mkdir b4
cd b4
cmake -DPLAYER_TARGET_PLATFORM=libretro -DBUILD_SHARED_LIBS=ON ..

Ahora lo lanzaríamos con:
retroarch -L core <.exe del juego hecho con RPG Maker>

INSTALAR DRIVER IMPRESORA CANON
===============================

Compilarlos a mano desde los sources que da Canon es imposible, porque están rotos a propósito.
Así que hay que añadir unos repos y los instalamos desde ahí con apt-get.
Las instrucciones, en castellano, aquí:

https://www.sololinux.es/instalar-drivers-de-impresoras-canon-en-ubuntu-20-04/

QUAKE 3: IOQUAKE3 EN LINUX
===========================

Clonamos los sources:

git clone --depth 1 https://github.com/suijingfeng/vkQuake3.git

mkdir ~/q3
mkdir ~/.q3a
mkdir ~/.q3a/baseq3

Entramos en los sources y, sin más, hacemos:
CFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -DSDL_DISABLE_IMMINTRIN_H" \
CXXFLAGS="-O2 -march=native -mtune=native -O2 -ftree-vectorize -pipe -fomit-frame-pointer -DSDL_DISABLE_IMMINTRIN_H" make -j4

En X86_64, con hacer make -j4, vale.

Cuando acabe, hacemos:
cd build/release-linux-<nombre_arquitectura>
cp oiquake3* renderer*.so ~/q3
cp -R baseq3/* ~/.q3a/baseq3/ 

Nos bajamos los pak*.pk3 desde el 1 al 8. Los puedes bajar de aquí:
https://github.com/nrempel/q3-server/tree/master/baseq3
...Y los metemos todos en ~/.q3a/baseq3

En la Pi, como NO HAY OpenGL y GLES no vale, sólo Vulkan, creamos:
~/.q3a/baseq3/q3config.cfg
Con el contenido:
seta cl_renderer "vulkan"

Y ya deberíamos poder lanzar el juego, simplemente ejecutando ~/q3/ioquake3.<nombre_arquitectura>

Para activar el renderer Vulkan, sacamos la consola con la tilde (es decir, con ~) y escribimos:
/cl_renderer vulkan
/vid_restart

Y vamos que está bien con:
/vkinfo

ACTUALIZAR RASPBERRY PI OS SIN ACTUALIZAR EL KERNEL
===================================================

Útil para cuando tenemos un kernel especial instalado, como por ejemplo el kernel realtime de: https://github.com/kdoren/linux/releases/

Se hace poniendo el paquete raspberrypi-kernel en "hold", tal que así:

-Actualizamos el índice de paquetes como siempre:
sudo apt-get update

-Ponemos el paquete del kernel en hold:
sudo apt-mark hold raspberrypi-kernel

-Actualizamos los paquetes normalmente. Como el paquete del kernel está en holdo, no se actualizará:
sudo apt-get upgrade

Opcionalmente, si quieres, puedes quitar el hold del paquete del kernel al acabar, haciendo:
sudo apt-mark unhold raspberrypi-kernel

REVENGE OF TITANS EN LA RASPBERRY PI
====================================

Hay un tutorial aquí:
https://www.raspberrypi.org/forums/viewtopic.php?t=290589

El juego usa tres librerías cuyas versiones aarch64 necesitas: 
liblwjgl.so
libopenal.so
lwjgl.jar

Para conseguirlas, vamos al configurador online de LWJGL:
https://www.lwjgl.org/customize
Generamos el paquete, y en los *natives de cada librería tienes los .so que necesitas.
SUSTUTUYE las versiones que trae el juego con las que acabas de generar.

ACCEDER A DISPOSITIVOS USB DESDE ORACLE VIRTUALBOX
==================================================

-Añadir al usuario al grupo vboxusers:
sudo usermod -a -G vboxusers manuel

-Instalar, en el VirtualBox, las "Oracle VM Virtual Box Extension Pack", correspondiente a la versión de VirtualBox que tengas instalada
y que puedes descargar aquí:
https://download.virtualbox.org/virtualbox

-Instalar, en la máquina virtual, las "Virtual Box Guess Additions", que vienen en una ISO llamada "VBoxGuestAdditions.iso"
correspondiente a la versión de VirtualBox que tengamos instalada, y que puedes descargar aquí:
https://download.virtualbox.org/virtualbox/
Tienes que montar la ISO desde la barra superior cuando estés ejecutando la máquina, en DEVICES->OPTICAL DRIVES.

-OJO: Usa USB 2.0 en los dispositivos USB del VirtualBox (en Settings->USB), si usas USB 3.0 probablemente no funcione.

AMS (Advanced Mac Substitute) en LINUX
=======================================

Clonamos el repo:
git clone --depth 1 https://github.com/jjuran/metamage_1

Hacemos:
make ams-linux
(Para X11, make ams-x11)

Para lanzar el programa demo, desde el directorio de los sources:
EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt var/out/minivx -Z v/bin/ams.vx

Para lanzar el Tic-tac-toe, que es otra demo, simplemente tenemos que añadir AMS_APPNAME=Tic-tac-toe
Lo mismo con "Nyanochrome Cat":

EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt AMS_APPNAME=Tic-tac-toe var/out/minivx -Z v/bin/ams.vx

EXHIBIT_INTERACT=interact-x11 PATH="$PWD/var/demo:$PWD/var/out:$PATH" AMS_BIN=var/links/ams-68k-bin/bin AMS_LIB=var/links/ams-68k-bin/lib AMS_MNT=var/links/ams-68k-bin/mnt AMS_APPNAME="Nyanochrome Cat" var/out/minivx -Z v/bin/ams.vx

¿CÓMO FUNCIONA TODO ESTO?
Pues ams.vx, que es un script escrito en Varyx (??), que llama a exhibit que a su vez va llamando a otras herramientas que ya serían ejecutables nativos de Linux.
Por ejemplo, si miras los ejemplos que he puesto, interact-x11 es el frontend x11. (Idealmente habría un interact-sdl2).
Lo que nos interesa son los frontent, es decir, interact-*.

Y si quisieras instalar system-wide:

sudo make ams-linux-inst

EJECUTAR VKCUBE SIN LAS X
=========================

vkcube -m khr -k 0:0:0
(display 0, modo 0, plano 0. Usa --help para más información).

ACELERACIÓN DE VÍDEO EN LA PI4 CON MPV
======================================

Un hilo interesante sobre el asunto: https://www.raspberrypi.org/forums/viewtopic.php?t=316381

Instalamos dependencias previas:
sudo apt-get install libv4l-dev --no-install-recommends

PARTE 1: ffmpeg
-Clonamos su repo: git clone --depth 1 https://git.ffmpeg.org/ffmpeg.git
-Configuramos con:

./configure --enable-libv4l2 --disable-network --disable-debug --disable-encoders --disable-muxers --disable-indevs \
--disable-outdev=fbdev --disable-outdev=oss

Llegados a este este punto, podemos reproducir vídeos con ffplay, para ello:

Lo primero, vermos qué codecs puede hacer desde hardware la Pi: ffmpeg -codecs | grep v4l2m2m

Y ahora elegimos un codec y reproducimos el vídeo usándolo: ffplay -codec:v h264_v4l2m2m -fs <fichero_vídeo> 

PARTE 2: MPV

-Instalamos dependencias previas: sudo apt-get install libass-dev --no-install-recommends
-Clonamos su repo: git clone --depth 1 https://github.com/mpv-player/mpv.git
-Ejecutamos:
./bootstrap.py
-Ahora vemos lo que podemos activar y desactivar con:
./waf configure --help
-Ahora configuramos:
CFLAGS="-DEGL_NO_X11" CXXFLAGS="-DEGL_NO_X11" ./waf configure --disable-rpi-mmal --enable-ffmpeg-strict-abi
-Y ahora compilamos e instalamos:
./waf build -j4
sudo ./waf install

Para usar wayland:
mpv -fs --vo=gpu --hwdec=v4l2m2m-copy --gpu-context=wayland <fichero_vídeo>

Y sin wayland:
mpv -fs --vo=gpu --hwdec=v4l2m2m-copy --gpu-context=drm --drm-connector=1.HDMI-A-1 <fichero_vídeo>
